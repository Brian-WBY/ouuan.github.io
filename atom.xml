<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ouuan的博客</title>
  
  <subtitle>Codes change the world.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ouuan.github.io/"/>
  <updated>2019-04-02T23:52:55.593Z</updated>
  <id>https://ouuan.github.io/</id>
  
  <author>
    <name>ouuan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>树分块学习笔记</title>
    <link href="https://ouuan.github.io/%E6%A0%91%E5%88%86%E5%9D%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://ouuan.github.io/树分块学习笔记/</id>
    <published>2019-03-30T13:18:50.000Z</published>
    <updated>2019-04-02T23:52:55.593Z</updated>
    
    <content type="html"><![CDATA[<p>最近发现 <a href="https://oi-wiki.org/" target="_blank" rel="noopener">OI Wiki</a> 的“树分块”是空的，本来想凭着之前写的<a href="https://ouuan.github.io/%E8%8E%AB%E9%98%9F%E3%80%81%E5%B8%A6%E4%BF%AE%E8%8E%AB%E9%98%9F%E3%80%81%E6%A0%91%E4%B8%8A%E8%8E%AB%E9%98%9F%E8%AF%A6%E8%A7%A3/">莫队教程</a>水一水，结果被告知已经有人写过树上莫队了..于是就得详细介绍一下树分块除了树上莫队以外的应用..然而我除了糖果公园只做过一道树分块..（结果最后并没有找到这道题以外的其它题..）</p><a id="more"></a><h2 id="树分块的方式"><a href="#树分块的方式" class="headerlink" title="树分块的方式"></a>树分块的方式</h2><p>可以参考 <a href="https://oi-wiki.org/misc/mo-algo/#_14" target="_blank" rel="noopener">OI Wiki/莫队算法/真-树上莫队</a>。</p><p>也可以参考 <a href="https://ouuan.github.io/%E8%8E%AB%E9%98%9F%E3%80%81%E5%B8%A6%E4%BF%AE%E8%8E%AB%E9%98%9F%E3%80%81%E6%A0%91%E4%B8%8A%E8%8E%AB%E9%98%9F%E8%AF%A6%E8%A7%A3/#%E6%A0%91%E4%B8%8A%E8%8E%AB%E9%98%9F">ouuan的博客/莫队、带修莫队、树上莫队详解/树上莫队</a>。</p><p>树上莫队同样可以参考以上两篇文章。</p><h2 id="树分块的应用"><a href="#树分块的应用" class="headerlink" title="树分块的应用"></a>树分块的应用</h2><p>树分块除了应用于莫队，还可以灵活地运用到某些树上问题中。但可以用树分块解决的题目往往都有更优秀的做法，所以相关的题目较少。</p><p>顺带提一句，“gty的妹子树”的树分块做法可以被菊花图卡掉。</p><h3 id="BZOJ4763-雪辉"><a href="#BZOJ4763-雪辉" class="headerlink" title="BZOJ4763 雪辉"></a><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=4763" target="_blank" rel="noopener">BZOJ4763 雪辉</a></h3><p>先进行树分块，然后对每个块的关键点，预处理出它到祖先中每个关键点的路径上颜色的 bitset，以及每个关键点的最近关键点祖先，复杂度是 $\mathcal O(n\sqrt n+\frac{nc}{32})​$，其中 $n\sqrt n​$ 是暴力从每个关键点向上跳的复杂度，$\frac{nc}{32}​$ 是把 $\mathcal O(n)​$ 个 bitset 存下来的复杂度。</p><p>回答询问的时候，先从路径的端点暴力跳到所在块的关键点，再从所在块的关键点一块一块地向上跳，直到 $lca$ 所在块，然后再暴力跳到 $lca$。关键点之间的 bitset 已经预处理了，剩下的在暴力跳的过程中计算。单次询问复杂度是 $\mathcal O(\sqrt n+\frac c{32})$，其中 $\sqrt n$ 是块内暴力跳以及块直接向上跳的复杂度，$\mathcal O(\frac c{32})$ 是将预处理的结果与暴力跳的结果合并的复杂度。数颜色个数可以用 bitset 的 <code>count()</code>，求 $\operatorname{mex}$ 可以用 bitset 的 <code>_Find_first()</code>。</p><p>所以，总复杂度为 $\mathcal O((n+m)(\sqrt n+\frac c{32}))​$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> out=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c=getchar()));</span><br><span class="line">    <span class="keyword">for</span> (;<span class="built_in">isdigit</span>(c);c=getchar()) out=out*<span class="number">10</span>+c-<span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> B=<span class="number">666</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> C=<span class="number">30000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N],nxt[N&lt;&lt;<span class="number">1</span>],to[N&lt;&lt;<span class="number">1</span>],cnt;</span><br><span class="line"><span class="keyword">int</span> n,m,type,c[N],fa[N],dep[N],sta[N],top,tot,bl[N],key[N/B+<span class="number">5</span>],p[N],keyid[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="built_in">bitset</span>&lt;C&gt; bs[N/B+<span class="number">5</span>][N/B+<span class="number">5</span>],temp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,u,v,x,y,k,lastans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    n=read();</span><br><span class="line">    m=read();</span><br><span class="line">    type=read();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;++i) c[i]=read();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        u=read();</span><br><span class="line">        v=read();</span><br><span class="line">        add(u,v);</span><br><span class="line">        add(v,u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!tot) ++tot;</span><br><span class="line">    <span class="keyword">if</span> (keyid[key[tot]]==tot) keyid[key[tot]]=<span class="number">0</span>;</span><br><span class="line">    key[tot]=<span class="number">1</span>;</span><br><span class="line">    keyid[<span class="number">1</span>]=tot; </span><br><span class="line">    <span class="keyword">while</span> (top) bl[sta[top--]]=tot;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=tot;++i) <span class="comment">//预处理</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[key[i]]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[key[i]]=<span class="literal">true</span>;</span><br><span class="line">        temp.reset();</span><br><span class="line">        <span class="keyword">for</span> (u=key[i];u;u=fa[u])</span><br><span class="line">        &#123;</span><br><span class="line">            temp[c[u]]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (keyid[u])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!p[key[i]]&amp;&amp;u!=key[i]) p[key[i]]=u;</span><br><span class="line">                bs[keyid[key[i]]][keyid[u]]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        k=read();</span><br><span class="line">        temp.reset();</span><br><span class="line">        <span class="keyword">while</span> (k--)</span><br><span class="line">        &#123;</span><br><span class="line">            u=x=read()^lastans;</span><br><span class="line">            v=y=read()^lastans;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (key[bl[x]]!=key[bl[y]])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (dep[key[bl[x]]]&gt;dep[key[bl[y]]])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (x==u) <span class="comment">//若是第一次跳先暴力跳到关键点</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">while</span> (x!=key[bl[u]])</span><br><span class="line">                        &#123;</span><br><span class="line">                            temp[c[x]]=<span class="number">1</span>;</span><br><span class="line">                            x=fa[x];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> x=p[x]; <span class="comment">//否则跳一整块</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (y==v)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">while</span> (y!=key[bl[v]])</span><br><span class="line">                        &#123;</span><br><span class="line">                            temp[c[y]]=<span class="number">1</span>;</span><br><span class="line">                            y=fa[y];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> y=p[y];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (keyid[x]) temp|=bs[keyid[key[bl[u]]]][keyid[x]];</span><br><span class="line">            <span class="keyword">if</span> (keyid[y]) temp|=bs[keyid[key[bl[v]]]][keyid[y]];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (x!=y)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (dep[x]&gt;dep[y])</span><br><span class="line">                &#123;</span><br><span class="line">                    temp[c[x]]=<span class="number">1</span>;</span><br><span class="line">                    x=fa[x];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    temp[c[y]]=<span class="number">1</span>;</span><br><span class="line">                    y=fa[y];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            temp[c[x]]=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans1=temp.count(),ans2=(~temp)._Find_first();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,ans1,ans2);</span><br><span class="line">        lastans=(ans1+ans2)*type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,v,t=top;</span><br><span class="line">    <span class="keyword">for</span> (i=head[u];i;i=nxt[i])</span><br><span class="line">    &#123;</span><br><span class="line">        v=to[i];</span><br><span class="line">        <span class="keyword">if</span> (v==fa[u]) <span class="keyword">continue</span>;</span><br><span class="line">        fa[v]=u;</span><br><span class="line">        dep[v]=dep[u]+<span class="number">1</span>;</span><br><span class="line">        dfs(v);</span><br><span class="line">        <span class="keyword">if</span> (top-t&gt;=B)</span><br><span class="line">        &#123;</span><br><span class="line">            key[++tot]=u;</span><br><span class="line">            <span class="keyword">if</span> (!keyid[u]) keyid[u]=tot;</span><br><span class="line">            <span class="keyword">while</span> (top&gt;t) bl[sta[top--]]=tot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sta[++top]=u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    nxt[++cnt]=head[u];</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">    to[cnt]=v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BZOJ4812-由乃打扑克"><a href="#BZOJ4812-由乃打扑克" class="headerlink" title="BZOJ4812 由乃打扑克"></a><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=4812" target="_blank" rel="noopener">BZOJ4812 由乃打扑克</a></h3><p>这题和上一题基本一样，唯一的区别是得到 bitset 后如何计算答案。</p><p><del>由于BZOJ是计算所有测试点总时限，不好卡，所以可以用 <code>_Find_next()</code> 水过去。</del></p><p>正解是每 $16$ 位一起算，先预处理出 $2^{16}$ 种可能的情况高位连续 $1$ 的个数、低位连续 $1$ 的个数以及中间的贡献。只不过这样要手写 bitset，因为标准库的 bitset 不能取某 $16$ 位..</p><p>代码可以参考<a href="https://www.cnblogs.com/FallDream/p/bzoj4763.html" target="_blank" rel="noopener">这篇博客</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近发现 &lt;a href=&quot;https://oi-wiki.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;OI Wiki&lt;/a&gt; 的“树分块”是空的，本来想凭着之前写的&lt;a href=&quot;https://ouuan.github.io/%E8%8E%AB%E9%98%9F%E3%80%81%E5%B8%A6%E4%BF%AE%E8%8E%AB%E9%98%9F%E3%80%81%E6%A0%91%E4%B8%8A%E8%8E%AB%E9%98%9F%E8%AF%A6%E8%A7%A3/&quot;&gt;莫队教程&lt;/a&gt;水一水，结果被告知已经有人写过树上莫队了..于是就得详细介绍一下树分块除了树上莫队以外的应用..然而我除了糖果公园只做过一道树分块..（结果最后并没有找到这道题以外的其它题..）&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://ouuan.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="https://ouuan.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="分块" scheme="https://ouuan.github.io/tags/%E5%88%86%E5%9D%97/"/>
    
      <category term="树分块" scheme="https://ouuan.github.io/tags/%E6%A0%91%E5%88%86%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>2019省选复习周做题计划</title>
    <link href="https://ouuan.github.io/2019%E7%9C%81%E9%80%89%E5%A4%8D%E4%B9%A0%E5%91%A8%E5%81%9A%E9%A2%98%E8%AE%A1%E5%88%92/"/>
    <id>https://ouuan.github.io/2019省选复习周做题计划/</id>
    <published>2019-03-30T01:25:04.000Z</published>
    <updated>2019-04-03T00:09:51.563Z</updated>
    
    <content type="html"><![CDATA[<p>随便找了点省选前需要复习的知识点相关的题目..</p><a id="more"></a><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="LCT-树剖"><a href="#LCT-树剖" class="headerlink" title="LCT/树剖"></a>LCT/树剖</h2><p><a href="http://uoj.ac/problem/207" target="_blank" rel="noopener"><del>共价大爷游长沙</del></a></p><p><a href="https://www.luogu.org/problemnew/show/P3676" target="_blank" rel="noopener">小清新数据结构题</a></p><p><a href="https://www.luogu.org/problemnew/show/P4234" target="_blank" rel="noopener">最小差值生成树</a></p><p><a href="https://www.luogu.org/problemnew/show/SP2666" target="_blank" rel="noopener">QTREE4</a></p><h2 id="淀粉质"><a href="#淀粉质" class="headerlink" title="淀粉质"></a>淀粉质</h2><p><a href="https://www.luogu.org/problemnew/show/P2664" target="_blank" rel="noopener">树上游戏</a></p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p><a href="https://www.luogu.org/problemnew/show/P4022" target="_blank" rel="noopener">[APIO2014]回文串</a></p><p><a href="https://www.luogu.org/problemnew/show/P4094" target="_blank" rel="noopener">[HEOI2016/TJOI2016]字符串</a></p><h2 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h2><p><a href="https://www.luogu.org/problemnew/show/P4735" target="_blank" rel="noopener"><del>最大异或和</del></a></p><p><a href="https://www.luogu.org/problemnew/show/P4551" target="_blank" rel="noopener">最长异或路径</a></p><h2 id="整体二分-树套树"><a href="#整体二分-树套树" class="headerlink" title="整体二分/树套树"></a>整体二分/树套树</h2><p><a href="https://www.luogu.org/problemnew/show/P3332" target="_blank" rel="noopener">[ZJOI2013]K大数查询</a></p><h2 id="cdq分治"><a href="#cdq分治" class="headerlink" title="cdq分治"></a>cdq分治</h2><p><a href="https://www.luogu.org/problemnew/show/P4169" target="_blank" rel="noopener">[Violet]天使玩偶/SJY摆棋子</a></p><p><a href="https://www.luogu.org/problemnew/show/P4027" target="_blank" rel="noopener">[NOI2007]货币兑换</a></p><h2 id="莫比乌斯反演"><a href="#莫比乌斯反演" class="headerlink" title="莫比乌斯反演"></a>莫比乌斯反演</h2><p><a href="https://www.luogu.org/problemnew/show/P3312" target="_blank" rel="noopener">[SDOI2014]数表</a></p><p><a href="https://www.luogu.org/problemnew/show/P3911" target="_blank" rel="noopener">最小公倍数之和</a></p><p><a href="https://remmina.github.io/BZPRO/JudgeOnline/4176.html" target="_blank" rel="noopener">Lucas的数论</a></p><h2 id="组合数学、容斥原理、斯特林数"><a href="#组合数学、容斥原理、斯特林数" class="headerlink" title="组合数学、容斥原理、斯特林数"></a>组合数学、容斥原理、斯特林数</h2><p><a href="https://www.luogu.org/problemnew/show/P4707" target="_blank" rel="noopener">重返现世</a></p><p><a href="https://www.luogu.org/problemnew/show/P4091" target="_blank" rel="noopener">[HEOI2016/TJOI2016]求和</a></p><p><a href="https://www.luogu.org/problemnew/show/P4827" target="_blank" rel="noopener">[国家集训队] Crash 的文明世界</a></p><h2 id="多项式、生成函数"><a href="#多项式、生成函数" class="headerlink" title="多项式、生成函数"></a>多项式、生成函数</h2><p><a href="https://remmina.github.io/BZPRO/JudgeOnline/3028.html" target="_blank" rel="noopener">食物</a></p><p><a href="https://remmina.github.io/BZPRO/JudgeOnline/3509.html" target="_blank" rel="noopener"> [CodeChef] COUNTARI</a></p><p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=3160" target="_blank" rel="noopener">万径人踪灭</a></p><p><a href="https://www.luogu.org/problemnew/show/CF438E" target="_blank" rel="noopener">The Child and Binary Tree</a></p><p><a href="https://remmina.github.io/BZPRO/JudgeOnline/3456.html" target="_blank" rel="noopener">城市规划</a></p><p><a href="https://www.luogu.org/problemnew/show/P4389" target="_blank" rel="noopener">付公主的背包</a></p><p><a href="https://www.luogu.org/problemnew/show/P4705" target="_blank" rel="noopener">玩游戏</a></p><h1 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h1><p>共价大爷游长沙：如果要获取一个点的子树信息，要么 access 父亲 Splay 自己然后看实+虚+自己，要么 access 自己然后看虚+自己。</p><p>最大异或和：一开始尝试用线段树合并做，复杂度是 $\mathcal O(n(\log(n+m)+\log w)+m\log(n+m)\log w)$，卡常卡不过去，尝试用 <code>bitset</code> 优化，后来发现除以 $32$ 被 $\log$ 掉了，加上带来的一些常数后根本没有优化.. 只不过后来发现可持久化 Trie 真的挺好写的，（只要会主席树不需要学也能 yy 出来的感觉）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随便找了点省选前需要复习的知识点相关的题目..&lt;/p&gt;
    
    </summary>
    
      <category term="计划" scheme="https://ouuan.github.io/categories/%E8%AE%A1%E5%88%92/"/>
    
    
      <category term="省选" scheme="https://ouuan.github.io/tags/%E7%9C%81%E9%80%89/"/>
    
      <category term="题表" scheme="https://ouuan.github.io/tags/%E9%A2%98%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>树状数组——从背模板到树套树</title>
    <link href="https://ouuan.github.io/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E2%80%94%E2%80%94%E4%BB%8E%E8%83%8C%E6%A8%A1%E6%9D%BF%E5%88%B0%E6%A0%91%E5%A5%97%E6%A0%91/"/>
    <id>https://ouuan.github.io/树状数组——从背模板到树套树/</id>
    <published>2019-03-26T13:38:45.000Z</published>
    <updated>2019-04-02T23:53:36.521Z</updated>
    
    <content type="html"><![CDATA[<p><del>这是一篇披着PJ组数据结构外衣的树套树教程。</del></p><p>大约会（尝试着）较为本质地简介一下树状数组？</p><a id="more"></a><h1 id="基础树状数组"><a href="#基础树状数组" class="headerlink" title="基础树状数组"></a>基础树状数组</h1><p>树状数组，英文名 BIT(Binary Indexed Tree)（<del>不是TreeArray</del>）。</p><p>原理的话..看图大约是一目了然的：</p><img src="/树状数组——从背模板到树套树/BIT.png"><p>其中，黑色的矩形（包括红色的正方形）代表这一部分的和，而红色的正方形代表这部分和在树状数组中的下标。如果把这些区间连边，就像是一棵二叉树，所以叫树状数组。</p><p>举几个栗子，$BIT[3]$ 表示 $A[3]$，$BIT[6]$ 表示 $A[5]+A[6]$，$BIT[12]$ 表示 $A[9]+A[10]+A[11]+A[12]$。</p><p>我们把每个下标用二进制表示，可以发现，二进制表示的末尾有 $k​$ 个 $0​$，在树状数组里它就代表一段长为 $2^k​$ 的区间的和。由于树状数组和下标的二进制联系紧密，所以英文叫 Binary Indexed Tree。</p><p>可以定义 $lowbit(x)$ 为 $x$ 的二进制表示中最低位的 $1$ 表示的数。如 $lowbit(101_{(2)})=1$，$lowbit(110100_{(2)}=4)$，这样的话，树状数组中下标为 $x$ 的元素就表示了一段长为 $lowbit(x)$ 的区间的和。</p><p>由于计算机中存储带符号整数的方式，$lowbit(x)=$<code>x&amp;-x</code>，具体原因可以自行搜索“补码”。</p><p>考虑如何更新树状数组：如果我们要更新第 $p$ 位，先更新 $BIT[p]$，再更新 $BIT[p+lowbit(p)]$，再更新 $BIT[p+lowbit(p)+lowbit(p+lowbit(p))]$……一直更新到原数列的长度。</p><p>考虑如何查询某个前缀和：如果我们要查询前 $p$ 位的前缀和，结果就是 $BIT[p]+BIT[p-lowbit(p)]+BIT[p-lowbit(p)-lowbit(p-lowbit(p))]$……一直查询到 $lowbit$ 为 $1$ 的节点。</p><p>把树状数组看成二叉树，深度不超过 $\log(n)$，所以单次操作复杂度是 $\mathcal O(\log n)$。</p><p>大概就是这样，代码比较简短：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;p&lt;=n;p+=(p&amp;-p)) BIT[p]+=x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> out=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;p;p-=(p&amp;-p)) out+=BIT[p];</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="稍进阶一点点的树状数组"><a href="#稍进阶一点点的树状数组" class="headerlink" title="稍进阶一点点的树状数组"></a>稍进阶一点点的树状数组</h1><p><del>由于本篇教程是“从背模板到树套树”而不是“摆脱线段树与平衡树”，所以不会提及那方面的高级用法。</del></p><h2 id="维护前缀积"><a href="#维护前缀积" class="headerlink" title="维护前缀积"></a>维护前缀积</h2><p>把+改成*。</p><h2 id="维护前缀异或和"><a href="#维护前缀异或和" class="headerlink" title="维护前缀异或和"></a>维护前缀异或和</h2><p>把+改成^。</p><h2 id="维护前缀矩阵积"><a href="#维护前缀矩阵积" class="headerlink" title="维护前缀矩阵积"></a>维护前缀矩阵积</h2><p><del>把+改成矩阵乘法。</del></p><p>诶，等等，怎么全WA了？</p><p>因为矩阵乘法不具有交换律..</p><p>比如说，两个矩阵 $A$ 和 $B$，树状数组里存的是 $A$ 和 $A\times B$，把 $A$ 乘上 $C$ 后树状数组里第二项我们期望它是 $A\times C\times B$，而实际上它是 $A\times B\times C$..</p><h2 id="所以树状数组到底在维护什么？"><a href="#所以树状数组到底在维护什么？" class="headerlink" title="所以树状数组到底在维护什么？"></a>所以树状数组到底在维护什么？</h2><blockquote><p>警告：本人其实没怎么学过群论..下文群论相关可能有口胡成分。</p></blockquote><p>在维护一个阿贝尔群..</p><p>等等，群是什么？<del>群号多少？</del></p><p>..就是一堆元素，定义了一种运算，它满足结合律、交换律，有单位元（谁和它运算都得到本身）、逆元（每个元素都存在一个元素运算后得到单位元）。如果只是前缀信息按理来说是不需要逆元的..然而一般都是要维护区间信息，而不只是前缀信息，所以需要逆元..</p><h1 id="树状数组套动态开点线段树"><a href="#树状数组套动态开点线段树" class="headerlink" title="树状数组套动态开点线段树"></a>树状数组套动态开点线段树</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><del>终于到正题了。</del></p><p><del>我们来定义一个阿贝尔群：</del></p><p>它的元素是一些同构的动态开点线段树，运算是把对应节点的信息相加，要求节点维护的信息是阿贝尔群。</p><p>一般来说，主席树可以解决的静态问题带修就要用树套树了..</p><p>修改就是把树状数组里的+换成动态开点线段树的修改操作，<del>询问就是把+换成merge</del>。直接 merge 复杂度好像不太对..（其实我不太会证线段树合并复杂度..）所以可以开个数组，把需要询问的节点存下来，然后在询问函数里合并信息。如果是询问区间，就把两个端点在树状数组里对应的节点存下来。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="P2617-Dynamic-Rankings"><a href="#P2617-Dynamic-Rankings" class="headerlink" title="P2617 Dynamic Rankings"></a><a href="https://www.luogu.org/problemnew/show/P2617" target="_blank" rel="noopener"><strong>P2617</strong> Dynamic Rankings</a></h3><div><div class="fold_hider"><div class="close hider_title">代码</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> out=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c=getchar()));</span><br><span class="line">    <span class="keyword">for</span> (;<span class="built_in">isdigit</span>(c);c=getchar()) out=out*<span class="number">10</span>+c-<span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100001</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val,ls,rs;</span><br><span class="line">&#125; t[N&lt;&lt;<span class="number">9</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p,<span class="keyword">int</span> type)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,tot,a[N],BIT[N],lsh[N&lt;&lt;<span class="number">1</span>],cnt,tp[N],l[N],r[N],xx[N],totx,toty,x[N],y[N];</span><br><span class="line"><span class="keyword">char</span> op[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line"></span><br><span class="line">    n=read();</span><br><span class="line">    m=read();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;++i) lsh[++cnt]=a[i]=read();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,op);</span><br><span class="line">        <span class="keyword">if</span> (op[<span class="number">0</span>]==<span class="string">'Q'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tp[i]=<span class="number">0</span>;</span><br><span class="line">            l[i]=read();</span><br><span class="line">            r[i]=read();</span><br><span class="line">            xx[i]=read();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            tp[i]=<span class="number">1</span>;</span><br><span class="line">            l[i]=read();</span><br><span class="line">            lsh[++cnt]=xx[i]=read();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(lsh+<span class="number">1</span>,lsh+cnt+<span class="number">1</span>);</span><br><span class="line">    cnt=unique(lsh+<span class="number">1</span>,lsh+cnt+<span class="number">1</span>)-lsh;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i]=lower_bound(lsh+<span class="number">1</span>,lsh+cnt,a[i])-lsh;</span><br><span class="line">        change(i,a[i],<span class="number">1</span>);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (tp[i])</span><br><span class="line">        &#123;</span><br><span class="line">            change(l[i],a[l[i]],<span class="number">-1</span>);</span><br><span class="line">            change(l[i],a[l[i]]=xx[i]=lower_bound(lsh+<span class="number">1</span>,lsh+cnt,xx[i])-lsh,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            totx=toty=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (j=l[i]<span class="number">-1</span>;j;j-=(j&amp;-j)) x[++totx]=BIT[j];</span><br><span class="line">            <span class="keyword">for</span> (j=r[i];j;j-=(j&amp;-j)) y[++toty]=BIT[j];</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,query(<span class="number">1</span>,cnt,xx[i]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;p&lt;=n;p+=(p&amp;-p)) BIT[p]=modify(BIT[p],<span class="number">1</span>,cnt,x,y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p,<span class="keyword">int</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u=++tot;</span><br><span class="line">    t[u]=t[x];</span><br><span class="line">    t[u].val+=type;</span><br><span class="line">    <span class="keyword">if</span> (l==r<span class="number">-1</span>) <span class="keyword">return</span> u;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (p&lt;mid) t[u].ls=modify(t[u].ls,l,mid,p,type);</span><br><span class="line">    <span class="keyword">else</span> t[u].rs=modify(t[u].rs,mid,r,p,type);</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l==r<span class="number">-1</span>) <span class="keyword">return</span> lsh[l];</span><br><span class="line">    <span class="keyword">int</span> i,sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=totx;++i) sum-=t[t[x[i]].ls].val;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=toty;++i) sum+=t[t[y[i]].ls].val;</span><br><span class="line">    <span class="keyword">if</span> (sum&gt;=k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=totx;++i) x[i]=t[x[i]].ls;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=toty;++i) y[i]=t[y[i]].ls;</span><br><span class="line">        <span class="keyword">return</span> query(l,l+r&gt;&gt;<span class="number">1</span>,k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=totx;++i) x[i]=t[x[i]].rs;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=toty;++i) y[i]=t[y[i]].rs;</span><br><span class="line">        <span class="keyword">return</span> query(l+r&gt;&gt;<span class="number">1</span>,r,k-sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="P3380-【模板】二逼平衡树（树套树）"><a href="#P3380-【模板】二逼平衡树（树套树）" class="headerlink" title="P3380 【模板】二逼平衡树（树套树）"></a><a href="https://www.luogu.org/problemnew/show/P3380" target="_blank" rel="noopener"><strong>P3380</strong> 【模板】二逼平衡树（树套树）</a></h3><div><div class="fold_hider"><div class="close hider_title">代码</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">50010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x7fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> out=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c=getchar()));</span><br><span class="line">    <span class="keyword">for</span> (;<span class="built_in">isdigit</span>(c);c=getchar()) out=out*<span class="number">10</span>+c-<span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val,ls,rs;</span><br><span class="line">&#125; t[N&lt;&lt;<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p,<span class="keyword">int</span> type)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qsum</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> d)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kth</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,tot,a[N],BIT[N],lsh[N&lt;&lt;<span class="number">1</span>],cnt,op[N],l[N],r[N],k[N],totx,toty,X[<span class="number">20</span>][N],Y[<span class="number">20</span>][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,p;</span><br><span class="line"></span><br><span class="line">    n=read();</span><br><span class="line">    m=read();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;++i) a[i]=lsh[++cnt]=read();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        op[i]=read();</span><br><span class="line">        <span class="keyword">if</span> (op[i]==<span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            l[i]=read();</span><br><span class="line">            k[i]=lsh[++cnt]=read();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            l[i]=read();</span><br><span class="line">            r[i]=read();</span><br><span class="line">            k[i]=read();</span><br><span class="line">            <span class="keyword">if</span> (op[i]!=<span class="number">2</span>) lsh[++cnt]=k[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(lsh+<span class="number">1</span>,lsh+cnt+<span class="number">1</span>);</span><br><span class="line">    cnt=unique(lsh+<span class="number">1</span>,lsh+cnt+<span class="number">1</span>)-lsh;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i]=lower_bound(lsh+<span class="number">1</span>,lsh+cnt,a[i])-lsh;</span><br><span class="line">        modify(i,a[i],<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (op[i]==<span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            k[i]=lower_bound(lsh+<span class="number">1</span>,lsh+cnt,k[i])-lsh;</span><br><span class="line">            modify(l[i],a[l[i]],<span class="number">-1</span>);</span><br><span class="line">            modify(l[i],a[l[i]]=k[i],<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            totx=toty=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (p=l[i]<span class="number">-1</span>;p;p-=(p&amp;-p)) X[<span class="number">0</span>][++totx]=BIT[p];</span><br><span class="line">            <span class="keyword">for</span> (p=r[i];p;p-=(p&amp;-p)) Y[<span class="number">0</span>][++toty]=BIT[p];</span><br><span class="line">            <span class="keyword">if</span> (op[i]==<span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,kth(<span class="number">1</span>,cnt,k[i]));</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                k[i]=lower_bound(lsh+<span class="number">1</span>,lsh+cnt,k[i])-lsh;</span><br><span class="line">                <span class="keyword">if</span> (op[i]==<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,qsum(<span class="number">1</span>,cnt,<span class="number">1</span>,k[i],<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (op[i]==<span class="number">4</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> rk=qsum(<span class="number">1</span>,cnt,<span class="number">1</span>,k[i],<span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">if</span> (rk) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,kth(<span class="number">1</span>,cnt,rk));</span><br><span class="line">                    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,-INF);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> rk=qsum(<span class="number">1</span>,cnt,<span class="number">1</span>,k[i]+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">if</span> (rk&lt;=r[i]-l[i]) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,kth(<span class="number">1</span>,cnt,rk+<span class="number">1</span>));</span><br><span class="line">                    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,INF);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;p&lt;=n;p+=(p&amp;-p)) BIT[p]=insert(BIT[p],<span class="number">1</span>,cnt,x,y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p,<span class="keyword">int</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u=++tot;</span><br><span class="line">    t[u]=t[x];</span><br><span class="line">    t[u].val+=type;</span><br><span class="line">    <span class="keyword">if</span> (l==r<span class="number">-1</span>) <span class="keyword">return</span> u;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (p&lt;mid) t[u].ls=insert(t[u].ls,l,mid,p,type);</span><br><span class="line">    <span class="keyword">else</span> t[u].rs=insert(t[u].rs,mid,r,p,type);</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qsum</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l&gt;=R||r&lt;=L) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i,sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (L&lt;=l&amp;&amp;R&gt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=totx;++i) sum-=t[X[d][i]].val;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=toty;++i) sum+=t[Y[d][i]].val;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=totx;++i) X[d+<span class="number">1</span>][i]=t[X[d][i]].ls;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=toty;++i) Y[d+<span class="number">1</span>][i]=t[Y[d][i]].ls;</span><br><span class="line">    sum=qsum(l,l+r&gt;&gt;<span class="number">1</span>,L,R,d+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=totx;++i) X[d+<span class="number">1</span>][i]=t[X[d][i]].rs;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=toty;++i) Y[d+<span class="number">1</span>][i]=t[Y[d][i]].rs;</span><br><span class="line">    <span class="keyword">return</span> sum+qsum(l+r&gt;&gt;<span class="number">1</span>,r,L,R,d+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kth</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l==r<span class="number">-1</span>) <span class="keyword">return</span> lsh[l];</span><br><span class="line">    <span class="keyword">int</span> i,sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=totx;++i) sum-=t[t[X[<span class="number">0</span>][i]].ls].val;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=toty;++i) sum+=t[t[Y[<span class="number">0</span>][i]].ls].val;</span><br><span class="line">    <span class="keyword">if</span> (sum&gt;=k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=totx;++i) X[<span class="number">0</span>][i]=t[X[<span class="number">0</span>][i]].ls;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=toty;++i) Y[<span class="number">0</span>][i]=t[Y[<span class="number">0</span>][i]].ls;</span><br><span class="line">        <span class="keyword">return</span> kth(l,l+r&gt;&gt;<span class="number">1</span>,k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=totx;++i) X[<span class="number">0</span>][i]=t[X[<span class="number">0</span>][i]].rs;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=toty;++i) Y[<span class="number">0</span>][i]=t[Y[<span class="number">0</span>][i]].rs;</span><br><span class="line">    <span class="keyword">return</span> kth(l+r&gt;&gt;<span class="number">1</span>,r,k-sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="CQOI2011-动态逆序对"><a href="#CQOI2011-动态逆序对" class="headerlink" title="[CQOI2011]动态逆序对"></a><a href="https://www.luogu.org/problemnew/show/P3157" target="_blank" rel="noopener">[CQOI2011]动态逆序对</a></h3><p>这题用树套树做有点卡空间..需要把带返回值的动态开点改成直接修改。</p><div><div class="fold_hider"><div class="close hider_title">代码</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> out=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c=getchar()));</span><br><span class="line">    <span class="keyword">for</span> (;<span class="built_in">isdigit</span>(c);c=getchar()) out=out*<span class="number">10</span>+c-<span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val,ls,rs;</span><br><span class="line">&#125; t[N*<span class="number">90</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span>&amp; u,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> d)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,a[N],p[N],del[N],BIT[N],x[<span class="number">20</span>][<span class="number">20</span>],y[<span class="number">20</span>][<span class="number">20</span>],xtot,ytot,tot;</span><br><span class="line"><span class="keyword">bool</span> deleted[N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans,out[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line"></span><br><span class="line">    n=read();</span><br><span class="line">    m=read();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i]=read();</span><br><span class="line">        p[a[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        del[i]=p[read()];</span><br><span class="line">        deleted[del[i]]=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=n;i&gt;=<span class="number">1</span>;--i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!deleted[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (j=a[i];j;j-=(j&amp;-j)) ans+=BIT[j];</span><br><span class="line">            <span class="keyword">for</span> (j=a[i];j&lt;=n;j+=(j&amp;-j)) ++BIT[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(BIT,<span class="number">0</span>,<span class="keyword">sizeof</span>(BIT));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!deleted[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (j=i;j&lt;=n;j+=(j&amp;-j))</span><br><span class="line">            &#123;</span><br><span class="line">                change(BIT[j],<span class="number">1</span>,n+<span class="number">1</span>,a[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=m;i&gt;=<span class="number">1</span>;--i)</span><br><span class="line">    &#123;</span><br><span class="line">        xtot=ytot=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j=del[i];j;j-=(j&amp;-j)) y[<span class="number">0</span>][++ytot]=BIT[j];</span><br><span class="line">        ans+=query(<span class="number">1</span>,n+<span class="number">1</span>,a[del[i]]+<span class="number">1</span>,n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        xtot=ytot=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j=del[i];j;j-=(j&amp;-j)) x[<span class="number">0</span>][++xtot]=BIT[j];</span><br><span class="line">        <span class="keyword">for</span> (j=n;j;j-=(j&amp;-j)) y[<span class="number">0</span>][++ytot]=BIT[j];</span><br><span class="line">        ans+=query(<span class="number">1</span>,n+<span class="number">1</span>,<span class="number">1</span>,a[del[i]],<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (j=del[i];j&lt;=n;j+=(j&amp;-j)) change(BIT[j],<span class="number">1</span>,n+<span class="number">1</span>,a[del[i]]);</span><br><span class="line">        out[i]=ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;++i) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,out[i]); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span>&amp; u,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!u) u=++tot; </span><br><span class="line">    ++t[u].val;</span><br><span class="line">    <span class="keyword">if</span> (l==r<span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (p&lt;mid) change(t[u].ls,l,mid,p);</span><br><span class="line">    <span class="keyword">else</span> change(t[u].rs,mid,r,p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l&gt;=R||r&lt;=L) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i,ret=<span class="number">0</span>,mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (L&lt;=l&amp;&amp;R&gt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=xtot;++i) ret-=t[x[d][i]].val;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=ytot;++i) ret+=t[y[d][i]].val;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=xtot;++i) x[d+<span class="number">1</span>][i]=t[x[d][i]].ls;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=ytot;++i) y[d+<span class="number">1</span>][i]=t[y[d][i]].ls;</span><br><span class="line">    ret+=query(l,mid,L,R,d+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=xtot;++i) x[d+<span class="number">1</span>][i]=t[x[d][i]].rs;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=ytot;++i) y[d+<span class="number">1</span>][i]=t[y[d][i]].rs;</span><br><span class="line">    ret+=query(mid,r,L,R,d+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;del&gt;这是一篇披着PJ组数据结构外衣的树套树教程。&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;大约会（尝试着）较为本质地简介一下树状数组？&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://ouuan.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="https://ouuan.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树状数组" scheme="https://ouuan.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
      <category term="树套树" scheme="https://ouuan.github.io/tags/%E6%A0%91%E5%A5%97%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>cdq分治学习笔记</title>
    <link href="https://ouuan.github.io/cdq%E5%88%86%E6%B2%BB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://ouuan.github.io/cdq分治学习笔记/</id>
    <published>2019-03-26T10:49:44.000Z</published>
    <updated>2019-04-02T23:52:40.773Z</updated>
    
    <content type="html"><![CDATA[<p>cdq分治也是咕了好久了..最近总算把它学了。</p><p><del>cdq分治是一种离线算法，可以代替一些复杂的数据结构，降低代码难度，减小常数。</del>废话大家都知道。</p><a id="more"></a><p>本文未完待续（cdq分治的其它应用，如维护凸壳，待填坑）。</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>感觉cdq分治不如叫“ex归并排序”，就是<strong>以操作的时间作为初始顺序，在递归处理的过程中按位置归并排序</strong>。</p><p>更一般地说，对于一个二维偏序 $P(i,j)=P_1(a_i,a_j)\land P_2(b_i,b_j)​$，位置 $i​$ 的修改对位置 $j​$ 的询问（询问为类前缀和形式，区间询问需拆成两个前缀询问）有影响当且仅当 $P(i,j)=true​$，cdq分治就是以其中一维为初始顺序，对另一维进行归并排序的过程中计算左区间里修改的总和，将左区间修改的影响应用到右区间。</p><p>学会了之后就会发现，cdq分治的确就是这样，已经描述的很清楚了，然而在没学会的时候估计是看不懂上面这段话的..所以结合具体题目来看一看吧。</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="P3374-【模板】树状数组-1"><a href="#P3374-【模板】树状数组-1" class="headerlink" title="P3374 【模板】树状数组 1"></a><a href="https://www.luogu.org/problemnew/show/P3374" target="_blank" rel="noopener"><strong>P3374</strong> 【模板】树状数组 1</a></h2><p><del>树状数组裸题！</del>冷静，我们来用ex归并排序做..（嗯，我决定就这么叫它了）</p><p>按照我们上面说的，我们把操作存下来，询问拆成两个前缀和相减，初始值视作修改，需要存的信息有操作的种类（修改、询问的左端点减一、询问的右端点），操作的位置（$p$、$l-1$、$r$）以及修改加上的值/询问的编号。如果写法正常的话你已经以操作的时间作为初始顺序了..</p><p>然后，写个归并排序，按操作的位置排序，同一个位置的修改要放在询问的前面。然后，在归并排序的过程中，遇到左区间里的修改就更新左区间修改的总和，遇到右区间里的询问就用记录的“左区间修改的总和”更新这个询问的答案。</p><div><div class="fold_hider"><div class="close hider_title">具体见代码</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">500010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> type,p,val; <span class="comment">//type为2表示修改，type为-1表示左端点减一，type为1表示右端点</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Node&amp; b) <span class="keyword">const</span> &#123; <span class="keyword">return</span> p==b.p?type&gt;b.type:p&lt;b.p; &#125;</span><br><span class="line">&#125; q[N&lt;&lt;<span class="number">2</span>],tmp[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,tot,qtot;</span><br><span class="line">ll ans[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,op,x,y;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;++i) <span class="comment">//初始值视作修改</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">        q[++tot].type=<span class="number">2</span>;</span><br><span class="line">        q[tot].p=i;</span><br><span class="line">        q[tot].val=x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;op,&amp;x,&amp;y);</span><br><span class="line">        <span class="keyword">if</span> (op==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            q[++tot].type=<span class="number">2</span>;</span><br><span class="line">            q[tot].p=x;</span><br><span class="line">            q[tot].val=y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//询问拆成两个前缀和相减</span></span><br><span class="line">        &#123;</span><br><span class="line">            q[++tot].type=<span class="number">-1</span>;</span><br><span class="line">            q[tot].p=x<span class="number">-1</span>;</span><br><span class="line">            q[tot].val=++qtot;</span><br><span class="line">            q[++tot].type=<span class="number">1</span>;</span><br><span class="line">            q[tot].p=y;</span><br><span class="line">            q[tot].val=qtot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    solve(<span class="number">1</span>,tot+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=qtot;++i) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l==r<span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> i,j,k,mid;</span><br><span class="line">    ll sum=<span class="number">0</span>;</span><br><span class="line">    i=k=l;</span><br><span class="line">    j=mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    solve(l,mid);</span><br><span class="line">    solve(mid,r);</span><br><span class="line">    <span class="keyword">while</span> (i&lt;mid&amp;&amp;j&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (q[i]&lt;q[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (q[i].type==<span class="number">2</span>) sum+=q[i].val; <span class="comment">//记录左区间里的修改之和</span></span><br><span class="line">            tmp[k++]=q[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (q[j].type!=<span class="number">2</span>) ans[q[j].val]+=q[j].type*sum; <span class="comment">//将左区间里的修改应用到右区间里的询问</span></span><br><span class="line">            tmp[k++]=q[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;mid) tmp[k++]=q[i++];</span><br><span class="line">    <span class="keyword">while</span> (j&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (q[j].type!=<span class="number">2</span>) ans[q[j].val]+=q[j].type*sum;</span><br><span class="line">        tmp[k++]=q[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i=l;i&lt;r;++i) q[i]=tmp[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><p>之前说过ex归并排序本质上是一个二维偏序限制了修改对询问的影响，所以也可以先按位置排序再按时间排序。只不过..这样写很奇怪，很麻烦，常数又大。然而为了理解ex归并排序的本质，我还是写了份这个做法..</p><div><div class="fold_hider"><div class="close hider_title">一种奇怪的写法</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">500010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> type,tim,p,val;</span><br><span class="line">    Node(<span class="keyword">int</span> _type=<span class="number">0</span>,<span class="keyword">int</span> _tim=<span class="number">0</span>,<span class="keyword">int</span> _p=<span class="number">0</span>,<span class="keyword">int</span> _val=<span class="number">0</span>):type(_type),tim(_tim),p(_p),val(_val)&#123;&#125;</span><br><span class="line">&#125; q[N&lt;&lt;<span class="number">2</span>],tmp[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,tot,qtot;</span><br><span class="line">ll ans[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,op,x,y;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">        q[++tot]=Node(<span class="number">2</span>,<span class="number">0</span>,i,x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;op,&amp;x,&amp;y);</span><br><span class="line">        <span class="keyword">if</span> (op==<span class="number">1</span>) q[++tot]=Node(<span class="number">2</span>,i,x,y);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            q[++tot]=Node(<span class="number">-1</span>,i,x<span class="number">-1</span>,++qtot);</span><br><span class="line">            q[++tot]=Node(<span class="number">1</span>,i,y,qtot);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(q+<span class="number">1</span>,q+tot+<span class="number">1</span>,[](<span class="keyword">const</span> Node&amp; x,<span class="keyword">const</span> Node&amp; y)&#123;<span class="keyword">return</span> x.p==y.p?x.type&gt;y.type:x.p&lt;y.p;&#125;);</span><br><span class="line"></span><br><span class="line">    solve(<span class="number">1</span>,tot+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=qtot;++i) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l==r<span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> i,j,k,mid;</span><br><span class="line">    ll sum=<span class="number">0</span>;</span><br><span class="line">    i=k=l;</span><br><span class="line">    j=mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    solve(l,mid);</span><br><span class="line">    solve(mid,r);</span><br><span class="line">    <span class="keyword">while</span> (i&lt;mid&amp;&amp;j&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (q[i].tim&lt;q[j].tim)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (q[i].type==<span class="number">2</span>) sum+=q[i].val;</span><br><span class="line">            tmp[k++]=q[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (q[j].type!=<span class="number">2</span>) ans[q[j].val]+=q[j].type*sum;</span><br><span class="line">            tmp[k++]=q[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;mid) tmp[k++]=q[i++];</span><br><span class="line">    <span class="keyword">while</span> (j&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (q[j].type!=<span class="number">2</span>) ans[q[j].val]+=q[j].type*sum;</span><br><span class="line">        tmp[k++]=q[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i=l;i&lt;r;++i) q[i]=tmp[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h1 id="P3810-【模板】三维偏序（陌上花开）"><a href="#P3810-【模板】三维偏序（陌上花开）" class="headerlink" title="P3810 【模板】三维偏序（陌上花开）"></a><a href="https://www.luogu.org/problemnew/show/P3810" target="_blank" rel="noopener"><strong>P3810</strong> 【模板】三维偏序（陌上花开）</a></h1><p>有两种做法，一种是cdq分治套树状数组，需要注意的有两点，一是清空树状数组可以用时间戳，二是 $a,\,b,\,c$ 都相等的元素要合并。</p><div><div class="fold_hider"><div class="close hider_title">参考代码</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> K=<span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a,b,c,w,f;</span><br><span class="line">&#125; a[N],b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,k,d[N],BIT[K],vis[K],tim,tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;b[i].a,&amp;b[i].b,&amp;b[i].c);</span><br><span class="line">        b[i].w=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(b+<span class="number">1</span>,b+n+<span class="number">1</span>,[](<span class="keyword">const</span> Node&amp; x,<span class="keyword">const</span> Node&amp; y)&#123;<span class="keyword">return</span> x.a==y.a?(x.b==y.b?x.c&lt;y.c:x.b&lt;y.b):x.a&lt;y.a;&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b[i].a!=b[i+<span class="number">1</span>].a||b[i].b!=b[i+<span class="number">1</span>].b||b[i].c!=b[i+<span class="number">1</span>].c) a[++tot]=b[i];</span><br><span class="line">        <span class="keyword">else</span> b[i+<span class="number">1</span>].w+=b[i].w;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    solve(<span class="number">1</span>,tot+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=tot;++i) d[a[i].f+a[i].w]+=a[i].w;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,d[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l==r<span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> i,j,k,mid;</span><br><span class="line">    i=k=l;</span><br><span class="line">    j=mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    solve(l,mid);</span><br><span class="line">    solve(mid,r);</span><br><span class="line">    ++tim;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;mid&amp;&amp;j&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i].b&lt;=a[j].b)</span><br><span class="line">        &#123;</span><br><span class="line">            add(a[i].c,a[i].w);</span><br><span class="line">            b[k++]=a[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            a[j].f+=query(a[j].c);</span><br><span class="line">            b[k++]=a[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;mid) b[k++]=a[i++];</span><br><span class="line">    <span class="keyword">while</span> (j&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        a[j].f+=query(a[j].c);</span><br><span class="line">        b[k++]=a[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i=l;i&lt;r;++i) a[i]=b[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;p&lt;=k;p+=(p&amp;-p))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[p]!=tim)</span><br><span class="line">        &#123;</span><br><span class="line">            BIT[p]=<span class="number">0</span>;</span><br><span class="line">            vis[p]=tim;</span><br><span class="line">        &#125;</span><br><span class="line">        BIT[p]+=x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> out=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;p;p-=(p&amp;-p)) <span class="keyword">if</span> (vis[p]==tim) out+=BIT[p];</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><p>还有一种做法是cdq分治套cdq分治：</p><div><div class="fold_hider"><div class="close hider_title">参考代码</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a,b,c,d,w,id;</span><br><span class="line">&#125; a[N],b[N],c[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve2</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,k,d[N],tot,ans[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;b[i].a,&amp;b[i].b,&amp;b[i].c);</span><br><span class="line">        b[i].w=<span class="number">1</span>;</span><br><span class="line">        b[i].id=i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(b+<span class="number">1</span>,b+n+<span class="number">1</span>,[](<span class="keyword">const</span> Node&amp; x,<span class="keyword">const</span> Node&amp; y)&#123;<span class="keyword">return</span> x.a==y.a?(x.b==y.b?x.c&lt;y.c:x.b&lt;y.b):x.a&lt;y.a;&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b[i].a!=b[i+<span class="number">1</span>].a||b[i].b!=b[i+<span class="number">1</span>].b||b[i].c!=b[i+<span class="number">1</span>].c) a[++tot]=b[i];</span><br><span class="line">        <span class="keyword">else</span> b[i+<span class="number">1</span>].w+=b[i].w;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    solve(<span class="number">1</span>,tot+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=tot;++i) d[ans[a[i].id]+a[i].w]+=a[i].w;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,d[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l==r<span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> i,j,k,mid;</span><br><span class="line">    i=k=l;</span><br><span class="line">    j=mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    solve(l,mid);</span><br><span class="line">    solve(mid,r);</span><br><span class="line">    <span class="keyword">while</span> (i&lt;mid&amp;&amp;j&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i].b&lt;=a[j].b)</span><br><span class="line">        &#123;</span><br><span class="line">            a[i].d=a[i].w;</span><br><span class="line">            b[k++]=a[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            a[j].d=<span class="number">0</span>;</span><br><span class="line">            b[k++]=a[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;mid)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i].d=a[i].w;</span><br><span class="line">        b[k++]=a[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        a[j].d=<span class="number">0</span>;</span><br><span class="line">        b[k++]=a[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i=l;i&lt;r;++i) a[i]=b[i];</span><br><span class="line">    solve2(l,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve2</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l==r<span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> i,j,k,mid,sum=<span class="number">0</span>;</span><br><span class="line">    i=k=l;</span><br><span class="line">    j=mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    solve2(l,mid);</span><br><span class="line">    solve2(mid,r);</span><br><span class="line">    <span class="keyword">while</span> (i&lt;mid&amp;&amp;j&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b[i].c&lt;=b[j].c)</span><br><span class="line">        &#123;</span><br><span class="line">            sum+=b[i].d;</span><br><span class="line">            c[k++]=b[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!b[j].d) ans[b[j].id]+=sum;</span><br><span class="line">            c[k++]=b[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;mid) c[k++]=b[i++];</span><br><span class="line">    <span class="keyword">while</span> (j&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!b[j].d) ans[b[j].id]+=sum;</span><br><span class="line">        c[k++]=b[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i=l;i&lt;r;++i) b[i]=c[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h1 id="cdq分治求偏序对的本质"><a href="#cdq分治求偏序对的本质" class="headerlink" title="cdq分治求偏序对的本质"></a>cdq分治求偏序对的本质</h1><p>（下文中“偏序问题”即求满足偏序关系的数对个数。而”高维偏序“实际上是多个严格弱序的并。非严格偏序与之类似，主要是在代码上有些细节改变。）</p><p>大家知道，二维偏序可以先按一维排序后用普通的归并排序解决，那为什么“三维偏序”不可以呢？</p><p>首先，按其中一维排序相当于降了一维，问题就变成了“为什么一维偏序可以用普通的归并排序解决，而二维偏序不可以”。</p><p>原因就在于，两个偏序关系的并，不一定具有不可比性的传递性。（Strict Weak Ordering 相关内容参见<a href="https://ouuan.github.io/%E6%B5%85%E8%B0%88%E9%82%BB%E9%A1%B9%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F%E7%9A%84%E5%BA%94%E7%94%A8%E4%BB%A5%E5%8F%8A%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98/#%E4%B8%A5%E6%A0%BC%E5%BC%B1%E5%BA%8F">我的另一篇博客</a>）</p><p>可以证明，两个严格弱序的并一定是一个严格偏序，但不一定是一个严格弱序。而 cdq 分治可以将多个严格弱序的并进行降维，每一次 cdq 分治都标记出哪些位置会对其它位置有贡献，并按某一维排序。</p><p>上面说的有点乱..简单概括一下。排序可以降维，只有严格弱序能排序，高维偏序不一定是严格弱序，cdq 分治在排序的过程中标记了元素之间如何贡献答案。所以 cdq 分治就可以解决高维偏序问题了..</p><p>所以，我们可以写出一份 cdq 分治求 $k$ 维偏序对的代码：</p><p>题意简述：第一行 $n,\,k$，后 $n$ 行每行 $k$ 个数 $a_{i,1..k}$，对每个 $i$ 求 $\forall d\in[1,k],\,a_{i,d}&lt;a_{j,d}$ 的 $j$ 个数。</p><p>当然，$n$ 要足够大，否则会被暴力艹。只不过理论上来说，如果维数是常数，复杂度就比暴力更优…</p><p><a href="https://www.luogu.org/problemnew/show/U66865" target="_blank" rel="noopener">随便造的一个模板题</a></p><div><div class="fold_hider"><div class="close hider_title">代码</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">10005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> K=<span class="number">15</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> d)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,k,ans[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> w[K],type,id;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Node&amp; y) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (w[<span class="number">0</span>]!=y.w[<span class="number">0</span>]) <span class="keyword">return</span> w[<span class="number">0</span>]&lt;y.w[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;k;++i) <span class="keyword">if</span> (w[i]!=y.w[i]) <span class="keyword">return</span> w[i]&gt;y.w[i]; <span class="comment">//如果是非严格偏序都应该顺着排，严格偏序除了第一维都应该倒着排。这是由于相等元素可以/不可以转移。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; a[K][N],tmp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        a[<span class="number">0</span>][i].id=i;</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;k;++j) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a[<span class="number">0</span>][i].w+j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(a[<span class="number">0</span>]+<span class="number">1</span>,a[<span class="number">0</span>]+n+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    solve(<span class="number">1</span>,n+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l==r<span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> i,j,p,mid,sum=<span class="number">0</span>;</span><br><span class="line">    i=p=l;</span><br><span class="line">    j=mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    solve(l,mid,d);</span><br><span class="line">    solve(mid,r,d);</span><br><span class="line">    <span class="keyword">while</span> (i&lt;mid&amp;&amp;j&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[d<span class="number">-1</span>][i].w[d]&lt;a[d<span class="number">-1</span>][j].w[d])</span><br><span class="line">        &#123;</span><br><span class="line">            a[d][p]=tmp[p]=a[d<span class="number">-1</span>][i++];</span><br><span class="line">            <span class="keyword">if</span> (d&gt;<span class="number">1</span>&amp;&amp;a[d][p].type!=<span class="number">1</span>) a[d][p].type=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                a[d][p].type=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (d==k<span class="number">-1</span>) ++sum;</span><br><span class="line">            &#125;</span><br><span class="line">            ++p; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            a[d][p]=tmp[p]=a[d<span class="number">-1</span>][j++];</span><br><span class="line">            <span class="keyword">if</span> (d&gt;<span class="number">1</span>&amp;&amp;a[d][p].type!=<span class="number">2</span>) a[d][p].type=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                a[d][p].type=<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (d==k<span class="number">-1</span>) ans[a[d][p].id]+=sum;</span><br><span class="line">            &#125;</span><br><span class="line">            ++p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;mid)</span><br><span class="line">    &#123;</span><br><span class="line">        a[d][p]=tmp[p]=a[d<span class="number">-1</span>][i++];</span><br><span class="line">        <span class="keyword">if</span> (d&gt;<span class="number">1</span>&amp;&amp;a[d][p].type!=<span class="number">1</span>) a[d][p].type=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> a[d][p].type=<span class="number">1</span>;</span><br><span class="line">        ++p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        a[d][p]=tmp[p]=a[d<span class="number">-1</span>][j++];</span><br><span class="line">        <span class="keyword">if</span> (d&gt;<span class="number">1</span>&amp;&amp;a[d][p].type!=<span class="number">2</span>) a[d][p].type=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            a[d][p].type=<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (d==k<span class="number">-1</span>) ans[a[d][p].id]+=sum;</span><br><span class="line">        &#125;</span><br><span class="line">        ++p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i=l;i&lt;r;++i) a[d<span class="number">-1</span>][i]=tmp[i];</span><br><span class="line">    <span class="keyword">if</span> (d&lt;k<span class="number">-1</span>) solve(l,r,d+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;cdq分治也是咕了好久了..最近总算把它学了。&lt;/p&gt;
&lt;p&gt;&lt;del&gt;cdq分治是一种离线算法，可以代替一些复杂的数据结构，降低代码难度，减小常数。&lt;/del&gt;废话大家都知道。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://ouuan.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="离线算法" scheme="https://ouuan.github.io/tags/%E7%A6%BB%E7%BA%BF%E7%AE%97%E6%B3%95/"/>
    
      <category term="cdq分治" scheme="https://ouuan.github.io/tags/cdq%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ4259 残缺的字符串（FFT）</title>
    <link href="https://ouuan.github.io/BZOJ4259-%E6%AE%8B%E7%BC%BA%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88FFT%EF%BC%89/"/>
    <id>https://ouuan.github.io/BZOJ4259-残缺的字符串（FFT）/</id>
    <published>2019-03-19T08:27:51.000Z</published>
    <updated>2019-03-19T10:28:41.420Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.luogu.org/problemnew/show/P4173" target="_blank" rel="noopener">洛谷</a></p><p><a href="https://darkbzoj.cf/problem/4259" target="_blank" rel="noopener">darkbzoj</a></p><h1 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h1><p>带通配符的单模式串、单文本串匹配。</p><p>字符串长度 $3\times10^5$。</p><a id="more"></a><h1 id="简要做法"><a href="#简要做法" class="headerlink" title="简要做法"></a>简要做法</h1><p>这题是利用字符串的距离函数来匹配字符串，使用 FFT 优化距离函数的计算。</p><p>将通配符的值设为零，定义 $dis(s,t)=\sum(s[i]-t[i])^2s[i]t[i]​$，那么两个等长的字符串匹配当且仅当它们的距离为零。</p><p>为了方便卷积，将题目中的 $A$ 串翻转​得到串 $A’​$。</p><p>推一波式子：</p><p>$\begin{aligned}dis(A,B[i..i+m-1])&amp;=\sum\limits_{j=0}^{m-1}(A’[m-j-1]-B[i+j])^2A’[m-j-1]B[i+j]\\&amp;=\left(\sum\limits_{j=0}^{m-1}A’[m-j-1]B^3[i+j]\right)-2\left(\sum\limits_{j=0}^{m-1}(A’)^2[m-j-1]B^2[i+j]\right)+\left(\sum\limits_{j=0}^{m-1}(A’)^3[m-j-1]B[i+j]\right)\end{aligned}$</p><p>设 $f(i)=\sum\limits_{j=0}^{i}A’[i-j]B^3[j]​$（即它们的卷积），将 $A’[m..n-1]​$ 设为 $0​$，那么 $\sum\limits_{j=0}^{m-1}A’[m-j-1]B^3[i+j]=f(i+m-1)​$。</p><p>可以类似地计算另外两项，就可以求出所有 $dis(A,B[i..i+m-1])​$，看看哪些等于零就好了。</p><h1 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1</span>&lt;&lt;<span class="number">19</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> re,im;</span><br><span class="line">    cp(<span class="keyword">double</span> _re=<span class="number">0.0</span>,<span class="keyword">double</span> _im=<span class="number">0.0</span>) &#123; re=_re; im=_im; &#125;</span><br><span class="line">    cp <span class="keyword">operator</span>+(<span class="keyword">const</span> cp&amp; b) <span class="keyword">const</span> &#123; <span class="keyword">return</span> cp(re+b.re,im+b.im); &#125;</span><br><span class="line">    cp <span class="keyword">operator</span>-(<span class="keyword">const</span> cp&amp; b) <span class="keyword">const</span> &#123; <span class="keyword">return</span> cp(re-b.re,im-b.im); &#125;</span><br><span class="line">    cp <span class="keyword">operator</span>*(<span class="keyword">const</span> cp&amp; b) <span class="keyword">const</span> &#123; <span class="keyword">return</span> cp(re*b.re-im*b.im,re*b.im+im*b.re); &#125;</span><br><span class="line">&#125; a[N],a2[N],a3[N],b[N],b2[N],b3[N],c1[N],c2[N],c3[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fft</span><span class="params">(cp* A,<span class="keyword">int</span> type)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,lim,L,r[N];</span><br><span class="line"><span class="keyword">char</span> s[N],t[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%s%s"</span>,&amp;m,&amp;n,s,t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m-i&gt;<span class="number">0</span>&amp;&amp;s[m-i<span class="number">-1</span>]!=<span class="string">'*'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            a[i].re=s[m-i<span class="number">-1</span>]-<span class="string">'a'</span>+<span class="number">1</span>;</span><br><span class="line">            a2[i].re=a[i].re*a[i].re;</span><br><span class="line">            a3[i].re=a[i].re*a2[i].re;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t[i]!=<span class="string">'*'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            b[i].re=t[i]-<span class="string">'a'</span>+<span class="number">1</span>;</span><br><span class="line">            b2[i].re=b[i].re*b[i].re;</span><br><span class="line">            b3[i].re=b[i].re*b2[i].re;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (lim=<span class="number">0</span>,L=<span class="number">1</span>;L&lt;=n;++lim,L&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;L;++i) r[i]=(r[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(lim<span class="number">-1</span>));</span><br><span class="line"></span><br><span class="line">    fft(a,<span class="number">1</span>);</span><br><span class="line">    fft(a2,<span class="number">1</span>);</span><br><span class="line">    fft(a3,<span class="number">1</span>);</span><br><span class="line">    fft(b,<span class="number">1</span>);</span><br><span class="line">    fft(b2,<span class="number">1</span>);</span><br><span class="line">    fft(b3,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;L;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        c1[i]=a[i]*b3[i];</span><br><span class="line">        c2[i]=a2[i]*b2[i];</span><br><span class="line">        c3[i]=a3[i]*b[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fft(c1,<span class="number">-1</span>);</span><br><span class="line">    fft(c2,<span class="number">-1</span>);</span><br><span class="line">    fft(c3,<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=m<span class="number">-1</span>;i&lt;n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (c1[i].re<span class="number">-2</span>*c2[i].re+c3[i].re&lt;<span class="number">0.5</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.push_back(i-m+<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="keyword">int</span>(ans.size()));</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;ans.size();++i) <span class="built_in">printf</span>(<span class="string">"%d "</span>,ans[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fft</span><span class="params">(cp* A,<span class="keyword">int</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,k;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;L;++i) <span class="keyword">if</span> (i&lt;r[i]) swap(A[i],A[r[i]]);</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;L;i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">cp <span class="title">w1</span><span class="params">(<span class="built_in">cos</span>(PI/i),type*<span class="built_in">sin</span>(PI/i))</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;L;j+=<span class="number">2</span>*i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">cp <span class="title">w</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (k=j;k&lt;i+j;++k,w=w*w1)</span><br><span class="line">            &#123;</span><br><span class="line">                cp t=A[k+i]*w;</span><br><span class="line">                A[k+i]=A[k]-t;</span><br><span class="line">                A[k]=A[k]+t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (type==<span class="number">-1</span>) <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;L;++i) A[i].re=A[i].re/L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/P4173&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;洛谷&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://darkbzoj.cf/problem/4259&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;darkbzoj&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;题意简述&quot;&gt;&lt;a href=&quot;#题意简述&quot; class=&quot;headerlink&quot; title=&quot;题意简述&quot;&gt;&lt;/a&gt;题意简述&lt;/h1&gt;&lt;p&gt;带通配符的单模式串、单文本串匹配。&lt;/p&gt;
&lt;p&gt;字符串长度 $3\times10^5$。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://ouuan.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="字符串" scheme="https://ouuan.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="FFT" scheme="https://ouuan.github.io/tags/FFT/"/>
    
  </entry>
  
  <entry>
    <title>2019YALI省选集训垫底记</title>
    <link href="https://ouuan.github.io/2019YALI%E7%9C%81%E9%80%89%E9%9B%86%E8%AE%AD%E5%9E%AB%E5%BA%95%E8%AE%B0/"/>
    <id>https://ouuan.github.io/2019YALI省选集训垫底记/</id>
    <published>2019-03-17T11:36:39.000Z</published>
    <updated>2019-03-28T13:23:38.721Z</updated>
    
    <content type="html"><![CDATA[<p>时隔半年又来到了YALI。</p><a id="more"></a><h1 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h1><p>中午放学，下午就坐火车走了。</p><p>晚上被骗去吃火宫殿..</p><p>然后做了一个 slide.</p><h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h1><p>T1是个字符串，一开始以为可以 $50$，先把 $30$ 写了然后去看后两题，回来发现那 $20$ 没法写..最后因为数组名 $end$ CE了..</p><p>T2还是个字符串，只不过是在图上，<del>是道大象题</del>，求期望，要高斯消元，利用非 $0​$ 项很少来降低复杂度。一开始先把不用求期望（每个点出度为 $1​$）的 $20​$ 分写了，然后就去看 $T3​$。后来回头发现 $T1​$ 的 $20​$ 写不出来，就来写这题的 $10​$ 分暴力高斯消元，然后调了 $1h​$，一开始先是概率各种算错，后来其它的都写对了，结果我脑抽写成了字符串失配跳到 $0​$ …</p><p>T3是<del>zzq最爱的</del>提答，又是给一种计算机。随便玩了 $47​$ 分。下午讲题的时候有几位神仙在那快乐地碾了碾标算..</p><p>做题的时候先是看到 ctr zzq，然后往右一看，发现 zzq 就在黑板前的电脑前坐着..之前就听说 _rqy 也要来，做题做到一半的时候看到 _rqy 去找 zzq 报告了两个 bug.. </p><p>之前就有猜测过：</p><img src="/2019YALI省选集训垫底记/rqy.png"><p>然后..下午果然是神仙聊天场，_rqy 现场推多项式三角函数..</p><img src="/2019YALI省选集训垫底记/tan.jpg"><p>晚上没去机房..游记就是晚上写的qaq</p><h1 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h1><p>今天有三种类型的题目，<del>性价比高</del>。</p><p>T1 是道图论交互，只会暴力 $20$..</p><p>T2 是道图论传统题，一开始以为直接欧拉回路就是正解，然后随便一拍就挂了..后来得知欧拉回路是正解的一部分。</p><p>T3 是道扫雷提答，暴力跑了 $4​$ 个点，构造了两个点，下午的时候手玩了一个点..是除了周围雷数还有行/列之和，行/列连续段个数之类的那种。</p><p>下午讲题的时候竟然有人讲<a href="https://www.luogu.org/problemnew/show/P4963" target="_blank" rel="noopener">美樱的颜料</a>..个人认为那题出的不是很好..<del>尤其是Sooke为卡loglogn设的空间限制..</del></p><img src="/2019YALI省选集训垫底记/mio.jpg"><h1 id="Day-3"><a href="#Day-3" class="headerlink" title="Day 3"></a>Day 3</h1><p>今天是讲题..感觉全场可能就我不会生成函数，只不过感觉好像大概弄明白了。</p><p>晚上把讲题咕咕了，结果不小心错过了 _rqy 的难题选讲..</p><h1 id="Day-4"><a href="#Day-4" class="headerlink" title="Day 4"></a>Day 4</h1><p>T1 是个数据结构，看了看觉得有 $41$ 分非常可做，先写了个暴力去肝后面两题，最后回来写这题，很快写完了 $30$ 分，然后把 $30$ 分备份了一下去写剩下的 $11$ 分，写的过程中发现 $30$ 分有个地方挂了，就在 $41$ 分代码里面改过来了，后来剩下 $11$ 分没写完，就把备份（没修改那个地方）的代码交上去了..最后连询问数为 $0$ 的 subtask 都挂了，只有 $22$ 分。</p><p>T2 是道<del>小清新0.5KB</del>找规律题。成功找到规律然后 A 掉了..</p><p>T3 是俄罗斯方块提答..搞了三个点，剩下的随机..获得了 $16$ 分的好成绩。之后 _rqy 说自己写了个模拟器手玩，于是我下午就自己写了个模拟器手玩..草，真的又好写又好玩，$1h$ 十几分绝对没问题..</p><h1 id="Day-5"><a href="#Day-5" class="headerlink" title="Day 5"></a>Day 5</h1><p>今天大众分 $200$..窝愉快垫底了。</p><p>T1 是个数据结构，定义数列中每个数的后继为它后面比它大的第一个数，区间询问跳到后继最多能跳多少步。暴力 $30$ 分滚粗。</p><p>T2 是个树交互，还比较简单吧..然而 std 做法看起来就很麻烦，所以没仔细听具体是怎么做的。</p><p><del>T3 是道 MO 题</del>，全场只有暴力 $15$ 和爆零..然后我考场上愉快地调了 $2h​$ 暴力，RETLEWA……最后还是没调出来。</p><h1 id="Day-6"><a href="#Day-6" class="headerlink" title="Day 6"></a>Day 6</h1><p>今天又是讲题..晚上轮到我难题讨论，讲了下<del>早就被我讲烂了的</del>皇后游戏&amp;由乃大母神原型与偶像崇拜。</p><h1 id="Day-7"><a href="#Day-7" class="headerlink" title="Day 7"></a>Day 7</h1><p>T1 是一个树上的神仙题..把暴力 $68$ 分打满了（$n^2$&amp;链&amp;菊花）。考场上写完菊花之后去看 T2，T3，然后放在那对拍，错了五六次才调对..</p><p>T2 是个神仙博弈论，只写了暴力 $17$ 分..</p><p>T3 是个神仙交互，用随机化搞到了 $66$ 分（期望得分 $67$，脸黑被卡到了 $66.99$），然而没有发现把 subtask3 的代码复制到 subtask4 后面就可以轻松获得 $60\%$ subtask5 的分数..</p><p>这场虽然没 A 题，然而好像是我得分最高的一场？</p><h1 id="Day-8"><a href="#Day-8" class="headerlink" title="Day 8"></a>Day 8</h1><p>T1指令集RE了..只不过写了数据分治还有暴力分。本地比正解跑的还快qaq..ylh用 $\mathcal O(n\sqrt n\log n)$ 艹过去了 Orz.</p><p>T2暴力。</p><p>T3暴力被卡常了。</p><p>垫底..分最低的一次。</p><h1 id="Day-9"><a href="#Day-9" class="headerlink" title="Day 9"></a>Day 9</h1><p>讲课，颓。</p><h1 id="Day-10"><a href="#Day-10" class="headerlink" title="Day 10"></a>Day 10</h1><p>T1暴力，ylh的暴力偏序被卡了。</p><p>T2会求答案不会求方案，结果下午才知道大家都会求答案..</p><p>T3暴力，不会类欧自闭了。</p><h1 id="Day-11"><a href="#Day-11" class="headerlink" title="Day 11"></a>Day 11</h1><p>和第二天互换了，讲课，继续春眠zzz..</p><h1 id="Day-12"><a href="#Day-12" class="headerlink" title="Day 12"></a>Day 12</h1><p>今天 T1 是五子棋互打，想着今天是最后一天，于是就真的写了整场（$3.5h$）的 T1。一开始写了个爆搜，后来发现很蠢，于是就算了个估价函数，然后感觉很对。然而 ctr 乱测..之后我把 ctr 测出来的前 $21$ 名测了一下，和 ctr 测出来的差别还挺大的..只不过我好像在执黑/执白的情况下都打过了其它人写的AI..然而被 ylh（人）击败了..</p><p>T2 题面掉了个关键条件，于是不会做..花 $20min$ 写了 $35$ 分。</p><p>T3 觉得部分分写起来很麻烦，于是最后半个多小时就一直在看自己的 AI 和自己的 AI 下棋..</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>要是省选没有非传统题就要凉凉的感觉…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;时隔半年又来到了YALI。&lt;/p&gt;
    
    </summary>
    
      <category term="游记" scheme="https://ouuan.github.io/categories/%E6%B8%B8%E8%AE%B0/"/>
    
    
      <category term="集训" scheme="https://ouuan.github.io/tags/%E9%9B%86%E8%AE%AD/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ3622 已经没有什么好害怕的了（二项式反演，组合数学）</title>
    <link href="https://ouuan.github.io/BZOJ3622-%E5%B7%B2%E7%BB%8F%E6%B2%A1%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%AE%B3%E6%80%95%E7%9A%84%E4%BA%86%EF%BC%88%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%8F%8D%E6%BC%94%EF%BC%8C%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%EF%BC%89/"/>
    <id>https://ouuan.github.io/BZOJ3622-已经没有什么好害怕的了（二项式反演，组合数学）/</id>
    <published>2019-03-15T04:48:17.000Z</published>
    <updated>2019-04-02T23:54:59.567Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.luogu.org/problemnew/show/P4859" target="_blank" rel="noopener">洛谷</a></p><p><a href="https://darkbzoj.cf/problem/3622" target="_blank" rel="noopener">darkbzoj</a></p><h1 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h1><p>给你两个长为 $n$ 、无重复元素的数列 $a,b$，求将 $b$ 重排后 $\left(\sum\limits_{i=1}^n[a_i&gt;b_i]\right)-\left(\sum\limits_{i=1}^n[a_i&lt;b_i]\right)=k$（$k$ 给定）的方案数。</p><p>$n\le2000$。</p><a id="more"></a><h1 id="简要做法"><a href="#简要做法" class="headerlink" title="简要做法"></a>简要做法</h1><p>首先，$a$ 大于 $b$ 比 $b$ 大于 $a$ 多 $k$ 对可以转化为 $a$ 大于 $b$ 有 $\frac{n+k}2$ 对。</p><p>考虑 $dp​$，设 $f(i,j)​$ 为 $a_{1..i}​$ 中选 $j​$ 个数，给这 $j​$ 个数每个数匹配一个小于它的 $b​$ 的方案数。为方便转移，一开始要先对 $a,b​$ 分别从小到大排序，这样的话若 $a_i&gt;b_j​$，必然有 $a_{i+1}&gt;b_j​$。</p><p>设比 $a_i$ 大的 $b$ 有 $cnt_i$ 个，转移方程就是 $f(i,j)=f(i-1,j)+(cnt_i-j+1)\times f(i-1,j-1)$。$cnt_i$ 可以二分查找/双指针计算。</p><p>考虑这样一个式子：$f(n,i)\times(n-i)!$，它的意义是，先从 $a$ 中选 $i$ 个数，给它们分别匹配一个小于它们的 $b$，再把剩下的 $n-i$ 个数随意匹配。这个式子并不是某种“方案数”，因为它可能会将相同的匹配方案算重。事实上，对于每种恰有 $j$ 对 $a&gt;b$ 的匹配方案，它在 $f(n,i)\times(n-i)!$ 中被计算了 $\binom{j}{i}$ 次。令 $ans_i$ 表示恰好有 $i$ 对 $a$ 大于 $b$ 的方案数，就有 $ans_i=f(n,i)\times(n-i)!-\sum\limits_{j=i+1}^n\binom{j}{i}ans_j$。这样的话，就可以递推地计算答案。</p><p>这题还有另一种做法，叫二项式反演。我自己没有太理解清楚这种方法，所以不详细阐述。这种做法可以 $O(n)​$ 地计算某个 $ans_i​$，但不影响总复杂度（$dp​$ 还是 $O(n^2)​$ 的）：</p><p>$$ans_i=\sum\limits_{j=i}^n(-1)^{j-i}\binom j i f(n,j)\times(n-j)​$$</p><h1 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,k,a[N],b[N],f[N][N],ans[N],c[N][N],fac[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,cnt=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((n&amp;<span class="number">1</span>)!=(k&amp;<span class="number">1</span>)) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    k=(n+k)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,b+i);</span><br><span class="line"></span><br><span class="line">    sort(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line">    sort(b+<span class="number">1</span>,b+n+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;++i) fac[i]=(ll)fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line"></span><br><span class="line">    c[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        c[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=i;++j) c[i][j]=(c[i<span class="number">-1</span>][j<span class="number">-1</span>]+c[i<span class="number">-1</span>][j])%mod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (cnt&lt;n&amp;&amp;b[cnt+<span class="number">1</span>]&lt;a[i]) ++cnt;</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=cnt;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j]=(f[i<span class="number">-1</span>][j]+(ll)f[i<span class="number">-1</span>][j<span class="number">-1</span>]*(cnt-j+<span class="number">1</span>))%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=n;i&gt;=k;--i)</span><br><span class="line">    &#123;</span><br><span class="line">        ans[i]=(ll)f[n][i]*fac[n-i]%mod;</span><br><span class="line">        <span class="keyword">for</span> (j=n;j&gt;i;--j) ans[i]=(ans[i]+mod-(ll)ans[j]*c[j][i]%mod)%mod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans[k];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> out=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (y&amp;<span class="number">1</span>) out=(ll)out*x%mod;</span><br><span class="line">        x=(ll)x*x%mod;</span><br><span class="line">        y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/P4859&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;洛谷&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://darkbzoj.cf/problem/3622&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;darkbzoj&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;题意简述&quot;&gt;&lt;a href=&quot;#题意简述&quot; class=&quot;headerlink&quot; title=&quot;题意简述&quot;&gt;&lt;/a&gt;题意简述&lt;/h1&gt;&lt;p&gt;给你两个长为 $n$ 、无重复元素的数列 $a,b$，求将 $b$ 重排后 $\left(\sum\limits_{i=1}^n[a_i&amp;gt;b_i]\right)-\left(\sum\limits_{i=1}^n[a_i&amp;lt;b_i]\right)=k$（$k$ 给定）的方案数。&lt;/p&gt;
&lt;p&gt;$n\le2000$。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://ouuan.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="组合数学" scheme="https://ouuan.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
      <category term="二项式反演" scheme="https://ouuan.github.io/tags/%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ4665 小w的喜糖（容斥原理，组合数学）</title>
    <link href="https://ouuan.github.io/BZOJ4665-%E5%B0%8Fw%E7%9A%84%E5%96%9C%E7%B3%96%EF%BC%88%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86%EF%BC%8C%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%EF%BC%89/"/>
    <id>https://ouuan.github.io/BZOJ4665-小w的喜糖（容斥原理，组合数学）/</id>
    <published>2019-03-13T13:10:56.000Z</published>
    <updated>2019-04-02T23:56:40.373Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://darkbzoj.cf/problem/4665" target="_blank" rel="noopener">darkbzoj</a></p><h1 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h1><p>给你一个数列，求重排后每个位置都变了的方案数。</p><p>数列长度和值域都是 $2000$。</p><a id="more"></a><h1 id="简要做法"><a href="#简要做法" class="headerlink" title="简要做法"></a>简要做法</h1><p>考虑容斥，计 $g(S)​$ 为 $S​$ 这个集合内的所有位置都不变的方案数，$U​$ 为位置的全集（即 $1​$ ~ $n​$），$i​$ 这个数出现了 $cnt[i]​$ 次，答案即为 $\frac{n!}{\prod\limits_{i=1}^ncnt[i]!}+\sum\limits_{S\subseteq U,S\ne\varnothing}(-1)^{|S|}g(S)​$。</p><p>计 $P_i$ 为 $i$ 这个数出现的位置集合，那么 $g(S)=\frac{(n-|S|)!\prod\limits_{i=1}^n\frac{cnt[i]!}{(cnt[i]-|P_i\bigcap S|)!}}{\prod\limits_{i=1}^ncnt[i]!}​$。</p><p>暴力枚举子集肯定是过不了的，考虑如何优化。</p><p>容斥原理的优化一般是将答案相同/结构相似的部分合在一起算，这题中，可以尝试将 $|S|$ 相同的集合合在一起算，问题就在于如何快速计算 $|S|$ 相同的所有 $\prod\limits_{i=1}^n\frac{cnt[i]!}{(cnt[i]-|P_i\bigcap S|)!}$ 之和。</p><p>这个东西可以用 $dp$ 解决：设 $f(i,j)$ 为从值为 $1$ ~ $i$ 的所有数中选 $j$ 个数的所有不同方案的贡献之和，其中，一种选法的贡献就是将选的数作为 $S$ 的 $\prod\limits_{i=1}^n\frac{cnt[i]!}{(cnt[i]-|P_i\bigcap S|)!}$。转移时枚举值为 $i$ 的数选了 $k$ 个，那么 $f(i,j)=\sum\limits_{k=0}^{\min(j,cnt[i])}\frac{cnt[i]!}{(cnt[i]-k)!}\binom{cnt[i]}kf(i-1,j-k)$. 由于 $cnt[i]$ 之和为 $n$，$dp$ 复杂度是 $O(n^2)$。</p><p>这样的话，最终的答案就是 $\frac{n!+\sum\limits_{i=1}^n(-1)^i(n-i)!f(n,i)}{\prod\limits_{i=1}^ncnt[i]!}$，实际上 $f(n,0)=1$，所以也可以化简为  $\frac{\sum\limits_{i=0}^n(-1)^i(n-i)!f(n,i)}{\prod\limits_{i=1}^ncnt[i]!}$.</p><h1 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,cnt[N],fac[N],inv[N],f[N][N],c[N][N],ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,k,x;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    fac[<span class="number">0</span>]=inv[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">        ++cnt[x];</span><br><span class="line">        fac[i]=(ll)fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">        inv[i]=qpow(fac[i],mod<span class="number">-2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    c[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        c[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=i;++j) c[i][j]=(c[i<span class="number">-1</span>][j<span class="number">-1</span>]+c[i<span class="number">-1</span>][j])%mod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;=n;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (k=<span class="number">0</span>;k&lt;=cnt[i]&amp;&amp;k&lt;=j;++k)</span><br><span class="line">            &#123;</span><br><span class="line">                f[i][j]=(f[i][j]+(ll)fac[cnt[i]]*inv[cnt[i]-k]%mod*f[i<span class="number">-1</span>][j-k]%mod*c[cnt[i]][k])%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;=n;++i) ans=(ans+(ll)(i&amp;<span class="number">1</span>?<span class="number">-1</span>:<span class="number">1</span>)*fac[n-i]*f[n][i]+mod)%mod;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;++i) ans=(ll)ans*inv[cnt[i]]%mod;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> out=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (y&amp;<span class="number">1</span>) out=(ll)out*x%mod;</span><br><span class="line">        x=(ll)x*x%mod;</span><br><span class="line">        y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://darkbzoj.cf/problem/4665&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;darkbzoj&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;题意简述&quot;&gt;&lt;a href=&quot;#题意简述&quot; class=&quot;headerlink&quot; title=&quot;题意简述&quot;&gt;&lt;/a&gt;题意简述&lt;/h1&gt;&lt;p&gt;给你一个数列，求重排后每个位置都变了的方案数。&lt;/p&gt;
&lt;p&gt;数列长度和值域都是 $2000$。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://ouuan.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="组合数学" scheme="https://ouuan.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
      <category term="容斥原理" scheme="https://ouuan.github.io/tags/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ4003 [JLOI2015]城池攻占（左偏树）</title>
    <link href="https://ouuan.github.io/BZOJ4003-JLOI2015-%E5%9F%8E%E6%B1%A0%E6%94%BB%E5%8D%A0%EF%BC%88%E5%B7%A6%E5%81%8F%E6%A0%91%EF%BC%89/"/>
    <id>https://ouuan.github.io/BZOJ4003-JLOI2015-城池攻占（左偏树）/</id>
    <published>2019-03-12T08:14:15.000Z</published>
    <updated>2019-04-02T23:56:02.337Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.luogu.org/problemnew/show/P3261" target="_blank" rel="noopener">洛谷</a></p><p><a href="https://darkbzoj.cf/problem/4003" target="_blank" rel="noopener">darkbzoj</a></p><h1 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h1><p>给你一棵树，每个节点有 $h$ 值，一个勇士来到一个节点时如果他的战斗力大于等于 $h$ 就能占领城池并前往这个节点的父亲（除非已经到了根节点），否则阵亡；攻占一个节点后，勇士的战斗力会加/减/乘一个正整数（根据节点而定）；每个勇士有初始战斗力和想占领的第一个节点。问，每个节点各有多少个勇士阵亡，每个勇士各占领了几个节点。</p><a id="more"></a><h1 id="简要做法"><a href="#简要做法" class="headerlink" title="简要做法"></a>简要做法</h1><p>每个节点搞个小根可并堆维护该节点所有勇士（包括一开始就在这的和爬上来的），当堆顶小于 $h$ 时弹出并更新答案，直到堆为空或者堆顶大于等于 $h$，然后再加/减/乘，合并到父亲。</p><p>加/减/乘：更新堆顶并打标记，在所有需要访问儿子的地方（弹出堆顶时/合并时）下传标记。</p><p>合并复杂度：每个勇士初始位置需要合并一次，每个节点合并到父亲要一次，$O((n+m)\log m)$；弹出复杂度：每个勇士最多被弹出一次，$O(m\log m)$；修改复杂度：除了下传标记外每次修改都是 $O(1)$ 的，所以是 $O(n)$；总复杂度：$O((n+m)\log m)$。</p><h1 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll out=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">for</span> (c=getchar();!<span class="built_in">isdigit</span>(c)&amp;&amp;c!=<span class="string">'-'</span>;c=getchar());</span><br><span class="line">    <span class="keyword">if</span> (c==<span class="string">'-'</span>) f=<span class="number">-1</span>,c=getchar();</span><br><span class="line">    <span class="keyword">for</span> (;<span class="built_in">isdigit</span>(c);c=getchar()) out=out*<span class="number">10</span>+c-<span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">return</span> out*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">300010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ls,rs,d;</span><br><span class="line">    ll val,add,mul;</span><br><span class="line">    Node()&#123;ls=rs=add=<span class="number">0</span>;d=mul=<span class="number">1</span>;&#125;</span><br><span class="line">&#125; t[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">madd</span><span class="params">(<span class="keyword">int</span> u,ll x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mmul</span><span class="params">(<span class="keyword">int</span> u,ll x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N],nxt[N],to[N],cnt;</span><br><span class="line"><span class="keyword">int</span> n,m,p[N],f[N],a[N],dep[N],c[N],ans1[N],ans2[N];</span><br><span class="line">ll h[N],b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    n=read();</span><br><span class="line">    m=read();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;++i) h[i]=read();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">2</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i]=read();</span><br><span class="line">        add(f[i],i);</span><br><span class="line">        a[i]=read();</span><br><span class="line">        b[i]=read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        t[i].val=read();</span><br><span class="line">        c[i]=read();</span><br><span class="line">        p[c[i]]=merge(i,p[c[i]]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans1[i]);</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;++i) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans2[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,v;</span><br><span class="line">    <span class="keyword">for</span> (i=head[u];i;i=nxt[i])</span><br><span class="line">    &#123;</span><br><span class="line">        v=to[i];</span><br><span class="line">        dep[v]=dep[u]+<span class="number">1</span>;</span><br><span class="line">        dfs(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p[u]&amp;&amp;t[p[u]].val&lt;h[u])</span><br><span class="line">    &#123;</span><br><span class="line">        ++ans1[u];</span><br><span class="line">        ans2[p[u]]=dep[c[p[u]]]-dep[u];</span><br><span class="line">        p[u]=pop(p[u]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a[u]) mmul(p[u],b[u]);</span><br><span class="line">    <span class="keyword">else</span> madd(p[u],b[u]);</span><br><span class="line">    <span class="keyword">if</span> (u&gt;<span class="number">1</span>) p[f[u]]=merge(p[u],p[f[u]]);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">while</span> (p[u])</span><br><span class="line">    &#123;</span><br><span class="line">        ans2[p[u]]=dep[c[p[u]]]+<span class="number">1</span>;</span><br><span class="line">        p[u]=pop(p[u]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    nxt[++cnt]=head[u];</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">    to[cnt]=v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x||!y) <span class="keyword">return</span> x|y;</span><br><span class="line">    <span class="keyword">if</span> (t[x].val&gt;t[y].val) swap(x,y);</span><br><span class="line">    pushdown(x);</span><br><span class="line">    t[x].rs=merge(t[x].rs,y);</span><br><span class="line">    <span class="keyword">if</span> (t[t[x].rs].d&gt;t[t[x].ls].d) swap(t[x].ls,t[x].rs);</span><br><span class="line">    t[x].d=t[t[x].rs].d+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pushdown(x);</span><br><span class="line">    <span class="keyword">return</span> merge(t[x].ls,t[x].rs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">madd</span><span class="params">(<span class="keyword">int</span> u,ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t[u].val+=x;</span><br><span class="line">    t[u].add+=x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mmul</span><span class="params">(<span class="keyword">int</span> u,ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t[u].val*=x;</span><br><span class="line">    t[u].add*=x;</span><br><span class="line">    t[u].mul*=x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mmul(t[x].ls,t[x].mul);</span><br><span class="line">    madd(t[x].ls,t[x].add);</span><br><span class="line">    mmul(t[x].rs,t[x].mul);</span><br><span class="line">    madd(t[x].rs,t[x].add);</span><br><span class="line">    t[x].add=<span class="number">0</span>;</span><br><span class="line">    t[x].mul=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/P3261&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;洛谷&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://darkbzoj.cf/problem/4003&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;darkbzoj&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;题意简述&quot;&gt;&lt;a href=&quot;#题意简述&quot; class=&quot;headerlink&quot; title=&quot;题意简述&quot;&gt;&lt;/a&gt;题意简述&lt;/h1&gt;&lt;p&gt;给你一棵树，每个节点有 $h$ 值，一个勇士来到一个节点时如果他的战斗力大于等于 $h$ 就能占领城池并前往这个节点的父亲（除非已经到了根节点），否则阵亡；攻占一个节点后，勇士的战斗力会加/减/乘一个正整数（根据节点而定）；每个勇士有初始战斗力和想占领的第一个节点。问，每个节点各有多少个勇士阵亡，每个勇士各占领了几个节点。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://ouuan.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="数据结构" scheme="https://ouuan.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="左偏树" scheme="https://ouuan.github.io/tags/%E5%B7%A6%E5%81%8F%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>CF235C Cyclical Quest（SAM）</title>
    <link href="https://ouuan.github.io/CF235C-Cyclical-Quest%EF%BC%88SAM%EF%BC%89/"/>
    <id>https://ouuan.github.io/CF235C-Cyclical-Quest（SAM）/</id>
    <published>2019-02-27T05:23:19.000Z</published>
    <updated>2019-04-02T23:57:08.338Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.luogu.org/problemnew/show/CF235C" target="_blank" rel="noopener">洛谷</a></p><p><a href="https://codeforces.com/problemset/problem/235/C" target="_blank" rel="noopener">CF problemset</a></p><p><a href="https://codeforces.com/contest/235/problem/C" target="_blank" rel="noopener">CF contest</a></p><h1 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h1><p>给你一个字符串 $s$ 和 $n$ 个字符串 $x_{1..n}$，对每个 $x_i$，求有多少个 $s$ 的子串可以由 $x_i$ 旋转得到。</p><p>旋转一个字符串就是把它的一个前缀移到后面，如 <code>abcd</code> 可以旋转得到的字符串有 <code>abcd</code>，<code>bcda</code>，<code>cdab</code>，<code>dabc</code>。</p><a id="more"></a><h1 id="简要做法"><a href="#简要做法" class="headerlink" title="简要做法"></a>简要做法</h1><p>对 $s$ 建 SAM，把 $x_i$ 旋转得到的每个字符串用 SAM 读入，就可以求答案了。（SAM 求子串出现次数是经典问题，可以参考<a href="https://ouuan.github.io/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA%EF%BC%88SAM%EF%BC%89%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#%E5%AD%90%E4%B8%B2%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0">我的博客</a>）</p><p>分开读入每个 $x_i$ 旋转得到的字符串显然会超时，然而，SAM 读入字符串是支持删除首字符的：记录当前读入的长度 $l$ 以及所处状态 $u$，删除字符就把 $l$ 减一，若减一后 $l=len(parent(u))$，则转移到 $parent(u)$（把 $u$ 赋值为 $parent(t)$）。需要注意的是，如果读入一个字符的时候当前状态没有这个字符的出边，就需要在 $parent$ 树上向上跳，直到有这个字符的出边，同时更新 $l$ 。这样的话，删除字符前就要先判断 $l$ 与需要保留的字符串的长度的关系。具体细节可以参考代码及注释。</p><p>所以，先读入 $x_i$ 统计答案，再删去首字符读入 $x_i[0]$ 统计答案，删去首字符读入 $x_i[1]$ 统计答案……就只用读入 $O(len(x_i))​$ 个字符。</p><p>还有一个问题，就是去重。$s$ 的一个子串可能可以和 $x_i$ 不同的旋转匹配。解决这个问题有两个方法，第一个是求出 $x_i​$ 的周期（可以用 kmp 求），第二个方法是在 SAM 上打标记。我用的是打标记的方法，具体细节还是可以参考代码及注释。</p><h1 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> len,par,ch[<span class="number">26</span>],vis,cnt;</span><br><span class="line">&#125; sam[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> head[N&lt;&lt;<span class="number">1</span>],nxt[N&lt;&lt;<span class="number">1</span>],to[N&lt;&lt;<span class="number">1</span>],cnt;</span><br><span class="line"><span class="keyword">int</span> p,tot,n,m,l,u,tim,ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s%d"</span>,s,&amp;n);</span><br><span class="line"></span><br><span class="line">    sam[<span class="number">0</span>].par=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;s[i];++i) insert(s[i]-<span class="string">'a'</span>);</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=tot;++i) add(sam[i].par,i);</span><br><span class="line">    dfs(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (tim=<span class="number">1</span>;tim&lt;=n;++tim)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line">        m=<span class="built_in">strlen</span>(s);</span><br><span class="line">        ans=u=l=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;m;++i) read(s[i]-<span class="string">'a'</span>);</span><br><span class="line">        calc();</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;m<span class="number">-1</span>;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            read(s[i]-<span class="string">'a'</span>);</span><br><span class="line">            del();</span><br><span class="line">            calc();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">//读入一个字符</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (u&amp;&amp;!sam[u].ch[x]) l=sam[u=sam[u].par].len; <span class="comment">//向上跳直至有这个字符的出边</span></span><br><span class="line">    <span class="keyword">if</span> (sam[u].ch[x])</span><br><span class="line">    &#123;</span><br><span class="line">        ++l;</span><br><span class="line">        u=sam[u].ch[x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">()</span> <span class="comment">//删除首字符</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l&gt;m&amp;&amp;--l==sam[sam[u].par].len) u=sam[u].par; <span class="comment">//m表示当前xi的长度，只有l&gt;m的时候才删除</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">()</span> <span class="comment">//计算当前的答案</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l==m&amp;&amp;sam[u].vis&lt;tim) <span class="comment">//只有当前读入的串长度恰好为m且当前状态没有打上标记时才统计答案</span></span><br><span class="line">    &#123;</span><br><span class="line">        ans+=sam[u].cnt;</span><br><span class="line">        sam[u].vis=tim; <span class="comment">//打标记</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">//向SAM中插入字符，有人把这个函数叫做extend</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> np=++tot;</span><br><span class="line">    sam[np].len=sam[p].len+<span class="number">1</span>;</span><br><span class="line">    sam[np].cnt=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (~p&amp;&amp;!sam[p].ch[x])</span><br><span class="line">    &#123;</span><br><span class="line">        sam[p].ch[x]=np;</span><br><span class="line">        p=sam[p].par;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p==<span class="number">-1</span>) sam[np].par=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> q=sam[p].ch[x];</span><br><span class="line">        <span class="keyword">if</span> (sam[q].len==sam[p].len+<span class="number">1</span>) sam[np].par=q;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> nq=++tot;</span><br><span class="line">            sam[nq].len=sam[p].len+<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">memcpy</span>(sam[nq].ch,sam[q].ch,<span class="keyword">sizeof</span>(sam[q].ch));</span><br><span class="line">            sam[nq].par=sam[q].par;</span><br><span class="line">            sam[q].par=sam[np].par=nq;</span><br><span class="line">            <span class="keyword">while</span> (~p&amp;&amp;sam[p].ch[x]==q)</span><br><span class="line">            &#123;</span><br><span class="line">                sam[p].ch[x]=nq;</span><br><span class="line">                p=sam[p].par;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    p=np;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> <span class="comment">//加边，用于遍历parent树</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    nxt[++cnt]=head[u];</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">    to[cnt]=v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> <span class="comment">//遍历parent树，计算每个状态的出现次数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,v;</span><br><span class="line">    <span class="keyword">for</span> (i=head[u];i;i=nxt[i])</span><br><span class="line">    &#123;</span><br><span class="line">        v=to[i];</span><br><span class="line">        dfs(v);</span><br><span class="line">        sam[u].cnt+=sam[v].cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/CF235C&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;洛谷&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://codeforces.com/problemset/problem/235/C&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CF problemset&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/235/problem/C&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CF contest&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;题意简述&quot;&gt;&lt;a href=&quot;#题意简述&quot; class=&quot;headerlink&quot; title=&quot;题意简述&quot;&gt;&lt;/a&gt;题意简述&lt;/h1&gt;&lt;p&gt;给你一个字符串 $s$ 和 $n$ 个字符串 $x_{1..n}$，对每个 $x_i$，求有多少个 $s$ 的子串可以由 $x_i$ 旋转得到。&lt;/p&gt;
&lt;p&gt;旋转一个字符串就是把它的一个前缀移到后面，如 &lt;code&gt;abcd&lt;/code&gt; 可以旋转得到的字符串有 &lt;code&gt;abcd&lt;/code&gt;，&lt;code&gt;bcda&lt;/code&gt;，&lt;code&gt;cdab&lt;/code&gt;，&lt;code&gt;dabc&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://ouuan.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="字符串" scheme="https://ouuan.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="SAM" scheme="https://ouuan.github.io/tags/SAM/"/>
    
  </entry>
  
  <entry>
    <title>后缀自动机（SAM）学习笔记</title>
    <link href="https://ouuan.github.io/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA%EF%BC%88SAM%EF%BC%89%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://ouuan.github.io/后缀自动机（SAM）学习笔记/</id>
    <published>2019-02-22T04:31:37.000Z</published>
    <updated>2019-04-03T00:05:10.406Z</updated>
    
    <content type="html"><![CDATA[<p>后缀自动机是一种处理字符串问题的有力工具（废话），它的码量不比后缀数组大（实际代码难度不比后缀数组小，但也不难），处理问题时的思维难度往往比后缀数组小，复杂度更优秀。若字符集大小为 $|\Sigma|$，则：构建时间复杂度 $O(n|\Sigma|)$，转移时间复杂度 $O(1)$，空间复杂度 $O(n|\Sigma|)$ 或 构建时间复杂度 $O(n\log|\Sigma|)$，转移时间复杂度 $O(\log|\Sigma|)$，空间复杂度 $O(n)$。</p><p><del>这篇文章会按我的理解详细地介绍一下 SAM，是否比其它教程更好懂我就不做评论了（毕竟所有人都认为自己的教程最好懂），只不过我会尽量保证教程的严谨性和正确性，同时尽量简洁（简洁地表达所有内容，而不是有选择地删去内容）。</del>这篇写的比较口胡随意..拉低了我写的教程的平均水平..只不过还是比市面上某些博客要强一些的（吧）。</p><p>这篇文章最大的特点..大约是讲了一些关于将自动机的状态数压缩至最少的方法。</p><a id="more"></a><h1 id="确定有限状态自动机（DFA）"><a href="#确定有限状态自动机（DFA）" class="headerlink" title="确定有限状态自动机（DFA）"></a>确定有限状态自动机（DFA）</h1><p>一个<strong>确定有限状态自动机（DFA）</strong>由以下五部分构成：</p><ol><li><strong>字符集</strong>（$\Sigma$），该自动机只能输入这些字符。</li><li><strong>状态集合</strong>（$Q$）。如果把一个DFA看成一张有向无环图（DAG），那么DFA中的状态就相当于图上的顶点。</li><li><strong>起始状态</strong>（$start$），$start\in Q$，是一个特殊的状态。起始状态一般用 $s$ 表示，为了避免混淆，本文中使用 $start$。</li><li><strong>接受状态集合</strong>（$F$），$F\subseteq Q$，是一堆特殊的状态。</li><li><strong>转移函数</strong>（$\delta$），$\delta$ 是一个接受两个参数返回一个值的函数，其中第一个参数和返回值都是一个状态，第二个参数是字符集中的一个字符。如果把一个DFA看成一张有向无环图（DAG），那么DFA中的转移函数就相当于顶点间的边，而每条边上都有一个字符。</li></ol><p>DFA的作用就是识别字符串，一个自动机 $A$，若它能识别（接受）字符串 $S$，那么 $A(S)=True$，否则 $A(S)=False$。</p><p>当一个DFA读入一个字符串时，从初始状态起按照转移函数一个一个字符地转移。如果读入完一个字符串的所有字符后位于一个接受状态，那么我们称这个DFA<strong>接受</strong>这个字符串，反之我们称这个DFA<strong>不接受</strong>这个字符串。</p><p>如果一个状态 $v$ 没有字符 $c$ 的转移，那么我们令 $\delta(v,c)=null$，而 $null$ 只能转移到 $null$，且 $null$ 不属于接受状态集合。无法转移到任何一个接受状态的状态都可以视作 $null$，或者说，$null​$ 代指所有无法转移到任何一个接受状态的状态。</p><p>我们扩展定义转移函数 $\delta​$，令其第二个参数可以接收一个字符串：$\delta(v,s)=\delta(\delta(v,s[0]),s[1..n-1])​$（$n​$ 表示 $s​$ 的长度），这个扩展后的转移函数就可以表示从一个状态起接收一个字符串后转移到的状态。那么，$A(s)=[\delta(start,s)\in F]​$。</p><p>如，一个接受且仅接受字符串 $a,ab,aac$ 的 DFA：</p><img src="/后缀自动机（SAM）学习笔记/dfa.png"><h1 id="后缀自动机（SAM）"><a href="#后缀自动机（SAM）" class="headerlink" title="后缀自动机（SAM）"></a>后缀自动机（SAM）</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>一个字符串的<strong>后缀自动机（SAM）</strong>就是一个<strong>接受且仅接受</strong>这个字符串的<strong>所有后缀</strong>的DFA。</p><p>下文中以 $SAM_s$ 代指字符串 $s$ 的后缀自动机，$\delta_s$ 代指 $SAM_s$ 的转移函数。若不带下标则表示字符串为母串 $s$（需要构建SAM的那个字符串）。</p><p>根据定义，一个字符串 $t​$ 是一个字符串 $s​$ 的后缀，当且仅当 $SAM_s(t)=True​$。</p><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>一个字符串 $t$ 是一个字符串 $s$ 的子串，当且仅当 $\delta_s(start_s,t)\neq null$。</p><p>因为，若 $t$ 是 $s$ 的子串，则在 $t$ 之后添加字符可能成为 $s$ 的一个后缀，反之不可能。</p><h2 id="一个朴素的SAM"><a href="#一个朴素的SAM" class="headerlink" title="一个朴素的SAM"></a>一个朴素的SAM</h2><p>若我们将一个字符串的所有后缀插入到一个字典树（trie树）中，并将每次插入的终止节点标记为接受状态，就可以得到一个状态数为 $O(n^2)​$ 的SAM。</p><p>如，串 $abaaabaa$ 的一个<strong>朴素SAM</strong>：</p><img src="/后缀自动机（SAM）学习笔记/triesam.png"><h1 id="最简SAM"><a href="#最简SAM" class="headerlink" title="最简SAM"></a>最简SAM</h1><p>上文中的“朴素SAM”状态数是 $O(n^2)$ 的，而<strong>最简SAM</strong>的状态数和转移数（点数和边数）都是 $O(n)$ 的。</p><h2 id="right-集合"><a href="#right-集合" class="headerlink" title="$right$ 集合"></a>$right$ 集合</h2><p>对于一个字符串 $t$，若它在 $s$ 中出现的位置集合为：$\{[l_1,r_1),[l_2,r_2),\cdots,[l_n,r_n)\}$（下标从 $0$ 开始），那么定义 $right(t)$ 为 $\{r_1,r_2,\cdots,r_n\}$。</p><p>如，又是串 $abaaabaa​$，那么 $right(a)=\{1,3,4,5,7,8\}​$，$right(aa)=\{4,5,8\}​$，$right(aab)=\{6\}​$。</p><p>在有的教程中，也称其为 $endpos$ 集合。</p><h2 id="right-集合等价类"><a href="#right-集合等价类" class="headerlink" title="$right$ 集合等价类"></a>$right$ 集合等价类</h2><h3 id="right-集合等价类的定义"><a href="#right-集合等价类的定义" class="headerlink" title="$right$ 集合等价类的定义"></a>$right$ 集合等价类的定义</h3><p>$right$ 集合相等的字符串组成一个 <strong>$right$ 集合等价类</strong>。</p><p>如，双是串 $abaaabaa$，那么 $right$ 集合为 $\{4,8\}$ 的字符串有 $\{abaa,baa\}$，这两个字符串组成一个 $right$ 集合等价类。</p><h3 id="right-集合等价类与最简SAM"><a href="#right-集合等价类与最简SAM" class="headerlink" title="$right$ 集合等价类与最简SAM"></a>$right$ 集合等价类与最简SAM</h3><p>我们定义 $reg(v)$ 表示<strong>从状态 $v$ 开始能识别的字符串的集合</strong>。即：$t\in reg(v)$ 当且仅当 $\delta(v,t)\in F$（$F$ 为接受状态集合）。</p><p>如果在 $t$ 的后面补上一个字符串 $s[r_i..n]$（$r_i\in right(t)$，$n$ 表示 $s$ 的长度），就得到了 $s$ 的一个后缀。所以，若 $right(t_1)=right(t_2)$，那么 $reg(SAM(t_1))=reg(SAM(t_2))=\{s[r_i..n]|r_i\in right(t_1)\}$。</p><p>对于每个状态 $v$，我们只关心 $reg(v)$，所以可以用SAM上的每一个状态去表示一个 $right$ 集合等价类，转移函数也相应地更改为对应的等价类（令 $f(v)$ 表示原状态 $v$ 对应的字符串的 $right$ 集合等价类在最简SAM中对应的状态，那么原来的转移函数 $\delta(u,c)=v$ 更改为 $\delta’(f(u),c)=f(v)$。可以证明，若 $right(u_1)=right(u_2)$，那么 $right(\delta(u_1,c))=right(\delta(u_2,c))$，因为 $right(\delta(u,c))=\{r_i|r_i\in right(u),s[r_i]=c\}$）。</p><p>这样的SAM是状态数最少的，因为状态的 $reg​$ 两两不同。这样的SAM若要和朴素SAM区分，可以叫做<strong>最简SAM</strong>。但一般不加说明的SAM都指最简SAM。</p><p>这样的SAM，从起始状态到某个状态可能有多条路径，每条路径都对应一个字符串，那么我们称这个状态<strong>对应</strong>着这些字符串。</p><p>如，叒是串 $abaaabaa​$ 的最简SAM：</p><img src="/后缀自动机（SAM）学习笔记/minsam.png"><h3 id="right-集合等价类的性质"><a href="#right-集合等价类的性质" class="headerlink" title="$right$ 集合等价类的性质"></a>$right$ 集合等价类的性质</h3><p>对于每个状态 $v$，定义 $max(v)$ 和 $min(v)$ 分别表示<strong>这个状态对应的 最长 和 最短 的字符串</strong>。</p><p>那么，<strong>$v$ 对应的任意一个字符串都是 $max(v)$ 的后缀，且不是 $min(v)$ 的真后缀。并且，$v​$ 包含了所有这样的字符串。</strong></p><p>第一点（$v$ 中的任意一个字符串都是 $max(v)$ 的后缀）可以由 $right$ 集合的定义得到。</p><p>第二点（且不是 $min(v)$ 的真后缀）可以由 $min(v)$ 的定义得到。</p><p>第三点（$v$ 包含了所有这样的字符串）可以由一个引理证明：<strong>对于一个字符串 $t$ ，它的 $right$ 集合是它的任意一个后缀的 $right$ 集合的子集。</strong>这个引理很好证明，进而可以证明这条性质。</p><p>如，叕是串 $abaaabaa$，$right$ 集合为 $\{6\}$ 的串有 $\{aab,aaab,baaab,abaaab\}$，若这个 $right$ 集合等价类对应状态 $v$，那么 $max(v)=abaaab$，$min(v)=aab$。</p><p>这条性质说明 $aaab$ 和 $baaab$ 都属于这个 $right$ 集合等价类，且 $ab$ 和 $b$ 不属于这个 $right$ 集合等价类。</p><p>证明第三点所用的引理说明，$right(aaab)\subseteq right(aab)\subseteq right(ab)\subseteq right(b)$，也就是 $\{6\}\subseteq\{6\}\subseteq\{2,6\}\subseteq\{2,6\}$ 。</p><h2 id="parent"><a href="#parent" class="headerlink" title="$parent$"></a>$parent$</h2><h3 id="parent-的定义"><a href="#parent-的定义" class="headerlink" title="$parent$ 的定义"></a>$parent$ 的定义</h3><p>$parent​$ 有两种等价的定义（你也可以把其一视作定义，另一个视作性质）：</p><h4 id="定义一"><a href="#定义一" class="headerlink" title="定义一"></a>定义一</h4><p>对于每个状态 $v$（除了起始状态），找到最长的一个字符串 $t$ 所对应的状态，使得 $right(v)\subsetneq right(t)$（注意是真子集；如果不存在这样的字符串就找起始状态），这样的状态就是 $parent(v)​$。</p><h4 id="定义二"><a href="#定义二" class="headerlink" title="定义二"></a>定义二</h4><p>对于每个状态 $v$（除了起始状态），$min(v)[1..n-1]$ 对应的状态（$n$ 表示 $min(v)$ 的长度，假定空串对应起始状态）就是 $parent(v)$。</p><p>有的教程中把 $parent$ 叫做后缀连接 $link$。</p><h3 id="parent-的性质"><a href="#parent-的性质" class="headerlink" title="$parent$ 的性质"></a>$parent$ 的性质</h3><p>$len(min(v))=len(max(parent(v)))+1$，这个可以由定义二说明。</p><h3 id="parent-树"><a href="#parent-树" class="headerlink" title="$parent$ 树"></a>$parent$ 树</h3><p>$parent​$ 连接可以构成一棵树。</p><p>由定义一，由 $right$ 集合要么包含要么不相交可以说明。$parent$ 树可以看成 $right​$ 集合的包含关系所构成的树。</p><p>由定义一或定义二，由除起始状态外的状态都有且仅有一条出边并且 $parent$ 连接无环（$right$ 集合大小递增/对应字符串长度递减）可以说明。</p><p>如，醊是串 $abaaabaa$，它的 $parent$ 树：（用 $max(v)$ 代表每个状态）</p><img src="/后缀自动机（SAM）学习笔记/parent.png"><p>SAM上的接受状态就是包含 $r_i=n$（字符串长度）的一些 $right$ 集合等价类，也就是 $parent$ 树上 $\{n\}$ 对应的状态及其祖先。因此，可以通过 $parent$ 树确定SAM的接受状态集合。</p><h2 id="最简SAM状态数为线性的证明"><a href="#最简SAM状态数为线性的证明" class="headerlink" title="最简SAM状态数为线性的证明"></a>最简SAM状态数为线性的证明</h2><p>其实由后面的线性构造方法可以说明状态数为线性。</p><p>只不过由SAM本身的性质也可以说明。</p><p>考虑 $parent​$ 树，最多有 $n​$ 个叶子节点，而每个非叶子节点至少有两个儿子，类似线段树/堆的节点数，可以证明总节点数不超过 $2n-1​$。</p><h2 id="最简SAM转移数为线性的证明"><a href="#最简SAM转移数为线性的证明" class="headerlink" title="最简SAM转移数为线性的证明"></a>最简SAM转移数为线性的证明</h2><p>考虑SAM的任意一个生成树，那么SAM上的边就会被分成树边和非树边。</p><p>树边最多只有 $2n-2​$ 条。</p><p>对于字符串的每个后缀，将其输入到SAM中都会经过一条终点为接受状态的路径，若经过了一条非树边，则称该后缀对应它经过的<strong>第一条</strong>非树边。</p><p>对于每条非树边 $(a,b)​$，一定存在一条从起始状态到 $a​$ 的不经过任何非树边的路径（因为树上两点间必定有路径），也一定存在一条从 $b​$ 到任意一个接受状态的路径（否则 $b=null​$），所以，至少有一个后缀对应着这条非树边。</p><p>因此，非树边数量不会超过后缀数量。总的边数就是 $O(n)​$ 的。</p><h2 id="最简SAM的线性构造"><a href="#最简SAM的线性构造" class="headerlink" title="最简SAM的线性构造"></a>最简SAM的线性构造</h2><p>SAM的线性构造可以在均摊 $O(1)$ 的时间复杂度内向SAM增加一个字符（从 $SAM_{s[0..i-1]}$ 变成 $SAM_{s[0..i]}$）。</p><p>向SAM增加一个字符，就是在所有接受状态后增加一个字符。所以，我们需要考虑上一次插入时的最后一个状态（$last​$）以及它在 ​$parent​$ 树上的祖先（也就是所有接受状态）。</p><p>加入一个字符 $x​$ 时，我们先创建一个新状态 $np​$，这个状态刚插入时代表 $right​$ 集合 $\{i\}​$（$i​$ 表示这是插入的第 $i​$ 个字符）。</p><p>一个引理：<strong>若一个状态有字符 $c$ 的转移，则它在 $parent$ 树上的祖先都有。</strong></p><p>引理的证明：$right(\delta(v,c))=\{r_i|r_i\in right(v),s[r_i]=c\}$，而 $right(v)\subsetneq right(parent(v))$。</p><p>因此，找到 $last​$ 最深的有出边 $x​$ 的祖先 $p​$ 后，在其之上的祖先都有出边 $x​$。</p><p>对于在其之下的状态，直接向 $np​$ 连边即可。</p><p>接下来要分三种情况讨论：</p><p>若不存在 $p​$（起始状态都没有出边 $x​$），则将 $parent(np)​$ 设为初始状态。</p><p>否则，令 $len(v)$ 表示 $max(v)$ 的长度，$q$ 表示 $\delta(p,x)$。</p><p>若 $len(q)=len(p)+1$，将 $parent(np)$ 设为 $q$ 即可。</p><p>否则，新建状态 $nq$，$len(nq)$ 设为（实际上不是人为设定，它本来就是）$len(p)+1$，将 $q$ 的转移函数复制到 $nq$，然后将 $parent(nq)$ 设为 $parent(q)$，再将 $parent(q)$ 和 $parent(np)$ 都设为 $nq$，最后把 $p$ 及 $p$ 的祖先中所有出边 $x$ 连到 $q$ 的都改为连到 $nq$。实际上，枚举祖先时只要遇到出边 $x$ 不连到 $q$ 的就可以停止枚举了。</p><p>至于为什么这样做..恕我表达能力有限，还请参考<a href="https://max.book118.com/html/2017/0523/108664184.shtm" target="_blank" rel="noopener">陈立杰WC课件</a>第 $35$ 页。</p><p>可以看出，当整个字符串的SAM构建好时，插入每个字符时只会进行常数次 $parent$ 修改，剩下的操作都是新建状态/连边，所以总复杂度和状态数、转移数一样，都是 $O(n)$。然而，如果字符集较大，空间开不下，就要用 $map$ 存边（因为要支持快速查询是否存在一条边，无法使用邻接表），复杂度就会带上 $\log|\Sigma|$。</p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> len,par,ch[<span class="number">26</span>];</span><br><span class="line">&#125; sam[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> p,tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line"></span><br><span class="line">    sam[<span class="number">0</span>].par=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;s[i];++i) insert(s[i]-<span class="string">'0'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> np=++tot;</span><br><span class="line">    sam[np].len=sam[p].len+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (~p&amp;&amp;!sam[p].ch[x])</span><br><span class="line">    &#123;</span><br><span class="line">        sam[p].ch[x]=np;</span><br><span class="line">        p=sam[p].par;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p==<span class="number">-1</span>) sam[np].par=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> q=sam[p].ch[x];</span><br><span class="line">        <span class="keyword">if</span> (sam[q].len==sam[p].len+<span class="number">1</span>) sam[np].par=q;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> nq=++tot;</span><br><span class="line">            sam[nq].len=sam[p].len+<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">memcpy</span>(sam[nq].ch,sam[q].ch,<span class="keyword">sizeof</span>(sam[q].ch));</span><br><span class="line">            sam[nq].par=sam[q].par;</span><br><span class="line">            sam[q].par=sam[np].par=nq;</span><br><span class="line">            <span class="keyword">while</span> (~p&amp;&amp;sam[p].ch[x]==q)</span><br><span class="line">            &#123;</span><br><span class="line">                sam[p].ch[x]=nq;</span><br><span class="line">                p=sam[p].par;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    p=np;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="SAM的一些应用"><a href="#SAM的一些应用" class="headerlink" title="SAM的一些应用"></a>SAM的一些应用</h1><p>一些应用我还没有写过..写过之后可能会补（gu）上（gu）来（gu）。可以参考<a href="https://oi-wiki.org/string/sam/#_13" target="_blank" rel="noopener">OI wiki</a>。</p><h2 id="判断子串-后缀"><a href="#判断子串-后缀" class="headerlink" title="判断子串/后缀"></a>判断子串/后缀</h2><p>根据SAM的定义和性质，建出文本串的SAM，将模式串分别输入SAM，若转移到 $null$ 则不是子串，否则是；若转移到接受状态则是后缀，否则不是。</p><h2 id="读入字符串时删除首字符"><a href="#读入字符串时删除首字符" class="headerlink" title="读入字符串时删除首字符"></a>读入字符串时删除首字符</h2><p>记录一下已读入的字符串长度，若小于等于当前状态的 $parent.len$，就转移到 $parent$。</p><p>例题：<a href="http://codeforces.com/problemset/problem/235/C" target="_blank" rel="noopener">CF235C Cyclical Quest</a></p><h2 id="子串出现次数"><a href="#子串出现次数" class="headerlink" title="子串出现次数"></a>子串出现次数</h2><p>一个子串出现次数就是其对应 $right$ 集合的元素个数。</p><p>在创建 $np$ 时，将其 $cnt$ 赋为 $1$，建好SAM后，每个状态的出现次数就是 $parent$ 子树内的 $cnt$ 之和。</p><p>例题：<a href="https://www.luogu.org/problemnew/show/P3804" target="_blank" rel="noopener">【模板】后缀自动机</a></p><h2 id="子串第一次出现位置"><a href="#子串第一次出现位置" class="headerlink" title="子串第一次出现位置"></a>子串第一次出现位置</h2><p>和子串出现次数差不多，创建 $np​$ 时，将 $firstpos(np)​$ 设为 $len(np)-1​$，复制 $nq​$ 时，将 $firstpos(nq)​$ 设为 $firstpos(q)​$，最后对子树内取 $min​$。</p><h2 id="本质不同子串数"><a href="#本质不同子串数" class="headerlink" title="本质不同子串数"></a>本质不同子串数</h2><p>每个状态表示 $maxlen-minlen+1$ 个字符串，而 $minlen=len(parent)+1$，所以一个状态表示的字符串数量就是 $len-parent.len$。求和即可。</p><p>例题：<a href="https://www.luogu.org/problemnew/show/P4070" target="_blank" rel="noopener">[SDOI2016]生成魔咒</a></p><h2 id="第-k-大子串"><a href="#第-k-大子串" class="headerlink" title="第 $k$ 大子串"></a>第 $k$ 大子串</h2><p>预处理每个状态可以转移到多少个不同的子串，然后就可以做了。</p><p>例题：</p><p><a href="https://www.luogu.org/problemnew/show/SP7258" target="_blank" rel="noopener">SP7258 SUBLEX</a></p><p><a href="https://www.luogu.org/problemnew/show/P3975" target="_blank" rel="noopener">[TJOI2015]弦论</a></p><h2 id="两串的最长公共子串"><a href="#两串的最长公共子串" class="headerlink" title="两串的最长公共子串"></a>两串的最长公共子串</h2><p>对其中一个串建SAM，从起始状态开始，读入另一个字符串，若有转移则转移，将已匹配长度 $+1$，否则跳到 $parent$（这里和 $kmp$ 有点像），并将已匹配长度修改为 $len(parent)​$。过程中最大的已匹配长度就是答案。</p><p>例题：<a href="https://www.luogu.org/problemnew/show/SP1811" target="_blank" rel="noopener">SP1811 LCS</a></p><h2 id="多串的最长公共子串"><a href="#多串的最长公共子串" class="headerlink" title="多串的最长公共子串"></a>多串的最长公共子串</h2><p>还是对其中一个串建SAM，以同样的方式依次读入每个字符串，只不过对每个状态要保存当前字符串的最大匹配长度，所有字符串在某个状态的最大匹配长度的最小值就是这一堆字符串在这个状态能匹配的最大长度。如果能在一个状态匹配，一定能在 $parent$ 处匹配，所以要对子树取 $max$，但也不要忘了对 $len$ 取 $min$。</p><p>例题：</p><p><a href="https://www.luogu.org/problemnew/show/SP1812" target="_blank" rel="noopener">SP1812 LCS2</a></p><p><a href="https://www.luogu.org/problemnew/show/P2463" target="_blank" rel="noopener">[SDOI2008]Sandy的卡片</a></p><h1 id="任意DFA的压缩"><a href="#任意DFA的压缩" class="headerlink" title="任意DFA的压缩"></a>任意DFA的压缩</h1><p>这部分估计没人感兴趣..OI里没用，也不是证明SAM最小性必需的（最小性的证明我在前文中已经简略说明了：状态的 $reg$ 两两不同）。只不过或许会对理解SAM本质以及发明它的人怎么想到的有些帮助…</p><p>或许这种方式在很多年前就已经被人提出了..总之这部分内容完全是我自己yy的，我也懒得去查有没有人发明过。</p><p>这部分内容不保证正确性，如果有误欢迎指正。如果有人愿意提供严谨证明（怎么可能有人啊..只不过我这里都懒得严谨证明了，随便口头地说了一下）一定非常感谢。</p><h2 id="“DFA的压缩”的定义"><a href="#“DFA的压缩”的定义" class="headerlink" title="“DFA的压缩”的定义"></a>“DFA的压缩”的定义</h2><p>一个可用于压缩DFA的映射 $f:Q_A\rightarrow Q_B$ 需要满足以下几个条件：</p><ol><li>$\forall v\ne start_A,f(v)\ne f(start_A)​$</li><li>$\forall u\in F,v\notin F,f(u)\ne f(v)​$</li><li>$\forall f(u)=f(v),c\in\Sigma,f(\delta_A(u,c))=f(\delta_A(v,c))$</li></ol><p>如：在SAM中，把所有 $right$ 集合相同的状态映射到同一状态就是一个符合条件的映射。</p><p>定义DFA $A$ 在映射 $f$ 下的压缩为 $B$，其中：</p><ol><li>$\Sigma_B=\Sigma_A$</li><li>$Q_B=f(Q_A)$</li><li>$start_B=f(start_A)$</li><li>$F_B=f(F_A)​$</li><li>$\delta_B(f(v),c)=f(\delta_A(v,c))$，这一定义依赖于 $f$ 的性质 $3​$。</li></ol><p>如：用 $right$ 集合等价类这个映射可以将朴素SAM压缩成最简SAM。</p><h2 id="压缩后的自动机与原自动机等价的证明"><a href="#压缩后的自动机与原自动机等价的证明" class="headerlink" title="压缩后的自动机与原自动机等价的证明"></a>压缩后的自动机与原自动机等价的证明</h2><p>我们证明一个比 $A(s)=B(s)$ 更强的命题：$[\delta_A(v,s)\in F_A]=[\delta_B(f(v),s)\in F_B]$。</p><p>当 $s$ 只有一个字符时，根据 $f$ 满足的性质 $2$ 以及 $B$ 的定义 $4,5$，命题显然成立。</p><p>当 $s$ 不止一个字符时，可以归纳地说明命题成立。</p><h2 id="DFA的最简压缩方法"><a href="#DFA的最简压缩方法" class="headerlink" title="DFA的最简压缩方法"></a>DFA的最简压缩方法</h2><p> 这里给出一个将任意DFA压缩至最简的方法：</p><p>由于DFA是一个DAG，它的任意生成子图都必定有出度为 $0$ 的点。每次找到这些点，然后从中选取尽量多的点，使其映射到同一个状态后满足 $f$ 需要满足的三条性质（也就是，同一字符转移到的状态映射到的状态相同，且没有一个是接受状态另一个不是的情况），然后将这些点从图中删去，重复直至所有点都有了映射后的状态（所有点都被删去）。这样得到的映射 $f​$ 能够将原DFA压缩至最简。</p><h2 id="压缩至最简的证明"><a href="#压缩至最简的证明" class="headerlink" title="压缩至最简的证明"></a>压缩至最简的证明</h2><p>我们先证明每个状态的 $reg$（定义参见上文，表示从一个状态起能识别的字符串集合）两两不等。我们按照拓扑序归纳地证明。</p><p>没有出边的非接受状态可以视作 $null$，而没有出边的接受状态按上文所述方法必定会被映射至同一状态。所以命题对没有出边的状态成立。</p><p>假设一个状态所有出边的对应状态都已被证明，那么转移函数不同就等价于 $reg$ 不同，所以命题成立。</p><p>接着，我们由 $reg$ 两两不同证明压缩至最简：</p><p>若状态数继续减少，那么必然存在原来 $reg$ 不同的两个状态 $B(s_1)$ 和 $B(s_2)$ 被压缩到了一起，任取一个只在 $reg(B(s_1))$ 或只在 $reg(B(s_2))$ 中的字符串 $t$，原来 $B(s_1+t)\ne B(s_2+t)$，压缩后却使得 $B’(s_1+t)=B’(s_2+t)$，不符合要求。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;后缀自动机是一种处理字符串问题的有力工具（废话），它的码量不比后缀数组大（实际代码难度不比后缀数组小，但也不难），处理问题时的思维难度往往比后缀数组小，复杂度更优秀。若字符集大小为 $|\Sigma|$，则：构建时间复杂度 $O(n|\Sigma|)$，转移时间复杂度 $O(1)$，空间复杂度 $O(n|\Sigma|)$ 或 构建时间复杂度 $O(n\log|\Sigma|)$，转移时间复杂度 $O(\log|\Sigma|)$，空间复杂度 $O(n)$。&lt;/p&gt;
&lt;p&gt;&lt;del&gt;这篇文章会按我的理解详细地介绍一下 SAM，是否比其它教程更好懂我就不做评论了（毕竟所有人都认为自己的教程最好懂），只不过我会尽量保证教程的严谨性和正确性，同时尽量简洁（简洁地表达所有内容，而不是有选择地删去内容）。&lt;/del&gt;这篇写的比较口胡随意..拉低了我写的教程的平均水平..只不过还是比市面上某些博客要强一些的（吧）。&lt;/p&gt;
&lt;p&gt;这篇文章最大的特点..大约是讲了一些关于将自动机的状态数压缩至最少的方法。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://ouuan.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="字符串" scheme="https://ouuan.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="SAM" scheme="https://ouuan.github.io/tags/SAM/"/>
    
  </entry>
  
  <entry>
    <title>P3804 【模板】后缀自动机（SAM/后缀数组）</title>
    <link href="https://ouuan.github.io/P3804-%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    <id>https://ouuan.github.io/P3804-【模板】后缀自动机/</id>
    <published>2019-02-21T07:47:52.000Z</published>
    <updated>2019-04-03T00:01:52.645Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.luogu.org/problemnew/show/P3804" target="_blank" rel="noopener">洛谷</a></p><h1 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h1><p>求 <strong>出现次数不为 $1$ 的子串的 出现次数 $\times$ 长度</strong> 的最大值。</p><a id="more"></a><h1 id="SAM-做法"><a href="#SAM-做法" class="headerlink" title="SAM 做法"></a>SAM 做法</h1><h2 id="简要做法"><a href="#简要做法" class="headerlink" title="简要做法"></a>简要做法</h2><p>一个状态的出现次数可以这么计算：</p><p>插入一个字符时，$np$ 的 $cnt$ 设为 $1$，一个状态的出现次数就是它在 $parent$ 树上的子树的 $cnt$ 之和。</p><p>证明..简要说一下：因为 $np$ 的 $right$ 集合为 $\{L\}$ 。</p><p>所以，插入整个字符串后 dfs 一遍 $parent$ 树算一算就好了。</p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> DELTA=<span class="number">26</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> len,ch[DELTA],par,cnt;</span><br><span class="line">    Node()&#123; <span class="built_in">memset</span>(ch,<span class="number">0</span>,<span class="keyword">sizeof</span>(ch)); &#125;</span><br><span class="line">&#125; sam[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> p,tot,head[N&lt;&lt;<span class="number">1</span>],nxt[N&lt;&lt;<span class="number">1</span>],to[N&lt;&lt;<span class="number">1</span>],cnt;</span><br><span class="line">ll ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;s[i];++i) insert(s[i]-<span class="string">'a'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=tot;++i) add(sam[i].par,i);</span><br><span class="line"></span><br><span class="line">    dfs(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> np=++tot;</span><br><span class="line">    sam[np].len=sam[p].len+<span class="number">1</span>;</span><br><span class="line">    sam[np].cnt=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p&amp;&amp;!sam[p].ch[x])</span><br><span class="line">    &#123;</span><br><span class="line">        sam[p].ch[x]=np;</span><br><span class="line">        p=sam[p].par;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sam[p].ch[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> q=sam[p].ch[x];</span><br><span class="line">        <span class="keyword">if</span> (sam[q].len==sam[p].len+<span class="number">1</span>) sam[np].par=q;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> nq=++tot;</span><br><span class="line">            sam[nq].len=sam[p].len+<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">memcpy</span>(sam[nq].ch,sam[q].ch,<span class="keyword">sizeof</span>(sam[q].ch));</span><br><span class="line">            sam[nq].par=sam[q].par;</span><br><span class="line">            sam[q].par=sam[np].par=nq;</span><br><span class="line">            <span class="keyword">while</span> (sam[p].ch[x]==q)</span><br><span class="line">            &#123;</span><br><span class="line">                sam[p].ch[x]=nq;</span><br><span class="line">                p=sam[p].par;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        sam[p].ch[x]=np;</span><br><span class="line">        sam[np].par=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    p=np;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    nxt[++cnt]=head[u];</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">    to[cnt]=v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,v;</span><br><span class="line">    <span class="keyword">for</span> (i=head[u];i;i=nxt[i])</span><br><span class="line">    &#123;</span><br><span class="line">        v=to[i];</span><br><span class="line">        dfs(v);</span><br><span class="line">        sam[u].cnt+=sam[v].cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sam[u].cnt&gt;<span class="number">1</span>) ans=max(ans,(ll)sam[u].cnt*sam[u].len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="后缀数组做法"><a href="#后缀数组做法" class="headerlink" title="后缀数组做法"></a>后缀数组做法</h1><h2 id="简要做法-1"><a href="#简要做法-1" class="headerlink" title="简要做法"></a>简要做法</h2><p>一个长度为 $h$ 的子串出现 $k$ 次就是有 $k-1$ 个连续的 $height\ge h$。单调栈维护即可。</p><p>然而..卡常卡不过去QAQ</p><h2 id="参考代码（最高80分）"><a href="#参考代码（最高80分）" class="headerlink" title="参考代码（最高80分）"></a>参考代码（最高80分）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> n,sa[N],rk[N&lt;&lt;<span class="number">1</span>],id[N&lt;&lt;<span class="number">1</span>],px[N],cnt[N],ht[N],l[N],sta[N],top;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> w)</span></span>&#123; <span class="keyword">return</span> id[x]==id[y]&amp;&amp;id[x+w]==id[y+w]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,w,p,m=<span class="number">300</span>,k;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s+<span class="number">1</span>);</span><br><span class="line">    n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;++i) ++cnt[rk[i]=s[i]];</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;++i) cnt[i]+=cnt[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span> (i=n;i&gt;=<span class="number">1</span>;--i) sa[cnt[rk[i]]--]=i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (w=<span class="number">1</span>;w&lt;n;w&lt;&lt;=<span class="number">1</span>,m=p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span>(cnt));</span><br><span class="line">        <span class="keyword">for</span> (p=<span class="number">0</span>,i=n;i&gt;n-w;--i) id[++p]=i;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">if</span> (sa[i]&gt;w) id[++p]=sa[i]-w;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;++i) ++cnt[px[i]=rk[id[i]]];</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;++i) cnt[i]+=cnt[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span> (i=n;i&gt;=<span class="number">1</span>;--i) sa[cnt[px[i]]--]=id[i];</span><br><span class="line">        swap(id,rk);</span><br><span class="line">        <span class="keyword">for</span> (p=<span class="number">0</span>,i=<span class="number">1</span>;i&lt;=n;++i) rk[sa[i]]=cmp(sa[i],sa[i<span class="number">-1</span>],w)?p:++p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>,k=<span class="number">0</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k) --k;</span><br><span class="line">        <span class="keyword">while</span> (s[i+k]==s[sa[rk[i]<span class="number">-1</span>]+k]) ++k;</span><br><span class="line">        ht[rk[i]]=k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (top&amp;&amp;ht[sta[top]]&gt;=ht[i]) --top;</span><br><span class="line">        l[i]=sta[top];</span><br><span class="line">        sta[++top]=i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sta[top=<span class="number">1</span>]=n+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=n;i&gt;=<span class="number">1</span>;--i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (top&amp;&amp;ht[sta[top]]&gt;ht[i]) --top;</span><br><span class="line">        <span class="keyword">if</span> (sta[top]-l[i]&gt;<span class="number">1</span>) ans=max(ans,(<span class="keyword">long</span> <span class="keyword">long</span>)ht[i]*(sta[top]-l[i]));</span><br><span class="line">        sta[++top]=i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/P3804&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;洛谷&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;题意简述&quot;&gt;&lt;a href=&quot;#题意简述&quot; class=&quot;headerlink&quot; title=&quot;题意简述&quot;&gt;&lt;/a&gt;题意简述&lt;/h1&gt;&lt;p&gt;求 &lt;strong&gt;出现次数不为 $1$ 的子串的 出现次数 $\times$ 长度&lt;/strong&gt; 的最大值。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://ouuan.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="字符串" scheme="https://ouuan.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="后缀数组" scheme="https://ouuan.github.io/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"/>
    
      <category term="SAM" scheme="https://ouuan.github.io/tags/SAM/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ4516 [SDOI2016]生成魔咒（SAM）</title>
    <link href="https://ouuan.github.io/BZOJ4516-SDOI2016-%E7%94%9F%E6%88%90%E9%AD%94%E5%92%92%EF%BC%88SAM%EF%BC%89/"/>
    <id>https://ouuan.github.io/BZOJ4516-SDOI2016-生成魔咒（SAM）/</id>
    <published>2019-02-21T06:10:35.000Z</published>
    <updated>2019-04-02T23:56:16.529Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.luogu.org/problemnew/show/P4070" target="_blank" rel="noopener">洛谷</a></p><p><a href="https://darkbzoj.cf/problem/4516" target="_blank" rel="noopener">dark bzoj</a></p><h1 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h1><p>给你一个字符串（字符集大小 $10^9$，长度 $10^5$），求每个前缀的本质不同子串数。</p><a id="more"></a><h1 id="简要做法"><a href="#简要做法" class="headerlink" title="简要做法"></a>简要做法</h1><p>如果只求整个串的本质不同子串，由于每个本质不同子串可以与 SAM 上一个状态+串的长度一一对应，所以本质不同子串数就是每个状态的 $maxlen-minlen+1$，也就是 $len-parent.len$。</p><p>$parent$ 不改变时，逐个加入字符并计算即可。</p><p>考虑 $parent$ 改变的情况，四次 $parent$ 改变分别为 $nq-q.parent$，$-(q-q.parent)$，$q-nq$，$np-nq$。总贡献为 $nq-q.parent-q+q.parent+q-nq+np-nq=np-nq$，也是新加入的点的 $len$ 减去 $parent.len$，是一样的。</p><p>由于字符集较大，用 <code>map</code> 存边。</p><h1 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> out=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c=getchar()));</span><br><span class="line">    <span class="keyword">for</span> (;<span class="built_in">isdigit</span>(c);c=getchar()) out=out*<span class="number">10</span>+c-<span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> len,par;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; ch;</span><br><span class="line">&#125; sam[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,p,tot;</span><br><span class="line">ll ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    n=read();</span><br><span class="line"></span><br><span class="line">    sam[<span class="number">0</span>].par=<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        insert(read());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> np=++tot;</span><br><span class="line">    sam[np].len=sam[p].len+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (~p&amp;&amp;sam[p].ch.find(x)==sam[p].ch.end())</span><br><span class="line">    &#123;</span><br><span class="line">        sam[p].ch[x]=np;</span><br><span class="line">        p=sam[p].par;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p==<span class="number">-1</span>) sam[np].par=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> q=sam[p].ch[x];</span><br><span class="line">        <span class="keyword">if</span> (sam[q].len==sam[p].len+<span class="number">1</span>) sam[np].par=q;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> nq=++tot;</span><br><span class="line">            sam[nq].len=sam[p].len+<span class="number">1</span>;</span><br><span class="line">            sam[nq].ch=sam[q].ch;</span><br><span class="line">            sam[nq].par=sam[q].par;</span><br><span class="line">            sam[q].par=sam[np].par=nq;</span><br><span class="line">            <span class="keyword">while</span> (~p&amp;&amp;sam[p].ch[x]==q)</span><br><span class="line">            &#123;</span><br><span class="line">                sam[p].ch[x]=nq;</span><br><span class="line">                p=sam[p].par;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans+=sam[np].len-sam[sam[np].par].len;</span><br><span class="line">    p=np;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/P4070&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;洛谷&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://darkbzoj.cf/problem/4516&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;dark bzoj&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;题意简述&quot;&gt;&lt;a href=&quot;#题意简述&quot; class=&quot;headerlink&quot; title=&quot;题意简述&quot;&gt;&lt;/a&gt;题意简述&lt;/h1&gt;&lt;p&gt;给你一个字符串（字符集大小 $10^9$，长度 $10^5$），求每个前缀的本质不同子串数。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://ouuan.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="字符串" scheme="https://ouuan.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="SAM" scheme="https://ouuan.github.io/tags/SAM/"/>
    
  </entry>
  
  <entry>
    <title>后缀数组学习笔记</title>
    <link href="https://ouuan.github.io/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://ouuan.github.io/后缀数组学习笔记/</id>
    <published>2019-02-17T05:53:54.000Z</published>
    <updated>2019-04-03T00:04:35.977Z</updated>
    
    <content type="html"><![CDATA[<p>后缀数组是一种处理字符串问题的有力工具（废话），本文的主要特点是一步步地由最朴素的后缀数组构建方法逐步优化，而非直接给出最终优化后的代码。</p><p>希望这篇文章能让更多的人看懂后缀数组的代码，学会后缀数组。</p><a id="more"></a><h1 id="模板题链接"><a href="#模板题链接" class="headerlink" title="模板题链接"></a>模板题链接</h1><p><a href="https://www.luogu.org/problemnew/show/P3809" target="_blank" rel="noopener">洛谷</a>（只用求 $sa$）</p><p><a href="https://loj.ac/problem/111" target="_blank" rel="noopener">LOJ</a>（只用求 $sa$）</p><p><a href="http://uoj.ac/problem/35" target="_blank" rel="noopener">UOJ</a>（求 $sa$ 和 $height$）</p><p><a href="https://duck.ac/problem/1006" target="_blank" rel="noopener">评测鸭</a>（求 $sa$ 和 $height$）</p><h1 id="两（can）篇（kao）论（zi）文（liao）"><a href="#两（can）篇（kao）论（zi）文（liao）" class="headerlink" title="两（can）篇（kao）论（zi）文（liao）"></a>两（can）篇（kao）论（zi）文（liao）</h1><p>[1]：<a href="https://wenku.baidu.com/view/0dc03d2b1611cc7931b765ce0508763230127479.html" target="_blank" rel="noopener">[2004]后缀数组 by.徐智磊</a></p><p>[2]：<a href="https://wenku.baidu.com/view/5b886b1ea76e58fafab00374.html" target="_blank" rel="noopener">[2009]后缀数组——处理字符串的有力工具 by.罗穗骞</a></p><p>这两篇论文还是写的很好的，大家可以看看。</p><p>下文中如果有引用这两篇论文中的内容，将以上标形式标出（$^{[1]}$ $^{[2]}$）。</p><h1 id="关于字符串"><a href="#关于字符串" class="headerlink" title="关于字符串.."></a>关于字符串..</h1><p>说到字符串算法，就得先提一些定（fei）义（hua），知道的就可以不看了..</p><h2 id="字符集-1"><a href="#字符集-1" class="headerlink" title="字符集$^{[1]}$"></a>字符集$^{[1]}$</h2><p>一个字符集 $Σ$ 是一个建立了全序关系的集合，也就是说，$Σ$ 中的任意两个不同的元素 $α$ 和 $β$ 都可以比较大小，要么 $α&lt;β$，要么 $β&lt;α$（也就是$α&gt;β$）。字符集 $Σ$ 中的元素称为字符。</p><h2 id="字符串-1"><a href="#字符串-1" class="headerlink" title="字符串$^{[1]}$"></a>字符串$^{[1]}$</h2><p>一个字符串 $S$ 是将 $n$ 个字符顺次排列形成的数组，$n$ 称为 $S$ 的长度，表示为 $len(S)$。$S$ 的第 $i$ 个字符表示为 $S[i]$。</p><h2 id="子串-1"><a href="#子串-1" class="headerlink" title="子串$^{[1]}$"></a>子串$^{[1]}$</h2><p>字符串 $S$ 的子串 $S[i..j]，i≤j$，表示 S 串中从 $i$ 到 $j$ 这一段，也就是顺次排列 $S[i],S[i+1],…,S[j]$ 形成的字符串。</p><h2 id="后缀"><a href="#后缀" class="headerlink" title="后缀"></a>后缀</h2><p>后缀是指从某个位置 $i$ 开始到整个串末尾结束的一个特殊子串。字符串 $S$ 的从 $i$ 开头的后缀表示为 $Suffix(S,i)$，也就是 $Suffix(S,i)=S[i..len(S)]$。$^{[1]}$</p><p>下文中以 “后缀 $i$” 代指字符串从 $i$ 开头的后缀。$i$ 称作这个后缀的编号。</p><h2 id="字典序"><a href="#字典序" class="headerlink" title="字典序"></a>字典序</h2><p>以第 $i$ 个字符作为第 $i$ 关键字进行大小比较，空字符小于字符集内任何字符（即：$a&lt;aa$）。</p><h1 id="后缀数组是什么？"><a href="#后缀数组是什么？" class="headerlink" title="后缀数组是什么？"></a>后缀数组是什么？</h1><p>后缀数组主要是两个数组：$sa$ 和 $rk$。</p><p>其中，$sa[i]$ 表示将所有后缀排序后第 $i$ 小的后缀的编号。$rk[i]$ 表示后缀 $i$ 的排名。</p><p>这两个数组满足性质：$sa[rk[i]]=rk[sa[i]]=i$。</p><p>后缀数组示例：$^{[2]}$</p><img src="/后缀数组学习笔记/sark.png"><h1 id="后缀数组怎么求？"><a href="#后缀数组怎么求？" class="headerlink" title="后缀数组怎么求？"></a>后缀数组怎么求？</h1><h2 id="O-n-2-log-n-做法"><a href="#O-n-2-log-n-做法" class="headerlink" title="$O(n^2\log n)$ 做法"></a>$O(n^2\log n)$ 做法</h2><p>我相信这个做法大家还是能自己想到的..用string+sort就可以了。由于比较两个字符串是 $O(n)$ 的，所以排序是 $O(n^2\log n)$ 的。</p><h2 id="O-n-log-2n-做法"><a href="#O-n-log-2n-做法" class="headerlink" title="$O(n\log^2n)$ 做法"></a>$O(n\log^2n)$ 做法</h2><p>这个做法要用到倍增的思想。</p><p>先对每个长度为 $1$ 的子串（即每个字符）进行排序。</p><p>假设我们已经知道了长度为 $w$ 的子串的排名 $rk_w[1..n]$（即，$rk_w[i]$ 表示 $s[i..\min(i+w-1,n)]$ 在 $\{s[x..\min(x+w-1,n)] | x\in\mathbb{N}\bigcap[1,n]\}$ 中的排名），那么，以 $rk_w[i]$ 为第一关键字， $rk_w[i+w]$ 为第二关键字（若 $i+w&gt;n$ 则令 $rk_w[i+w]$ 为 $-INF$）进行排序，就可以求出 $rk_{2w}[1..n]$。</p><p>倍增排序示意图：$^{[2]}$</p><img src="/后缀数组学习笔记/bz.png"><p>如果用 <code>sort</code> 进行排序，复杂度就是 $O(n\log^2n)$ 的。</p><div><div class="fold_hider"><div class="close hider_title">参考代码</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> n,w,sa[N],rk[N&lt;&lt;<span class="number">1</span>],oldrk[N]; <span class="comment">//为了防止访问rk[i+w]导致数组越界，开两倍数组。当然也可以在访问前判断是否越界，但直接开两倍数组方便一些。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,p;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s+<span class="number">1</span>);</span><br><span class="line">    n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;++i) rk[i]=s[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (w=<span class="number">1</span>;w&lt;n;++w)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;++i) sa[i]=i;</span><br><span class="line">        sort(sa+<span class="number">1</span>,sa+n+<span class="number">1</span>,[](<span class="keyword">int</span> x,<span class="keyword">int</span> y)&#123;<span class="keyword">return</span> rk[x]==rk[y]?rk[x+w]&lt;rk[y+w]:rk[x]&lt;rk[y];&#125;); <span class="comment">//这里用到了lambda表达式</span></span><br><span class="line">        <span class="built_in">memcpy</span>(oldrk,rk,<span class="keyword">sizeof</span>(oldrk)); <span class="comment">//由于计算rk的时候原来的rk会被覆盖，要先复制一份</span></span><br><span class="line">        <span class="keyword">for</span> (p=<span class="number">0</span>,i=<span class="number">1</span>;i&lt;=n;++i) rk[sa[i]]=oldrk[sa[i]]==oldrk[sa[i<span class="number">-1</span>]]&amp;&amp;oldrk[sa[i]+w]==oldrk[sa[i<span class="number">-1</span>]+w]?p:++p; <span class="comment">//若两个子串相同，它们对应的rk也需要相同，所以要去重</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">printf</span>(<span class="string">"%d "</span>,sa[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h2 id="O-n-log-n-做法"><a href="#O-n-log-n-做法" class="headerlink" title="$O(n\log n)$ 做法"></a>$O(n\log n)$ 做法</h2><p>在刚刚的 $O(n\log^2n)$ 做法中，一次排序是 $O(n\log n)$ 的，如果能 $O(n)$ 排序，就能 $O(n\log n)$ 计算后缀数组了。</p><h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p>计数排序的核心思想还是比较好理解的，可以先看代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对a这个数组进行排序，结果存到数组b中（b[i]表示第i名的编号），cnt是一个辅助数组，m是a的值域</span></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;++i) ++cnt[a[i]];</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;++i) cnt[i]+=cnt[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span> (i=n;i&gt;=<span class="number">1</span>;--i) b[cnt[a[i]]--]=i;</span><br></pre></td></tr></table></figure><p>其实就是先数一数小于等于 $a[i]$ 的数有多少个，然后从后往前看每个数的名次。感性理解/手玩一下就能明白这个排序算法了。</p><p>这个算法有两个特点：</p><ol><li>它是 $O(n+m)$ 的（$m$ 为待排序数据的值域范围）。</li><li>它是一个稳定排序，即，相等的数会按原位置（下标）进行排序。</li></ol><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>值得一提的是很多人经常把计数排序和基数排序搞混..</p><p>基数排序是一个基于稳定排序的多关键字排序算法，复杂度为关键字个数乘上稳定排序的复杂度。而这个稳定排序通常用计数排序实现。</p><p>它的思想是，如果有 $k$ 个关键字，先以第 $k$ 关键字进行一次稳定排序，然后再以第 $k-1$ 关键字进行一次稳定排序，……，最后以第一关键字进行一次稳定排序。可以看出，这样做就完成了以这 $k$ 个关键字的排序。</p><p>具体实现大约是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//key[i][j]表示第j个数的第i关键字，b[i]依然表示第i名的编号，m是key的值域，cnt和id都是辅助数组</span></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;++i) id[i]=i;</span><br><span class="line"><span class="keyword">for</span> (i=k;i&gt;=<span class="number">1</span>;--i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span>(cnt));</span><br><span class="line">    <span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=n;++j) id[j]=b[j];</span><br><span class="line">    <span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=n;++j) ++cnt[key[i][id[j]]];</span><br><span class="line">    <span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=m;++j) cnt[j]+=cnt[j<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span> (j=n;j&gt;=<span class="number">1</span>;--j) b[cnt[key[i][id[j]]]--]=id[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="将基数排序运用于求后缀数组"><a href="#将基数排序运用于求后缀数组" class="headerlink" title="将基数排序运用于求后缀数组"></a>将基数排序运用于求后缀数组</h3><p>如果你学会了基数排序，也会 $O(n\log^2n)$ 求后缀数组，那你应该可以自己写出一个 $O(n\log n)$ 求后缀数组的程序了。</p><div><div class="fold_hider"><div class="close hider_title">参考代码</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> n,sa[N],rk[N&lt;&lt;<span class="number">1</span>],oldrk[N&lt;&lt;<span class="number">1</span>],id[N],cnt[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,m,p,w;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s+<span class="number">1</span>);</span><br><span class="line">    n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">    m=max(n,<span class="number">300</span>);</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;++i) ++cnt[rk[i]=s[i]];</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;++i) cnt[i]+=cnt[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span> (i=n;i&gt;=<span class="number">1</span>;--i) sa[cnt[rk[i]]--]=i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (w=<span class="number">1</span>;w&lt;n;w&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span>(cnt));</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;++i) id[i]=sa[i];</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;++i) ++cnt[rk[id[i]+w]];</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;++i) cnt[i]+=cnt[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span> (i=n;i&gt;=<span class="number">1</span>;--i) sa[cnt[rk[id[i]+w]]--]=id[i];</span><br><span class="line">        <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span>(cnt));</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;++i) id[i]=sa[i];</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;++i) ++cnt[rk[id[i]]];</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;++i) cnt[i]+=cnt[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span> (i=n;i&gt;=<span class="number">1</span>;--i) sa[cnt[rk[id[i]]]--]=id[i];</span><br><span class="line">        <span class="built_in">memcpy</span>(oldrk,rk,<span class="keyword">sizeof</span>(oldrk));</span><br><span class="line">        <span class="keyword">for</span> (p=<span class="number">0</span>,i=<span class="number">1</span>;i&lt;=n;++i) rk[sa[i]]=oldrk[sa[i]]==oldrk[sa[i<span class="number">-1</span>]]&amp;&amp;oldrk[sa[i]+w]==oldrk[sa[i<span class="number">-1</span>]+w]?p:++p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">printf</span>(<span class="string">"%d "</span>,sa[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="一些常数优化"><a href="#一些常数优化" class="headerlink" title="一些常数优化"></a>一些常数优化</h3><p>如果你把上面那份代码交到洛谷上..</p><img src="/后缀数组学习笔记/TLE.png"><p>怎么会这样呢？是这题卡常吗？</p><p>一翻其他人的代码，最慢点也不过 $1s$..</p><p>这是因为，上面那份代码的常数的确很大..</p><h4 id="第二关键字无需计数排序"><a href="#第二关键字无需计数排序" class="headerlink" title="第二关键字无需计数排序"></a>第二关键字无需计数排序</h4><p>实际上，像这样就可以了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (p=<span class="number">0</span>,i=n;i&gt;n-w;--i) id[++p]=i;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">if</span> (sa[i]&gt;w) id[++p]=sa[i]-w;</span><br></pre></td></tr></table></figure><p>意会一下，先把 $s[i+w..i+2w-1]$ 为空串的位置放前面，再把剩下的按排好的顺序放进去。</p><h4 id="优化计数排序的值域"><a href="#优化计数排序的值域" class="headerlink" title="优化计数排序的值域"></a>优化计数排序的值域</h4><p>每次对 $rk$ 进行去重之后，我们都计算了一个 $p$，这个 $p$ 即是 $k$ 的值域，将值域改成它即可。</p><h4 id="无需新开数组oldrk并memcpy"><a href="#无需新开数组oldrk并memcpy" class="headerlink" title="无需新开数组oldrk并memcpy"></a>无需新开数组oldrk并memcpy</h4><p>注意到计算完 $sa$ 之后 $id$ 数组就没有用了，可以直接 <code>swap(id,rk)</code> 来把 <code>oldrk</code> 的信息存在 <code>id</code> 数组中（$id$ 和 $rk$ 本质上都是指针，所以 <code>swap</code> 是 $O(1)$ 的）。注意两个数组要开一样大才能 <code>swap</code>。</p><h4 id="将-rk-id-i-存下来，减少不连续内存访问"><a href="#将-rk-id-i-存下来，减少不连续内存访问" class="headerlink" title="将 $rk[id[i]]$ 存下来，减少不连续内存访问"></a>将 $rk[id[i]]$ 存下来，减少不连续内存访问</h4><p>这个优化在数据范围较大时效果非常明显。</p><h4 id="用函数cmp来计算是否重复"><a href="#用函数cmp来计算是否重复" class="headerlink" title="用函数cmp来计算是否重复"></a>用函数cmp来计算是否重复</h4><p>同样是减少不连续内存访问，在数据范围较大时效果比较明显。</p><p>把 <code>oldrk[sa[i]]==oldrk[sa[i-1]]&amp;&amp;oldrk[sa[i]+w]==oldrk[sa[i-1]+w]</code> 替换成 <code>cmp(sa[i],sa[i-1],w)</code>，<code>bool cmp(int x,int y,int w){ return id[x]==id[y]&amp;&amp;id[x+w]==id[y+w]; }</code>。</p><div><div class="fold_hider"><div class="close hider_title">参考代码</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> n,sa[N],rk[N&lt;&lt;<span class="number">1</span>],id[N&lt;&lt;<span class="number">1</span>],px[N],cnt[N]; <span class="comment">//px[i]=rk[id[i]]（用于排序的数组所以叫px）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> w)</span></span>&#123; <span class="keyword">return</span> id[x]==id[y]&amp;&amp;id[x+w]==id[y+w]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,m=<span class="number">300</span>,p,w;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s+<span class="number">1</span>);</span><br><span class="line">    n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;++i) ++cnt[rk[i]=s[i]];</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;++i) cnt[i]+=cnt[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span> (i=n;i&gt;=<span class="number">1</span>;--i) sa[cnt[rk[i]]--]=i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (w=<span class="number">1</span>;w&lt;n;w&lt;&lt;=<span class="number">1</span>,m=p) <span class="comment">//m=p就是优化计数排序值域</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (p=<span class="number">0</span>,i=n;i&gt;n-w;--i) id[++p]=i;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">if</span> (sa[i]&gt;w) id[++p]=sa[i]-w;</span><br><span class="line">        <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span>(cnt));</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;++i) ++cnt[px[i]=rk[id[i]]];</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;++i) cnt[i]+=cnt[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span> (i=n;i&gt;=<span class="number">1</span>;--i) sa[cnt[px[i]]--]=id[i];</span><br><span class="line">        swap(rk,id);</span><br><span class="line">        <span class="keyword">for</span> (p=<span class="number">0</span>,i=<span class="number">1</span>;i&lt;=n;++i) rk[sa[i]]=cmp(sa[i],sa[i<span class="number">-1</span>],w)?p:++p; <span class="comment">//注意这里的id相当于原来的oldrk</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">printf</span>(<span class="string">"%d "</span>,sa[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样优化之后应该不开O2都能过。</p></div></div><h2 id="O-n-做法"><a href="#O-n-做法" class="headerlink" title="$O(n)$ 做法"></a>$O(n)$ 做法</h2><p><del>名字叫DC3，我不会</del></p><p>可以参考<a href="https://wenku.baidu.com/view/5b886b1ea76e58fafab00374.html" target="_blank" rel="noopener">[2009]后缀数组——处理字符串的有力工具 by.罗穗骞</a>，里面有介绍这个算法。</p><p>一般情况下用倍增法做足常数优化是不会被卡的..</p><h1 id="后缀数组无需-height-数组的应用"><a href="#后缀数组无需-height-数组的应用" class="headerlink" title="后缀数组无需 $height$ 数组的应用"></a>后缀数组无需 $height$ 数组的应用</h1><p>如果用不到 $height$ 数组，一般就是利用 $rk$ 数组对字符串进行排序，有时需要对原串进行一定的加工使需要排序的字符串变成后缀，或者是只需对后缀进行排序便能对需要排序的字符串进行排序。</p><h2 id="JSOI2007-字符加密"><a href="#JSOI2007-字符加密" class="headerlink" title="[JSOI2007]字符加密"></a>[JSOI2007]字符加密</h2><p><a href="https://www.luogu.org/problemnew/show/P4051" target="_blank" rel="noopener">洛谷</a></p><p><a href="https://darkbzoj.cf/problem/1031" target="_blank" rel="noopener">dark bzoj</a></p><h2 id="USACO07DEC-Best-Cow-Line-Gold"><a href="#USACO07DEC-Best-Cow-Line-Gold" class="headerlink" title="[USACO07DEC]Best Cow Line, Gold"></a>[USACO07DEC]Best Cow Line, Gold</h2><p><a href="https://www.luogu.org/problemnew/show/P2870" target="_blank" rel="noopener">洛谷</a></p><p><a href="https://ouuan.github.io/P2870-USACO07DEC-Best-Cow-Line-Gold%EF%BC%88%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%EF%BC%89/">我的题解</a></p><h1 id="height-数组"><a href="#height-数组" class="headerlink" title="$height$ 数组"></a>$height$ 数组</h1><p>后缀数组的题目往往是要用到 $height$ 数组的。</p><h2 id="lcp（最长公共前缀）"><a href="#lcp（最长公共前缀）" class="headerlink" title="lcp（最长公共前缀）"></a>lcp（最长公共前缀）</h2><p>两个字符串 $S$ 和 $T$ 的 $lcp$ 就是最大的 $x$ 使得 $S_i=T_i (\forall 1\le i\le x)$ 。</p><p>下文中以 $lcp(i,j)$ 表示后缀 $i$ 和后缀 $j$ 的最长公共前缀（的长度）。</p><h2 id="height-数组的定义"><a href="#height-数组的定义" class="headerlink" title="$height$ 数组的定义"></a>$height$ 数组的定义</h2><p>$height[i]=lcp(sa[i],sa[i-1])$，即第 $i$ 名的后缀与它前一名的后缀的最长公共前缀。</p><h2 id="O-n-求-height-数组需要的一个引理"><a href="#O-n-求-height-数组需要的一个引理" class="headerlink" title="$O(n)$ 求 $height$ 数组需要的一个引理"></a>$O(n)$ 求 $height$ 数组需要的一个引理</h2><p>$height[rk[i]]\ge height[rk[i-1]]-1$</p><p>证明的话..<del>感性理解</del></p><p>当 $height[rk[i-1]]\le1$ 时，上式显然成立（右边小于等于 $0$ ）。</p><p>当 $height[rk[i-1]]&gt;1$ 时：</p><p>设后缀 $i-1$ 为 $aAD$（$A$ 是一个长度为 $height[rk[i-1]]-1$ 的字符串），那么后缀 $i$ 就是 $AD$。设后缀 $sa[rk[i-1]-1]$ 为 $aAB$ ，那么 $lcp(i-1,sa[rk[i-1]-1])=aA$。由于后缀 $sa[rk[i-1]-1]+1$ 是 $AB$，一定排在后缀 $i$ 的前面，所以后缀 $sa[rk[i]-1]$ 一定含有前缀 $A$，所以 $lcp(i,sa[rk[i]-1])$ 至少是 $height[rk[i-1]]-1$。</p><p>简单来说：</p><p>$i-1$：$aAD$</p><p>$i$：$AD$</p><p>$sa[rk[i-1]-1]$：$aAB$</p><p>$sa[rk[i-1]-1]+1$：$AB$</p><p>$sa[rk[i]-1]$：$A[B/C]$</p><p>$lcp(i,sa[rk[i]-1])$：$AX$（$X$ 可能为空）</p><h2 id="O-n-求-height-数组的代码实现"><a href="#O-n-求-height-数组的代码实现" class="headerlink" title="$O(n)$ 求 $height$ 数组的代码实现"></a>$O(n)$ 求 $height$ 数组的代码实现</h2><p>利用上面这个引理暴力求即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i=<span class="number">1</span>,k=<span class="number">0</span>;i&lt;=n;++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (k) --k;</span><br><span class="line">    <span class="keyword">while</span> (s[i+k]==s[sa[rk[i]<span class="number">-1</span>]+k]) ++k;</span><br><span class="line">    ht[rk[i]]=k; <span class="comment">//height太长了缩写为ht</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>利用摊还分析/势能分析可以发现是O(n)的</del>，$k$ 不会超过 $n$，最多减 $n$ 次，所以最多加 $2n$ 次。</p><h2 id="应用-height-数组需要的一个性质"><a href="#应用-height-数组需要的一个性质" class="headerlink" title="应用 $height$ 数组需要的一个性质"></a>应用 $height$ 数组需要的一个性质</h2><p>$lcp(sa[i],sa[j])=\min\{height[i+1..j]\}$</p><p>感性理解：如果 $height$ 一直大于某个数，前这么多位就一直没变过；反之，由于后缀已经排好序了，不可能变了之后变回来。</p><p>严格证明可以参考<a href="https://wenku.baidu.com/view/0dc03d2b1611cc7931b765ce0508763230127479.html" target="_blank" rel="noopener">[2004]后缀数组 by.徐智磊</a>。</p><h2 id="height-数组的应用"><a href="#height-数组的应用" class="headerlink" title="$height$ 数组的应用"></a>$height$ 数组的应用</h2><p>$height$ 数组往往用来解决关于字符串公共部分的题目，通常需要和RMQ/单调栈等算法相结合。</p><h3 id="USACO06DEC-Milk-Patterns"><a href="#USACO06DEC-Milk-Patterns" class="headerlink" title="[USACO06DEC]Milk Patterns"></a>[USACO06DEC]Milk Patterns</h3><p><a href="https://www.luogu.org/problemnew/show/P2852" target="_blank" rel="noopener">洛谷</a></p><p><a href="https://ouuan.github.io/P2852-USACO06DEC-Milk-Patterns%EF%BC%88%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%EF%BC%89/">我的题解</a></p><h3 id="AHOI2013-差异"><a href="#AHOI2013-差异" class="headerlink" title="[AHOI2013]差异"></a>[AHOI2013]差异</h3><p><a href="https://www.luogu.org/problemnew/show/P3181" target="_blank" rel="noopener">洛谷</a></p><p><a href="https://darkbzoj.cf/problem/3238" target="_blank" rel="noopener">dark bzoj</a></p><h3 id="HAOI2016-找相同字符"><a href="#HAOI2016-找相同字符" class="headerlink" title="[HAOI2016]找相同字符"></a>[HAOI2016]找相同字符</h3><p><a href="https://www.luogu.org/problemnew/show/P3181" target="_blank" rel="noopener">洛谷</a></p><p><a href="https://darkbzoj.cf/problem/4566" target="_blank" rel="noopener">dark bzoj</a></p><p><a href="https://ouuan.github.io/BZOJ4566-HAOI2016-%E6%89%BE%E7%9B%B8%E5%90%8C%E5%AD%97%E7%AC%A6%EF%BC%88%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%EF%BC%89/">我的题解</a></p><h3 id="NOI2015-品酒大会"><a href="#NOI2015-品酒大会" class="headerlink" title="[NOI2015]品酒大会"></a>[NOI2015]品酒大会</h3><p><a href="https://www.luogu.org/problemnew/show/P2178" target="_blank" rel="noopener">洛谷</a></p><p><a href="https://darkbzoj.cf/problem/3238" target="_blank" rel="noopener">dark bzoj</a></p><h3 id="SP8222-NSUBSTR-Substrings"><a href="#SP8222-NSUBSTR-Substrings" class="headerlink" title="SP8222 NSUBSTR - Substrings"></a>SP8222 NSUBSTR - Substrings</h3><p><a href="https://www.luogu.org/problemnew/show/SP8222" target="_blank" rel="noopener">洛谷</a></p><p><a href="https://www.spoj.com/problems/NSUBSTR/" target="_blank" rel="noopener">SPOJ</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;后缀数组是一种处理字符串问题的有力工具（废话），本文的主要特点是一步步地由最朴素的后缀数组构建方法逐步优化，而非直接给出最终优化后的代码。&lt;/p&gt;
&lt;p&gt;希望这篇文章能让更多的人看懂后缀数组的代码，学会后缀数组。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://ouuan.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="字符串" scheme="https://ouuan.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="后缀数组" scheme="https://ouuan.github.io/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ4566 [HAOI2016]找相同字符（后缀数组）</title>
    <link href="https://ouuan.github.io/BZOJ4566-HAOI2016-%E6%89%BE%E7%9B%B8%E5%90%8C%E5%AD%97%E7%AC%A6%EF%BC%88%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%EF%BC%89/"/>
    <id>https://ouuan.github.io/BZOJ4566-HAOI2016-找相同字符（后缀数组）/</id>
    <published>2019-02-14T03:22:18.000Z</published>
    <updated>2019-04-02T23:56:25.469Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.luogu.org/problemnew/show/P3181" target="_blank" rel="noopener">洛谷</a></p><p><a href="https://darkbzoj.cf/problem/4566" target="_blank" rel="noopener">dark bzoj</a></p><h1 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h1><p>给你两个字符串，从中各取一个子串使这两个子串相同，求方案数。</p><a id="more"></a><h1 id="简要做法"><a href="#简要做法" class="headerlink" title="简要做法"></a>简要做法</h1><p>以某两个位置开头的相同子串数=这两个位置开头的后缀的 $lcp$</p><p>如果在同一个字符串中，求出 <code>height</code> 数组后使用单调栈求出每个位置作为最小值的贡献即可（单调栈部分与 <a href="https://www.luogu.org/problemnew/show/P2659" target="_blank" rel="noopener">P2659 美丽的序列</a>，<a href="https://www.luogu.org/problemnew/show/P1169" target="_blank" rel="noopener">[ZJOI2007]棋盘制作</a> 等题类似，在此就不赘述了；求两两 $lcp​$ 之和这部分与 <a href="https://www.luogu.org/problemnew/show/P4248" target="_blank" rel="noopener">[AHOI2013]差异</a> 类似，故没有写那题的题解）。</p><p>由于有两个字符串不太方便，考虑将它们拼接起来并在中间加上一个不存在的字符（如<code>#</code>）。这样求出拼接后的字符串的答案，减去两个原串的答案，就是最终的答案。</p><h1 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">400010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sa[N],sa2[N&lt;&lt;<span class="number">1</span>],rk[N&lt;&lt;<span class="number">1</span>],px[N],cnt[N],sta[N],top,f[N],height[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Suffix_Array</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> s[N];</span><br><span class="line">    <span class="function">ll <span class="title">calc</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ll out=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n,i,k,w,p,m=<span class="number">200</span>;</span><br><span class="line">        n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">memset</span>(sa2,<span class="number">0</span>,<span class="keyword">sizeof</span>(sa2));</span><br><span class="line">        <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span>(cnt));</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;++i) ++cnt[rk[i]=s[i]];</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;++i) cnt[i]+=cnt[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span> (i=n;i&gt;=<span class="number">1</span>;--i) sa[cnt[rk[i]]--]=i;</span><br><span class="line">        <span class="keyword">for</span> (w=<span class="number">1</span>;w&lt;n;w&lt;&lt;=<span class="number">1</span>,m=p)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span>(cnt));</span><br><span class="line">            <span class="keyword">for</span> (p=<span class="number">0</span>,i=n;i&gt;n-w;--i) sa2[++p]=i;</span><br><span class="line">            <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">if</span> (sa[i]&gt;w) sa2[++p]=sa[i]-w;</span><br><span class="line">            <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;++i) ++cnt[px[i]=rk[sa2[i]]];</span><br><span class="line">            <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;++i) cnt[i]+=cnt[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">for</span> (i=n;i&gt;=<span class="number">1</span>;--i) sa[cnt[px[i]]--]=sa2[i];</span><br><span class="line">            swap(rk,sa2);</span><br><span class="line">            <span class="keyword">for</span> (p=<span class="number">0</span>,i=<span class="number">1</span>;i&lt;=n;++i) rk[sa[i]]=sa2[sa[i]]==sa2[sa[i<span class="number">-1</span>]]&amp;&amp;sa2[sa[i]+w]==sa2[sa[i<span class="number">-1</span>]+w]?p:++p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">1</span>,k=<span class="number">0</span>;i&lt;=n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (k) --k;</span><br><span class="line">            <span class="keyword">while</span> (s[i+k]==s[sa[rk[i]<span class="number">-1</span>]+k]) ++k;</span><br><span class="line">            height[rk[i]]=k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (top&amp;&amp;height[sta[top]]&gt;=height[i]) --top;</span><br><span class="line">            f[i]=i-sta[top];</span><br><span class="line">            sta[++top]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        top=<span class="number">0</span>;</span><br><span class="line">        sta[++top]=n+<span class="number">1</span>;</span><br><span class="line">        height[n+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i=n;i&gt;=<span class="number">1</span>;--i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (top&amp;&amp;height[sta[top]]&gt;height[i]) --top;</span><br><span class="line">            out+=(ll)f[i]*(sta[top]-i)*height[i];</span><br><span class="line">            sta[++top]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; a,b,ab;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s%s"</span>,a.s+<span class="number">1</span>,b.s+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    n=<span class="built_in">strlen</span>(a.s+<span class="number">1</span>);</span><br><span class="line">    m=<span class="built_in">strlen</span>(b.s+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;++i) ab.s[i]=a.s[i];</span><br><span class="line">    ab.s[n+<span class="number">1</span>]=<span class="string">'#'</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;++i) ab.s[n+<span class="number">1</span>+i]=b.s[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ab.calc()-a.calc()-b.calc();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/P3181&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;洛谷&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://darkbzoj.cf/problem/4566&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;dark bzoj&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;题意简述&quot;&gt;&lt;a href=&quot;#题意简述&quot; class=&quot;headerlink&quot; title=&quot;题意简述&quot;&gt;&lt;/a&gt;题意简述&lt;/h1&gt;&lt;p&gt;给你两个字符串，从中各取一个子串使这两个子串相同，求方案数。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://ouuan.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="字符串" scheme="https://ouuan.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="后缀数组" scheme="https://ouuan.github.io/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>P2852 [USACO06DEC]Milk Patterns（后缀数组）</title>
    <link href="https://ouuan.github.io/P2852-USACO06DEC-Milk-Patterns%EF%BC%88%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%EF%BC%89/"/>
    <id>https://ouuan.github.io/P2852-USACO06DEC-Milk-Patterns（后缀数组）/</id>
    <published>2019-02-14T03:21:26.000Z</published>
    <updated>2019-04-03T00:01:26.715Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.luogu.org/problemnew/show/P2852" target="_blank" rel="noopener">洛谷</a></p><h1 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h1><p>给你一个字符串，求最长的出现了至少 $k$ 次的子串的长度。</p><a id="more"></a><h1 id="简要做法"><a href="#简要做法" class="headerlink" title="简要做法"></a>简要做法</h1><p>求出 <code>height</code> 数组，若一个长为 $x$ 的子串在原串中出现了至少 $k$ 次，则 <code>height</code> 数组中一定存在至少 $k-1$ 个 连续的大于等于 $x$ 的值。所以，问题就转化成了：求 <code>height</code> 数组中 <strong>每连续 $k-1$ 个数的最小值</strong> 的最大值。即：$a_i=\min\{height_{i..i+k-2}\}$，求 $a_i$ 的最大值。可以用RMQ/平衡树/线段树/multiset解决。</p><h1 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">40010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,k,a[N],sa[N],rk[N],sa2[N],px[N],cnt[<span class="number">1000010</span>],height[N],ans;</span><br><span class="line"><span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,w,p,m=<span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">    --k;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;++i) ++cnt[rk[i]=a[i]];</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;++i) cnt[i]+=cnt[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span> (i=n;i&gt;=<span class="number">1</span>;--i) sa[cnt[rk[i]]--]=i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (w=<span class="number">1</span>;w&lt;n;w&lt;&lt;=<span class="number">1</span>,m=p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span>(cnt));</span><br><span class="line">        <span class="keyword">for</span> (p=<span class="number">0</span>,i=n;i&gt;n-w;--i) sa2[++p]=i;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">if</span> (sa[i]&gt;w) sa2[++p]=sa[i]-w;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;++i) ++cnt[px[i]=rk[sa2[i]]];</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;++i) cnt[i]+=cnt[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span> (i=n;i&gt;=<span class="number">1</span>;--i) sa[cnt[px[i]]--]=sa2[i];</span><br><span class="line">        swap(rk,sa2);</span><br><span class="line">        <span class="keyword">for</span> (p=<span class="number">0</span>,i=<span class="number">1</span>;i&lt;=n;++i) rk[sa[i]]=sa2[sa[i]]==sa2[sa[i<span class="number">-1</span>]]&amp;&amp;sa2[sa[i]+w]==sa2[sa[i<span class="number">-1</span>]+w]?p:++p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (j) --j;</span><br><span class="line">        <span class="keyword">while</span> (a[i+j]==a[sa[rk[i]<span class="number">-1</span>]+j]) ++j;</span><br><span class="line">        height[rk[i]]=j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        t.insert(height[i]);</span><br><span class="line">        <span class="keyword">if</span> (i&gt;k) t.erase(t.find(height[i-k]));</span><br><span class="line">        ans=max(ans,*t.begin());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/P2852&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;洛谷&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;题意简述&quot;&gt;&lt;a href=&quot;#题意简述&quot; class=&quot;headerlink&quot; title=&quot;题意简述&quot;&gt;&lt;/a&gt;题意简述&lt;/h1&gt;&lt;p&gt;给你一个字符串，求最长的出现了至少 $k$ 次的子串的长度。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://ouuan.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="字符串" scheme="https://ouuan.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="后缀数组" scheme="https://ouuan.github.io/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>P2870 [USACO07DEC]Best Cow Line, Gold（后缀数组）</title>
    <link href="https://ouuan.github.io/P2870-USACO07DEC-Best-Cow-Line-Gold%EF%BC%88%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%EF%BC%89/"/>
    <id>https://ouuan.github.io/P2870-USACO07DEC-Best-Cow-Line-Gold（后缀数组）/</id>
    <published>2019-02-14T03:20:59.000Z</published>
    <updated>2019-04-03T00:01:35.467Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.luogu.org/problemnew/show/P2870" target="_blank" rel="noopener">洛谷</a></p><h1 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h1><p>给你一个字符串，每次从首或尾取一个字符组成字符串，问所有能够组成的字符串中字典序最小的一个。</p><a id="more"></a><h1 id="简要做法"><a href="#简要做法" class="headerlink" title="简要做法"></a>简要做法</h1><p>暴力做法就是每次最坏 $O(n)$ 地判断当前应该取首还是尾，只需优化这一判断过程即可。</p><p>将原串reverse后拼接在原串后，并在中间加上一个没出现过的字符（如 <code>#</code> ），求SA，即可 $O(1)$ 完成这一判断。</p><h1 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> n,sa[N],sa2[N&lt;&lt;<span class="number">1</span>],rk[N&lt;&lt;<span class="number">1</span>],px[N],cnt[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,w,m=<span class="number">200</span>,p,l=<span class="number">1</span>,r,tot=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    r=n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">while</span> (!<span class="built_in">isalpha</span>(s[i]=getchar()));</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;++i) rk[i]=rk[<span class="number">2</span>*n+<span class="number">2</span>-i]=s[i];</span><br><span class="line"></span><br><span class="line">    n=<span class="number">2</span>*n+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;++i) ++cnt[rk[i]];</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;++i) cnt[i]+=cnt[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span> (i=n;i&gt;=<span class="number">1</span>;--i) sa[cnt[rk[i]]--]=i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (w=<span class="number">1</span>;w&lt;n;w&lt;&lt;=<span class="number">1</span>,m=p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span>(cnt));</span><br><span class="line">        <span class="keyword">for</span> (p=<span class="number">0</span>,i=n;i&gt;n-w;--i) sa2[++p]=i;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">if</span> (sa[i]&gt;w) sa2[++p]=sa[i]-w;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;++i) ++cnt[px[i]=rk[sa2[i]]];</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;++i) cnt[i]+=cnt[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span> (i=n;i&gt;=<span class="number">1</span>;--i) sa[cnt[px[i]]--]=sa2[i];</span><br><span class="line">        swap(sa2,rk);</span><br><span class="line">        <span class="keyword">for</span> (p=<span class="number">0</span>,i=<span class="number">1</span>;i&lt;=n;++i) rk[sa[i]]=sa2[sa[i]]==sa2[sa[i<span class="number">-1</span>]]&amp;&amp;sa2[sa[i]+w]==sa2[sa[i<span class="number">-1</span>]+w]?p:++p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (l&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>,rk[l]&lt;rk[n+<span class="number">1</span>-r]?s[l++]:s[r--]);</span><br><span class="line">        <span class="keyword">if</span> ((++tot)%<span class="number">80</span>==<span class="number">0</span>) <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/P2870&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;洛谷&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;题意简述&quot;&gt;&lt;a href=&quot;#题意简述&quot; class=&quot;headerlink&quot; title=&quot;题意简述&quot;&gt;&lt;/a&gt;题意简述&lt;/h1&gt;&lt;p&gt;给你一个字符串，每次从首或尾取一个字符组成字符串，问所有能够组成的字符串中字典序最小的一个。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://ouuan.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="字符串" scheme="https://ouuan.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="后缀数组" scheme="https://ouuan.github.io/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ1856 [SCOI2010]生成字符串（组合数学）</title>
    <link href="https://ouuan.github.io/BZOJ1856-SCOI2010-%E7%94%9F%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%EF%BC%89/"/>
    <id>https://ouuan.github.io/BZOJ1856-SCOI2010-生成字符串（组合数学）/</id>
    <published>2019-02-12T06:56:42.000Z</published>
    <updated>2019-04-02T23:55:47.793Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.luogu.org/problemnew/show/P1641" target="_blank" rel="noopener">洛谷</a></p><p><a href="https://darkbzoj.cf/problem/1856" target="_blank" rel="noopener">darkbzoj</a></p><h1 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h1><p>$n$ 个入栈操作，$m$ 个出栈操作，问合法操作序列数。</p><a id="more"></a><h1 id="简要做法"><a href="#简要做法" class="headerlink" title="简要做法"></a>简要做法</h1><p>借用一下<a href="https://www.luogu.org/blog/user29936/solution-p1641" target="_blank" rel="noopener">这篇题解</a>（的图）。</p><p>选了 $x$ 个数，$1$ 与 $0$ 个数之差为 $y$，如下图：</p><p><img src="http://img.blog.csdn.net/20170826103642649?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHl6MzI3Njg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><p>不考虑限制条件，方案数为从 $(0,0)$ 到 $(n+m,n-m)$ 的折线数，即从 $n+m$ 次操作中选择 $m$ 次向下： $\binom{n+m}m$。考虑某一种不合法的情况，把这条折线第一次碰到 $y=-1$ 前的部分以 $y=-1$ 为轴翻折，这样就建立了 <strong>从 $(0,0)$ 到 $(n+m,n-m)$ 且碰到了 $y=-1$ 的折线</strong> 与 <strong>从 $(0,-2)$ 到 $(n+m,n-m)$ 的折线</strong> 的一一对应，所以不合法的情况个数为 $\binom{n+m}{m-1}$，答案为 $\binom{n+m}m-\binom{n+m}{m-1}$。</p><p>（<del>上面看懂了这段可以不看，这段是废话证明</del>）为什么这玩意是双射（一一对应）..其实很简单，每条 <strong>从 $(0,0)$ 到 $(n+m,n-m)$ 且碰到了 $y=-1$ 的折线</strong> 在第一次碰到 $y=-1$ 前的部分以 $y=-1$ 为轴翻折可以得到唯一一条 <strong>从 $(0,-2)$ 到 $(n+m,n-m)$ 的折线</strong>，而一条 <strong>从 $(0,-2)$ 到 $(n+m,n-m)$ 的折线</strong> 必然会碰到 $y=-1$，同样可以把它在第一次碰到 $y=-1$ 前的部分以 $y=-1$ 为轴翻折，就会得到唯一一条 <strong>从 $(0,0)$ 到 $(n+m,n-m)$ 且碰到了 $y=-1$ 的折线</strong>。</p><p><del>最后吐槽一句。你谷完全不接受做法相同的题解，无法对已有做法进行阐述，所以并没有尝试在你谷发题解。</del></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">20100403</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">c</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> jc[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    jc[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+m;++i) jc[i]=(ll)jc[i<span class="number">-1</span>]*i%mod;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;(c(n+m,m)-c(n+m,m<span class="number">-1</span>)+mod)%mod;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> out=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (y&amp;<span class="number">1</span>) out=(ll)out*x%mod;</span><br><span class="line">        x=(ll)x*x%mod;</span><br><span class="line">        y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">c</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (ll)jc[x]*qpow(jc[y],mod<span class="number">-2</span>)%mod*qpow(jc[x-y],mod<span class="number">-2</span>)%mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/P1641&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;洛谷&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://darkbzoj.cf/problem/1856&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;darkbzoj&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;题意简述&quot;&gt;&lt;a href=&quot;#题意简述&quot; class=&quot;headerlink&quot; title=&quot;题意简述&quot;&gt;&lt;/a&gt;题意简述&lt;/h1&gt;&lt;p&gt;$n$ 个入栈操作，$m$ 个出栈操作，问合法操作序列数。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://ouuan.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="组合数学" scheme="https://ouuan.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>n方过百万 暴力碾标算——指令集优化的基础使用</title>
    <link href="https://ouuan.github.io/n%E6%96%B9%E8%BF%87%E7%99%BE%E4%B8%87-%E6%9A%B4%E5%8A%9B%E7%A2%BE%E6%A0%87%E7%AE%97%E2%80%94%E2%80%94%E6%8C%87%E4%BB%A4%E9%9B%86%E4%BC%98%E5%8C%96%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"/>
    <id>https://ouuan.github.io/n方过百万-暴力碾标算——指令集优化的基础使用/</id>
    <published>2019-02-01T06:26:52.000Z</published>
    <updated>2019-04-03T00:01:07.145Z</updated>
    
    <content type="html"><![CDATA[<p>感谢 yfz 和 mcfx 在 WC 营员交流上的分享！</p><p>然而只看那个课件来学习指令集好像略有困难..所以我来分享一下<del>我自学一晚上的成果</del>。</p><p>希望能帮助大家暴力过题，<del>考场上再也写不出标算</del>。</p><a id="more"></a><blockquote><p>注：本文省略了无数个 <code>unsigned</code>，请自行把所有 <code>int</code> 视作 <code>unsigned int</code>，把所有 <code>long long</code> 视作 <code>unsigned long long</code>。</p></blockquote><h1 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h1><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p><strong>不要尝试在正式OI竞赛中使用指令集优化。</strong></p><p>只适用于提供资瓷的 OJ，具体列表参照营员交流ppt：</p><img src="/n方过百万-暴力碾标算——指令集优化的基础使用/ojzc1.png"><img src="/n方过百万-暴力碾标算——指令集优化的基础使用/ojzc2.png"><p>sse2，avx 什么的都是指令集的名字。</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>适用于<strong>方便对连续内存空间进行批量处理</strong>的题目。大约可以视作每 $8$ 个 int 为一个分块，块内进行赋值、修改等操作常数为 $1$，也就实现了常数/=$8$。当然如果是 long long 就只能除以四。</p><h1 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h1><h2 id="pragma-amp-include"><a href="#pragma-amp-include" class="headerlink" title="pragma&amp;include"></a>pragma&amp;include</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"Ofast,no-stack-protector,unroll-loops,fast-math"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC target(<span class="meta-string">"sse,sse2,sse3,ssse3,sse4.1,sse4.2,avx,avx2,popcnt,tune=native"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;immintrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;emmintrin.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>第一行是优化，如果你都用指令集了当然是能优化尽量优化。</p><p>第二行是告诉编译器你要使用指令集。</p><p>后面两个头文件是 C++ 将指令集封装成了函数，这样就不用在代码中内联汇编了。</p><h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><p>大约有 <code>__m256i</code> <code>__m256</code> <code>__m256d</code> 三种，分别存储 <code>long long</code>，<code>float</code> 和 <code>double</code>，实际上 <code>__m256i</code> 也可以用来存储 <code>int</code>。</p><h2 id="指令使用"><a href="#指令使用" class="headerlink" title="指令使用"></a>指令使用</h2><p>可以在<a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide" target="_blank" rel="noopener">一个神奇的网站</a>查需要的指令，左边选指令集以及指令类型，右边是指令，点开指令可以查看函数原型以及伪代码。</p><p>这里列几条常用指令：</p><p><code>__m256i _mm256_set_epi32 (int e7, int e6, int e5, int e4, int e3, int e2, int e1, int e0)</code>：参数是八个数，也就是一个“分块”里的数，注意是逆序的。返回值是一个含这八个数的“分块”。</p><p><code>__m256i _mm256_set_epi64x (__int64 e3, __int64 e2, __int64 e1, __int64 e0)</code>：和上面一样，只不过是 $64$ 位整数，也就是 long long。</p><p><code>__m256i _mm256_set1_epi32 (int a)</code>：相当于 <code>_mm256_set_epi32(a,a,a,a,a,a,a,a)</code>。</p><p><code>__m256i _mm256_add_epi32 (__m256i a, __m256i b)</code>：把两个“分块”的对应位置分别相加，返回结果。</p><p><code>__m256i _mm256_cmpeq_epi32 (__m256i a, __m256i b)</code>：判断两个“分块”的对应位置是否相等，若相等则返回的“分块”对应位置是 <code>0xffffffff</code>，否则是 <code>0</code>。</p><p><code>__m256i _mm256_cmpgt_epi32 (__m256i a, __m256i b)</code>：和上面一样，只不过比较符是大于而不是相等。</p><p><code>__m256i _mm256_and_si256 (__m256i a, __m256i b)</code>：返回两个“分块”的按位与，可以配合上面两条比较指令来使用。</p><h2 id="访问数据"><a href="#访问数据" class="headerlink" title="访问数据"></a>访问数据</h2><p>可以直接通过下标访问：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"Ofast,no-stack-protector,unroll-loops,fast-math"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC target(<span class="meta-string">"sse,sse2,sse3,ssse3,sse4.1,sse4.2,avx,avx2,popcnt,tune=native"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;immintrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;emmintrin.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">__m256i a;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a=_mm256_set_epi32(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,a[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你们可以猜猜这个的结果是什么。</p><p>答案是..4。</p><p>为什么呢，首先 <code>_mm256_set_epi32</code> 的参数是逆序的，所以实际上存储的数顺序是 <code>8,7,6,5,4,3,2,1</code>。其次，<code>__m256i</code> 类型是存储 long long 的，所以直接通过下标访问实际上是在访问 long long，如果 <code>cout&lt;&lt;a[2]</code>就会返回 <code>12884901892</code>（$3\times2^{32}+4$）。所以，这句话实际上是在 <code>printf(&quot;%d&quot;,12884901892ll);</code>。</p><p>那么如何访问 <code>int</code>（甚至 <code>short</code>，如果题目允许这样就可以常数除以 $16$）呢？</p><p>其实搞个指针就可以了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=_mm256_set_epi32(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>);</span><br><span class="line"><span class="keyword">int</span> *b=(<span class="keyword">int</span> *)&amp;a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,b[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure><p>这样子的输出就是 $6$ 了。</p><p>用这种方法就可以方便地处理序列问题了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"Ofast,no-stack-protector,unroll-loops,fast-math"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC target(<span class="meta-string">"sse,sse2,sse3,ssse3,sse4.1,sse4.2,avx,avx2,popcnt,tune=native"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;immintrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;emmintrin.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>* b;</span><br><span class="line">__m256i a[<span class="number">10</span>],x;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    b=(<span class="keyword">int</span> *)&amp;a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">80</span>;++i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,b+i);</span><br><span class="line"></span><br><span class="line">    x=_mm256_set1_epi32(<span class="number">233</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i) a[i]=_mm256_add_epi32(a[i],x);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">80</span>;++i) <span class="built_in">printf</span>(<span class="string">"%d "</span>,b[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是一个简单的示例，读入 $80$ 个数，然后输出它们加上 $233$ 的结果。</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p><del>这种东西为什么还会有例题啊。</del></p><p><a href="https://www.luogu.org/problemnew/show/P2801" target="_blank" rel="noopener">教主的魔法</a>，这题比较简单（<del>废话暴力当然简单</del>）。</p><p><a href="https://www.luogu.org/problemnew/show/P3372" target="_blank" rel="noopener">【模板】线段树1</a>，这题其实是最简单的，然而由于 dl 出题人把值域搞到了 long long，常数只能除以四，需要卡卡常，多提交几次才能过。</p><p><a href="https://www.luogu.org/problemnew/show/P4117" target="_blank" rel="noopener">[Ynoi2018]五彩斑斓的世界</a>，神司怒艹lxl标算的课件例题。</p><p><a href="http://uoj.ac/problem/435" target="_blank" rel="noopener">Simple Tree</a>，这个还要树剖，只不过也还好，神司是直接内嵌汇编写的，没有测过用函数能不能过..</p><p>然后以教主的魔法为例讲一下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"Ofast,no-stack-protector,unroll-loops,fast-math"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC target(<span class="meta-string">"sse,sse2,sse3,ssse3,sse4.1,sse4.2,avx,avx2,popcnt,tune=native"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;immintrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;emmintrin.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,tot,*a;</span><br><span class="line">__m256i A[N&gt;&gt;<span class="number">3</span>];</span><br><span class="line"><span class="keyword">char</span> op[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> ((l&amp;<span class="number">7</span>)&amp;&amp;l&lt;r) a[l++]+=x; <span class="comment">//处理左边不是整块的部分，和分块的处理方法是一样的</span></span><br><span class="line">    <span class="keyword">if</span> (l==r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">while</span> (r&amp;<span class="number">7</span>) a[--r]+=x; <span class="comment">//处理右边不是整块的部分</span></span><br><span class="line">    <span class="keyword">if</span> (l==r) <span class="keyword">return</span>;</span><br><span class="line">    __m256i t=_mm256_set1_epi32(x); <span class="comment">//剩下的部分整块加上x</span></span><br><span class="line">    <span class="keyword">for</span> (l&gt;&gt;=<span class="number">3</span>,r&gt;&gt;=<span class="number">3</span>;l&lt;r;++l) A[l]=_mm256_add_epi32(A[l],t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> out=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((l&amp;<span class="number">7</span>)&amp;&amp;l&lt;r) out+=<span class="keyword">int</span>(a[l++]&gt;=x); <span class="comment">//处理左边不是整块的部分</span></span><br><span class="line">    <span class="keyword">if</span> (l==r) <span class="keyword">return</span> out;</span><br><span class="line">    <span class="keyword">while</span> (r&amp;<span class="number">7</span>) out+=<span class="keyword">int</span>(a[--r]&gt;=x); <span class="comment">//处理右边不是整块的部分</span></span><br><span class="line">    <span class="keyword">if</span> (l==r) <span class="keyword">return</span> out;</span><br><span class="line">    __m256i t=_mm256_set1_epi32(<span class="number">1</span>); <span class="comment">//这个1是每个大于等于x的数的贡献</span></span><br><span class="line">    __m256i ans=_mm256_set1_epi32(<span class="number">0</span>); <span class="comment">//这个ans是用来存答案的</span></span><br><span class="line">    __m256i cp=_mm256_set1_epi32(x<span class="number">-1</span>); <span class="comment">//这个是用来比较的，题目中是大于等于，所以和x-1比较</span></span><br><span class="line">    <span class="keyword">for</span> (l&gt;&gt;=<span class="number">3</span>,r&gt;&gt;=<span class="number">3</span>;l&lt;r;++l) ans=_mm256_add_epi32(ans,_mm256_and_si256(t,_mm256_cmpgt_epi32(A[l],cp))); <span class="comment">//这个意会一下，作用是数当前块有几个大于x-1的数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;++i) out+=(ans[i]&amp;<span class="number">0xffffffff</span>)+(ans[i]&gt;&gt;<span class="number">32</span>); <span class="comment">//最后统计答案，因为ans[i]是一个long long，所以要前32位和后32位分别统计</span></span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,l,r,x,aa[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"></span><br><span class="line">    a=(<span class="keyword">int</span>*)&amp;A;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;++i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s%d%d%d"</span>,op,&amp;l,&amp;r,&amp;x);</span><br><span class="line">        <span class="keyword">if</span> (op[<span class="number">0</span>]==<span class="string">'M'</span>) modify(l<span class="number">-1</span>,r,x);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,query(l<span class="number">-1</span>,r,x));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;感谢 yfz 和 mcfx 在 WC 营员交流上的分享！&lt;/p&gt;
&lt;p&gt;然而只看那个课件来学习指令集好像略有困难..所以我来分享一下&lt;del&gt;我自学一晚上的成果&lt;/del&gt;。&lt;/p&gt;
&lt;p&gt;希望能帮助大家暴力过题，&lt;del&gt;考场上再也写不出标算&lt;/del&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="黑科技" scheme="https://ouuan.github.io/categories/%E9%BB%91%E7%A7%91%E6%8A%80/"/>
    
    
      <category term="常数优化" scheme="https://ouuan.github.io/tags/%E5%B8%B8%E6%95%B0%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>2019THUWC/WC冬眠记</title>
    <link href="https://ouuan.github.io/2019THUWC-WC%E5%86%AC%E7%9C%A0%E8%AE%B0/"/>
    <id>https://ouuan.github.io/2019THUWC-WC冬眠记/</id>
    <published>2019-01-20T04:16:15.000Z</published>
    <updated>2019-02-14T05:54:52.863Z</updated>
    
    <content type="html"><![CDATA[<p><del>又到了 Kanon 的季节呢</del>，快乐的冬眠生活开始了_(:з」∠)_</p><a id="more"></a><h1 id="Day-0-8"><a href="#Day-0-8" class="headerlink" title="Day 0/-8"></a>Day 0/-8</h1><p>Day -1 被归到<a href="https://ouuan.github.io/2018-2019%E5%86%AC-%E5%B9%BF%E4%BA%8C%E9%81%BF%E5%AF%92%E8%AE%B0/">广二避寒记</a>去了..</p><p>上午在水群的时候吐槽 Kanon 结局，然后和 yfz 稍微聊了一下，又看了看萌百，的确あゆ就是和风子、面码差不多的<a href="https://zh.moegirl.org/%E6%80%9D%E5%BF%B5%E4%BD%93" target="_blank" rel="noopener">思念体</a>鸭，为什么我会觉得看不懂呢..大约不止是因为あゆ的存在？</p><img src="/2019THUWC-WC冬眠记/yfz.jpg"><p>下午只做了一道题…淀粉质竟然能把 <code>solve(rt)</code> 写成 <code>solve(v)</code>…退役吧</p><p>然后不知道为什么去试了下自走棋，连续垫底了一下午，算是明示WC垫底了。</p><p>RNG居（guo）然连跪两把，<del>继续暗示窝WC的命运</del>。</p><h1 id="Day-1-7"><a href="#Day-1-7" class="headerlink" title="Day 1/-7"></a>Day 1/-7</h1><p>上午报到的时候没能和 <strong><font color="black">B</font><font color="red">lackRedRabbit</font></strong> 面基，只不过试机的时候发现brr就在窝左边的左边的左边，然后就愉快的面基了。</p><p>哦对了，晚上跟 jxl 还有 hyf 住。好像是女生宿舍？被子是粉的..然而听说A栋住女生，B栋住男生，感觉不会特意反过来..</p><p>试机题目T1（听别人说）是AC自动机上dp..本来就不会，AC自动机也几年没打过了…T2是THUSC2017提答，于是没做试机题，打了个NTT，还没一遍打对..丢人。</p><p>下午果然垫底了..T1一个简单 $12$ 分暴力打了 1h，然后 T2 的第一档 $26$ 分写了 1h 才过大（xiao）样例，交上去没过pt..然后又调了 50min，还是没过..然后花了 0.5h 重构代码，莫名其妙就过了..T3看了看感觉第一档都不会，回去看T2，T2是答对第一问有 $60\%$ 的分那种，发现自己会另一档的 $27\times60\%$，然后又花了 50min 写.. 最后 30min 的时候发现 T2 还有 $43\times 60\%$ 可以用可持久化并查集写，然而时间不够了…</p><p>T2 第一次写了 6K…（菜死了连 6K 都没写过..）也是第一次用 namespace 写 subtask。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (r&lt;=10&amp;&amp;c&lt;=10)</span><br><span class="line">&#123;</span><br><span class="line">    using namespace subtask1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样写真的爽_(:з」∠)_</p><p>T1是道期望，输出格式是最简分数，而且不约分的话数会非常大。当时我就在想为什么不取模..然后出考场听说 T1 的式子有一堆可以约分，剩下的形式特别简单… </p><p>我的游记好像经常不写题目就瞎bb..还是简单说一下吧。</p><p>T1：给两个数列 $a_{1..n},\,b_{1..n}$，多组询问，每次给 $c,\,d,\,e,\,f$ ，需要从 $a_{c..d}$ 和 $b_{e..f}$ 中各取 $d-c+1$ 个数然后两两配对，问配对的两个数相同的对数的期望，以最简分数形式输出。$n$ 和询问数好像大约是 $10^5$ ，因为只打了第一档暴力不记得了…</p><p>T2：一个网格图，有两种连边：</p><ol><li>一整行/列两两连边。</li><li>一些特殊点之间两两连边。</li></ol><p>有 $m$ 个被破坏的点，在某个时间点（每个被破坏的点独立）被修好，修好前所在行/列的整行/列连边不会连上。每个特殊点在某个时间点（每个特殊点独立）前不会和其它特殊点连边。多组询问问两个点联通的最早时间点，以及这个时间点的最短路。</p><p>网格大小 $10^5$，询问数 $10^6$，被破坏的点数和特殊点数都是 $2\times 10^5$。</p><p>T3：求有多少个不同的长度不超过 $m$ 的 区间取min操作序列 使得进行最后一次操作后原序列恰好变成指定序列。值域和序列大小一样都是 $n$。$n$ 好像是一两百的样子，$m$ $10^9$。</p><p>数据范围可能记错了，题意可能简述成看不懂了..QAQ就这样吧。</p><p>晚上开营仪式，先是清华系主任自吹，然后是广二校长继续吹+拉拢和THU的关系，然后请一个现在在THU的NOI2017Au爷<del>上台念了篇游记</del>…感觉那如果是篇游记还是写的挺好的，然而当众念出来..然后请了广二的一个妹子OIer 讲了一点，就结束了。</p><h1 id="Day-2-6"><a href="#Day-2-6" class="headerlink" title="Day 2/-6"></a>Day 2/-6</h1><p>今天是上午考试..T1是给你一棵树，每个点有 $a_i,\,b_i$，每条边有 $c_i,\,d_i$，$u$ 到 $v$ 的费用为 $\sum\limits_{i\text{ on path }(u,v)}\min(a_u+c_i,b_u+d_i)$，求每个点到其它所有点的费用之和。树大小 $5\times 10^5$，值域 $10^5$。开场先打了个暴力，然后感觉可以枚举每条边把树分成两半，然后就可以计算 $\sum\limits_{c-d&lt;b-a} c$  和 $\sum\limits_{c-d\ge b-a}d$ 来做，然而一开始没想到怎么做。继续去想链的部分分，发现可以主席树，然后花了 $1.5h$ 过 pt。然后发现可以用线段树合并搬到树上，又花了 $1h$ 过掉 pt。在 THUWC 过 pt 还是挺爽的..</p><p>T2是道通过询问得到树的形态的交互，没仔细看…</p><p>T3是给平面上一些点，定义“好的多边形”为取一些点构成的没有三点共线的凸四边形，求所有“好的多边形”的面积的平均值和方差，对 $998244353$ 取模。点数 $400$ ，值域 $10^9$。有个点在坐标轴上的部分分，然而WA了两个小时..至今不知道哪错了..</p><p>中午回寝室发现两边隔壁寝室分别有 nzhtl1984 和 yyb..然而最后和 lk 面基了。</p><p>下午推了会儿 Kanon。</p><p>去吃晚饭的时候碰见了 pr 和 lk。</p><p>晚上是图像处理题：</p><img src="/2019THUWC-WC冬眠记/png.png"><p>任务一把 $B\times65536+A$ 看成 $A\times65536+B$，调了 20min…</p><p>任务二任务三也写的特别慢，最后任务四没时间了..</p><p>三场加起来没别人一场高，whkwhk</p><p>最后离场的时候发现了这个：</p><img src="/2019THUWC-WC冬眠记/wallpaper.jpg"><p>那两个红红的桌面壁纸是今天的样例…</p><h1 id="Day-3-5"><a href="#Day-3-5" class="headerlink" title="Day 3/-5"></a>Day 3/-5</h1><p>今天应该是我来广二之后最有趣的一天了，本来拍了一堆照片，录了一堆视频，还有一堆录音，好多想说的。可是记（gu）忆（gu）是个好东西，它会帮你筛去那些不重要的，留在脑海中的便是那些真正值得写的吧。</p><h2 id="讲题"><a href="#讲题" class="headerlink" title="讲题"></a>讲题</h2><p>Day2+讲题的时候听到最多的一句话就是“然后就可以跳到”…..</p><p>讲完之后还讲了一些关于图像的其它内容，比如把图片的某些 bit 异或一下来加密：</p><img src="/2019THUWC-WC冬眠记/xorpic.jpg"><p>D1T2的讲题是带动画的，非常有意思，虽然有一些录像，然而还是放几张图片凑合一下吧：</p><img src="/2019THUWC-WC冬眠记/hj1.jpg"><img src="/2019THUWC-WC冬眠记/hj2.jpg"><img src="/2019THUWC-WC冬眠记/hj3.jpg"><p>好像 ctr 还觉得 D1T2 可以放 NOIp T2T3 左右…</p><img src="/2019THUWC-WC冬眠记/5kb.jpg"><p>然后是什么 ”圆梦清华路上有力的援助“什么的…</p><p>反正讲题特别有意思。</p><h2 id="扯皮"><a href="#扯皮" class="headerlink" title="扯皮"></a><del>扯皮</del></h2><p>下午是<del>扯皮</del>介绍THU的时间。</p><p>能发弹幕，所以现场特别欢乐。</p><p>先是介绍了算协，然后介绍了科协，然后是一个去年THUWC签约然后进队今年过来当工作人员的介绍自己这一年的经历，然后是一个人介绍了一下科研相关。</p><p>反正当时感觉超有意思的..然而不太记得算协具体讲了啥了..科协讲的就记得智能体大赛..那位神仙 lzj 讲的倒记得比较清楚。大约是说他签约后写了个光线追踪的工程，然后写了个“二维<del>屁股</del>守望”还现场演示了，之后还去参加了智能体（注意他现在才高三..）。科研相关的<del>讲的非常科研</del>，可能是比较硬核而且互动/玩梗不够，当时现场也不太活跃，弹幕都没什么人刷…</p><h2 id="结营"><a href="#结营" class="headerlink" title="结营"></a>结营</h2><p>感觉贵系招生主任的演讲水平真的超棒..弹幕都能迅速地扯到相关话题并且立刻扯回原本的主线，衔接自然流畅，<del>感觉可以去当主播</del>。</p><p>中途提了个问题，问我们为什么选择OI。</p><p>有回答“不想上文化课”“不想高考_(:з」∠)_”的，有回答“因为兴趣（略略略”“好玩”的，有回答“希望在有生之年解决曾经无法解决的问题”的，也有回答“能结识好多厉害的同学！”的。可能大多数人都是如此吧。因为兴趣开始，时而有宏大的理想，时而又为现实所迫，最后才发现不是自己菜，而是结识了越来越多越来越强的同学们。</p><p>约咕咕了一个小时才发，窝自然是没有的，pr签了，lk签了，yyb签了，<del>nzhtl</del>shadowice1984签了，joker签了，<del>窝认识的都签了</del>。</p><p>一天下来那么多的感想竟然短短几行就写完了呢…遗憾没有拍到的照片也只是和其它拍到了的照片一样没有被放上来。</p><h1 id="Day-4"><a href="#Day-4" class="headerlink" title="Day -4"></a>Day -4</h1><p>今天早上一起来就是愉快的<del>卷铺盖走人</del>，虽然路程比去 THUWC 的时候近（从“苏元”（好像是初中部？）到“二高”），然而要搬被子床单什么的..分了两趟搬QAQ</p><p>然后<del>颓</del>推了<del>一天</del>一会儿Kanon，<del>魔芋的翻译真有意思</del>：</p><img src="/2019THUWC-WC冬眠记/juruo.png"><p>报到的时候有个签名墙，中午和晚上各拍了一张，晚上的比较全（废话），然而中午的拍的比较清楚，所以都放上来好了..</p><img src="/2019THUWC-WC冬眠记/qmq1.jpg"><img src="/2019THUWC-WC冬眠记/qmq2.jpg"><p>看到窝写的 <code>&lt;font color=&quot;grey&quot;&gt;ouuan&lt;/font&gt;</code> 了吗qwq</p><p>晚上是开幕式，掌声最热烈的有两个地方。</p><p>第一个是广二的一个妹子OIer的演讲：“OI到底在学什么？班主任眼中最会修电脑的一批人，旁人眼中前途一片平坦通向美好未来的道路，同班同学眼中那个经常消失不知道去哪的神秘人”，“OI 已不只是一个竞赛，也不只是一门学科，而是存在于群聊中一句句 Orz 和三个百分号里，存在于看到十的九次方加七时的熟悉感以及看到 998244353 时的心里默默的波动中，抑或是一步步化难为简，最终得出正解的喜悦，也可能是自闭场后一个人独自惆怅的身影”。</p><p>第二个有js风险，所以..： <font style="opacity:0">当NOI科学委员会主席念到“WC性价比高”的时候</font>（copy这行）</p><h1 id="Day-3-0"><a href="#Day-3-0" class="headerlink" title="Day -3~0"></a>Day -3~0</h1><p>自闭。</p><p>放几张图好了。</p><img src="/2019THUWC-WC冬眠记/duck.jpg"><img src="/2019THUWC-WC冬眠记/luogu.jpg"><img src="/2019THUWC-WC冬眠记/wxh.jpg"><img src="/2019THUWC-WC冬眠记/nz.jpg"><img src="/2019THUWC-WC冬眠记/wc.jpg"><img src="/2019THUWC-WC冬眠记/o2.jpg"><p>把汐里线（推了游戏之后更喜欢这个翻译了..和香里也有姐妹的感觉）推完了。算是理解了为什么汐里的“名言”是“起きないから奇跡って言うんですよ”，这句话有好几层意思，光是看动画不会明白的吧..也稍微明白了“梦境”与“第三个愿望”是怎么回事了。虽然还是不完全懂..（都是不合理的，好像也没什么“完全懂”）</p><p>第二场营员交流上 yfz 和 mcfx 讲的指令集真好玩。</p><img src="/2019THUWC-WC冬眠记/blddlxl.jpg"><img src="/2019THUWC-WC冬眠记/cccx.jpg"><img src="/2019THUWC-WC冬眠记/elephant.jpg"><h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h1><p>打铁。</p><p>开场先写了 $T1$ $34$ 分，一出考场就听说自己挂了 $8$ 分。</p><p>然后去想 $T3$ 交互，发现不会做，先把强制数据分治的 $13$ 分写了，调了一会儿，继续想 $O(n^2)$。</p><p>感觉不会，这时候已经过去 $3.5h$ 了（鬼知道前面那点分为什么写了这么久..），去玩 $T2$ 提答，前面 $60$ 分还是很好写的，然后作死的想了一会儿第四个点，发现不会，已经只剩 $0.5h$ 了。</p><p>问题是我这个时候还在想 $T3​$ 的 $n^2​$ 怎么写…最后 $15min​$ 的时候决定写个随机询问打表对照，直接随便打了个表都没有检查结果是否两两不同，本来还把原来的代码复制了一份，最后 $1min​$ 写好的时候竟然把代码复制回去编译的..随手输了个数据，一测，既不是 correct 也不是 incorrect，然后就考试结束了..估计连那 $13​$ 分一起没了，爆零了。</p><p>写了的分：$34+60+44=138$，<font color="brown">Cu</font>/<font color="silver">Ag</font>。</p><p>估分 at 考试结束前 $15min$ ：$34+60+13=107$，<font color="brown">Cu</font>。</p><p>估分 of 考试结束前 $15min$ ：$26+60+13=99$，<font color="black">Fe</font>/<font color="brown">Cu</font>。</p><p>考试结束后的估分：$26+60+0=86$，<font color="black">Fe</font>。</p><p>保底估分：$18+38+0=56$，<font color="black">Fe</font>。</p><p>最高可能得分：$26+60+44=130$，<font color="brown">Cu</font>/<font color="silver">Ag</font>。</p><h1 id="Day-1-5"><a href="#Day-1-5" class="headerlink" title="Day 1.5"></a>Day 1.5</h1><p>虽然只有下午+晚上，然而发生了好多事鸭。</p><p>先是 GGF 把选手<del>复读</del>复测鸽到了讲题开始之后..</p><img src="/2019THUWC-WC冬眠记/yzj.jpg"><p>然后窝去看成绩，$T3$ 竟然没挂（$13$），然而 $T2$ 的第二个点莫名挂了..仔细看了半天都是对的，问别人也是对的，群里更有趣了，$O(1)$ 的题目 $O(n)$ 做法有 $0,\,6,\,20$ 分的..然后找到了工作人员，咕了一会儿之后帮我重测过了..然后去申诉，还不知道能不能加回来。讲题没去听..<del>听了也是自闭。</del></p><p><del>OIer真能搞</del>，说搞就搞出来了一个文艺汇演。</p><p>LCA nb！Joker nb！大连24 nb！zzt nb！</p><p>感觉这一晚上更加了解 OI 了。要变得更强，和更强的人在一起，去喜欢正确的事情，再用尽全力去喜欢自己喜欢的事情。</p><p><font color="grey">完整版</font>文艺汇演录制今晚压制出来，大约要回武汉之后才能传到b站上。</p><h1 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h1><p>上午去科学中心冬眠。在车上用 zar 的热点<a href="https://www.bilibili.com/video/av42134227/" target="_blank" rel="noopener">把文艺汇演传了</a>。</p><p>下午听说 $T2$ 重测了，然后窝莫名 <font color="silver">Ag</font> 了.. 这场 WC 好像是暴力 <font color="gold">Au</font>，只要 $127$ 分，然而窝暴力没打满，又疯狂挂分，只好滚粗了.. 另外好像人人都有一枚铁牌。</p><p>睡前看了两集《比宇宙更远的地方》。</p><h1 id="Day-3"><a href="#Day-3" class="headerlink" title="Day 3"></a>Day 3</h1><p>上午看了两集《比宇宙更远的地方》，然后去火车站。发现竟然和 <font color="black"><strong>P</strong></font><font color="red"><strong>inkRabbit</strong></font> 一辆（去火车站的）车。</p><p>中午吃了干拌面（来火车站之前买的），然后有个卖方便面的小哥让我们帮忙把方便面看着，他去上个厕所。$20min$ 后，他从厕所出来，去问 ylh 在玩什么游戏：</p><img src="/2019THUWC-WC冬眠记/fbm&ylh.jpg"><p>本来想对广二说 さようなら 的，想了想应该是 またね 。</p><p>感觉 cl 中渚对朋也说的那句“离开的时候一定要是笑着离开的，不然就再也回不来了”莫名可以用在这里。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;del&gt;又到了 Kanon 的季节呢&lt;/del&gt;，快乐的冬眠生活开始了_(:з」∠)_&lt;/p&gt;
    
    </summary>
    
      <category term="游记" scheme="https://ouuan.github.io/categories/%E6%B8%B8%E8%AE%B0/"/>
    
    
      <category term="CCF系列赛事" scheme="https://ouuan.github.io/tags/CCF%E7%B3%BB%E5%88%97%E8%B5%9B%E4%BA%8B/"/>
    
  </entry>
  
</feed>
