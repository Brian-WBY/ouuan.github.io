<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2018~2019冬 广二避寒记]]></title>
    <url>%2F2018-2019%E5%86%AC-%E5%B9%BF%E4%BA%8C%E9%81%BF%E5%AF%92%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[突然就得知了要去广二集训。 然后知道了这次出去可能要一直到 WC，差不多有 $50$ 天。这样一算这个学期我在武汉的时间可能和外出的时间一样多了。 毕竟是去广州，会暖和很多，也许看不到武汉的雪了。 Day 0Railway在站台上遇到了 Dew、ylh，感觉自己活尸化严重，都是我妈先看见的… 中午吃了泡面（有汤的那种），之前出去都比较近，在火车上不用吃饭，印象中上次吃方便面还是初三的时候在学校里吃的（桶装的泡面，愣是被我当成干拌面吃的）。 在火车上看看手机、看看《大卫·科波菲尔》，当然我现在在写博客。 途中看到了一幅非常………..ok我承认我词穷了。云很低，好像不比火车高多少，环绕在山的周围，山脚下是一些平房，在远处插入了几栋现代化的高楼大厦，有一种违和却奇妙的美感。 赶紧掏出手机，可毕竟只是手机，拍不出云那种虚无缥缈的立体感，匆忙中也没能选好角度，没拍到那几栋高楼大厦。 已经逝去了，经纬度也没有记下来，不能在回来的火车上再览其景，只能用粗浅的文字将其略微地记录下来罢。 Underground进地铁前忘记上厕所了Orz 和 ylh 一起体验了一次换票出站上厕所。 然后是 huangbei 站： 人特别多，特别热。毕竟是来避寒的 Restaurant和广二的教练谈了谈人生，建议我和 ylh 先系统地学知识点，不着急打套题，结果 dew 想先学知识点，我和 ylh 想在广二做题.. 然后就是住宿的事，貌似准备先住两个星期三人间，等 ylh 回去了就去教练家里住（教练一个星期只回家一天）。今晚是先各自和家长住双人间。房号 1216.]]></content>
      <tags>
        <tag>游记</tag>
        <tag>集训</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AtCoder Beginner Contest 115 游记]]></title>
    <url>%2FAtCoder-Beginner-Contest-115%2F</url>
    <content type="text"><![CDATA[之前听教练安利，就来打了场 AtCoder。 -5h比赛地址 一开始看到 “Beginner”的时候我还迟疑了一下，看了下上一场 Beginner 的题目，又在网上搜了一下，想着可以熟悉一下 AtCoder ，就准备打了。 0min咕咕咕 5min咕咕咕咕咕咕 只不过幸好咕咕了，我的模板还没搞好..赶紧新建文件夹 atcoder\AtCoder Beginner Contest 115 ，把 $4$ 个用于 CF 的模板扔进去。 10min开始了！ 用了 $0.1s$ 决定用 switch 而不是 if else 。 用了不知道多久敲完。 没测样例（废话）直接交了。 其实我现在还在想，如果 WJ 的时候我去写 T2 而不是刷新看结果会不会涨个一两名… 12min看了下 $10\times10000&lt;10^9$ 。 用了不知道多久敲完。 测了样例交了。 其实我现在还在想，如果没测样例我会不会再涨个一两名… 14min想了想还是用了快读，毕竟模板里有。 测样例，没写cout&lt;&lt;ans; 。 其实我现在还在想，其实我现在还在想，如果没测样例我会不会掉个十几名。 16min数据范围看起来好小。 等等，$x$ 的范围？ 预处理汉堡的大小。 哦，爆 int 了。 其实我现在还在想，如果模板里有#define int long long我会不会再涨个一两名… 写个函数 work(int a) 处理大小为 $a$ 的汉堡，分类讨论乱搞一下应该就行了。 测样例，#3 看起来好大。 终于可以安心地看 judging 不用担心浪费时间了。 130minBeginner 定级貌似最高 400 点 rating..]]></content>
      <tags>
        <tag>游记</tag>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WC2019 全国模拟赛第二场 T1 题解]]></title>
    <url>%2FWC2019-%E5%85%A8%E5%9B%BD%E6%A8%A1%E6%8B%9F%E8%B5%9B%E7%AC%AC%E4%BA%8C%E5%9C%BA-T1-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[又只会写T1… 题目链接 题意简述给你一个排列 $p_{1..n}$，$a_{1..n}$ 为任意的一个排列，定义 $b[a_i]=a[p_i]$，求总共有多少个不同的 $b_{1..n}$ 。 做法首先，对 $(i,p_i)$ 连边，会得到若干个环。 环上旋转一下（$\forall i\text{ on the cycle : }i\rightarrow p_i$）得到的置换是本质相同的。节点个数相同的环互换一下是本质相同的。 先计算把 $n​$ 个节点分成若干个环的方案数：（用 $siz[i]​$ 表示第 $i​$ 个环的大小，$k​$ 表示环的个数，$sum[i]​$ 表示 $\sum\limits_{j=i}^ksiz[j]​$） $$S_1=\prod\limits_{i=1}^kC_{sum[i]}^{siz[i]}$$ 然后去掉节点个数相同的环互相交换：（用 $num[i]$ 表示节点个数为 $i$ 的环的个数） $$S_2=\frac{S_1}{\prod\limits_{i=1}^nnum[i]!}$$ 然后乘上每个环旋转（旋转造成的不同方案数即固定某个数后剩下的数的排列个数）： $$S_3=S_2\times\prod\limits_{i=1}^k(siz[i]-1)!$$ $S_3$ 就是最终的答案了。 参考代码noi.ac 上最短解（其实计算方式和我是一样的..）： 12345678910111213141516#include&lt;bits/stdc++.h&gt;#define mn 1111111using namespace std;long long n,i=1,s=1,j,x,p=998244353,a[mn],f[mn],v[mn],t[mn];int main()&#123; scanf("%lld",&amp;n); f[0]=f[1]=1; for (;i&lt;=n;i++) scanf("%lld",a+i); for (i=2;i&lt;=n;i++) f[i]=f[p%i]*(p-p/i)%p,(s*=i)%=p; for (i=1;i&lt;=n;i++) if (!v[i]) &#123; for (j=i,x=0;!v[j];x++,j=a[j]) v[j]=1; (s*=f[x]*f[++t[x]]%p)%=p; &#125; printf("%lld",s);&#125; 我自己赛时的辣鸡写法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cctype&gt;using namespace std;int read()&#123; int out=0; char c; while (!isdigit(c=getchar())); for (;isdigit(c);c=getchar()) &#123; out=out*10+c-'0'; &#125; return out;&#125;const int N=1000010;const int M=998244353;void dfs(int u);int c(int a,int b);int n,p[N],dfn[N],low[N],sta[N],dfncnt,top,siz[N],tot,num[N];int x,y,jc[N],inv[N],ans=1,sum;bool ins[N];int main()&#123; int i; n=sum=read(); for (i=1;i&lt;=n;++i) &#123; p[i]=read(); &#125; for (i=1;i&lt;=n;++i) &#123; if (dfn[i]==0) &#123; dfs(i); &#125; &#125; jc[0]=jc[1]=inv[0]=inv[1]=1; for (i=2;i&lt;=n;++i) &#123; inv[i]=(1ll*M*M-1ll*(M/i)*inv[M%i])%M; &#125; for (i=2;i&lt;=n;++i) &#123; jc[i]=(1ll*jc[i-1]*i)%M; inv[i]=(1ll*inv[i-1]*inv[i])%M; &#125; for (i=1;i&lt;=tot;++i) &#123; ans=1ll*ans*c(sum,siz[i])%M; sum-=siz[i]; &#125; for (i=1;i&lt;=n;++i) &#123; ans=1ll*ans*inv[num[i]]%M; &#125; for (i=1;i&lt;=tot;++i) &#123; ans=1ll*ans*jc[siz[i]-1]%M; &#125; cout&lt;&lt;ans; return 0;&#125;int c(int a,int b)&#123; if (a==b||b==0) &#123; return 1; &#125; return 1ll*(1ll*jc[a]*inv[b]%M)*inv[a-b]%M;&#125;void dfs(int u)&#123; dfn[u]=low[u]=++dfncnt; sta[++top]=u; ins[u]=true; if (dfn[p[u]]==0) &#123; dfs(p[u]); low[u]=min(low[u],low[p[u]]); &#125; else if (ins[p[u]]) &#123; low[u]=min(low[u],dfn[p[u]]); &#125; if (low[u]==dfn[u]) &#123; siz[++tot]=1; while (sta[top]!=u) &#123; ++siz[tot]; ins[sta[top--]]=false; &#125; ins[sta[top--]]=false; ++num[siz[tot]]; &#125;&#125; 所以说不要看到环就 tarjan…]]></content>
      <tags>
        <tag>题解</tag>
        <tag>组合数学</tag>
        <tag>noi.ac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客搭建指北]]></title>
    <url>%2Fhexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8C%97%2F</url>
    <content type="text"><![CDATA[折腾了 $3$ 天终于把博客搭建好了…本文会简单介绍一下hexo博客的搭建，并选取一些我自己在配置博客的过程中遇到的问题，说明一下我的解决方案。 实际上，hexo博客的搭建并不难，难搞的是美化，我在这个过程中遇到了很多问题，不可能在这篇博客中全部陈述出来，最重要的还是勤于百度。 本篇博客不完全按照顺序撰写，可以通过页面左边的目录跳转阅读。 博客的搭建先推荐两篇比较好的教程：搭建个人博客-hexo+github详细完整步骤，使用github+Hexo人人都能拥有一个美美的博客。 这部分网上讲的已经比较好了，我在这就简单说一下。 安装软件需要安装的软件有：git，Node.js。 下载安装即可… 本地设置装好之后，在本地创建一个文件夹，下文中称其为“根目录”。 下文中“输入命令”均指在命令行中输入命令（并回车废话），既可以使用 git bash，也可以使用 cmd 或 powershell 。输入命令时若无特别说明都需要 cd 到根目录下。 输入命令 npm install -g hexo 来安装 hexo 。 输入命令 hexo init 来初始化 hexo 。 输入命令 npm install 来安装一些需要的包。 输入命令 hexo s，并在浏览器打开 localhost:4000，在本地预览博客；如果上文步骤进行正确，应该看到一个类似于这样的页面： 注：命令可以缩写，条件是没有开头几个字母相同的其它命令。hexo s 实际上是 hexo server 的缩写；下文中 hexo d 是 hexo deploy 的缩写，hexo g 是 hexo generate 的缩写；hexo clean 不能缩写为 hexo c，因为存在命令 hexo config ，但是可以缩写为 hexo cl 。 按 Ctrl+C 关闭 server 以继续操作。（若出现类似于 终止批处理操作吗(Y/N)? 的提示，输入 y 即可。） 接着安装博客的主题，可以在 hexo 官网 选择主题下载，本篇教程推荐使用 NexT 主题。 在 hexo 官网 点击图片下方蓝色的文字即可打开主题的 GitHub 主页，一般来说，一个主题的 GitHub 主页上是有用于安装的命令以及配置博客的教程的。 如果没有的话（或者即使有也一样），你应该输入命令 git clone 主题的Github主页地址 themes/主题名 。例如：git clone https://github.com/theme-next/hexo-theme-next themes/next 。 当然，你也可以使用默认的 landscape 主题，从而不用额外下载主题。 下载好主题后，用任何一款文本编辑器（记事本也可以），打开根目录下的 _config.yml ，将 theme: landscape 修改为 theme: 你想用的主题名 即可。 配置 GitHub 仓库首先你需要有一个 GitHub 账号。 然后点击右上角你的头像，打开“Your repositories”，点击绿色的按钮“New”。 在”Repository name”一栏填入 yourname.github.io （“yourname”指你的 GitHub ID，比如我就填 ouuan.github.io），”Description”可以随便填也可以不填，然后点绿色的按钮“Create repository”。 将博客上传至 GitHub输入命令 ssh-keygen 来生成 SSH，让你输入东西你就空着，按回车（应该要按三次回车）。 然后用任意的文本编辑器打开 C:\Users\电脑用户名\.ssh\id_rsa.pub（如果装了 vim 可以直接输入命令 vim ~/.ssh/id_rsa.pub），复制里面的内容。 打开 GitHub，点击右上角的头像，打开“Settings”，选择左边的“SSH and GPG keys”，点绿色的按钮“New SSH key”，Title 随便填，下面的 Key 把刚才复制的东西粘贴进去，然后点绿色的按钮“Add SSH key”。过程中可能需要输入密码。 输入命令 ssh -T git@github.com ，若出现 Hi yourname! You&#39;ve successfully authenticated, but GitHub does not provide shell access. 表示 SSH 配置成功。 输入命令 npm install hexo-deployer-git --save 安装 deployer 。 打开根目录下的 _config.yml ，将最后几行改为： 1234deploy: type: git repository: https://github.com/yourname/yourname.github.io.git branch: master 当然”yourname”要改成你的 GitHub ID 。 依次输入命令： 123hexo cleanhexo ghexo d 这一步可能要输入密码。 等几分钟，再用浏览器打开 yourname.github.io ，应该就可以看到你的博客了。（此时别人也可以通过这个网址看到你的博客） 域名的配置实际上，自定义域名基本上没有什么用。但是有一个自己的域名还是一件比较爽的事，会感觉摆脱了束缚（实际上你还是用着 GitHub…）。 域名的获取本篇教程只讲解如何免费获取域名（的 $12$ 个月使用权），当然你也可以通过其它方式购买域名。 打开 Freenom，输入自己想用的域名，点击”Check Availability”，有“Get it now”的就是能用的。 选择好你要的域名后，点右上角的”Checkout”，Period 选择”12 Months @ FREE”，然后点”Continue”，输入邮箱登录或使用其它账号（如 Google 账号）登录（输入邮箱登录经常会出错，而使用其它账号登录需要科学上网）。 DNS 配置我使用的是 cloudfare，（因为在学校搭建的博客，手机没电了，国内的服务商注册都需要短信验证码），还是比较方便的。 先注册一个账号，然后点”Add site”，输入你刚刚获取的域名。 然后进入站点设置里的 DNS 设置，如图添加两条记录： 1185.199.109.153 当然要记得把“yourname”换成你的 GitHub ID。推荐关闭 cdn 服务，即点击一下橙色的云使其变成灰色。 完成后应该是这样的： 连接域名和 DNS回到 Freenom，登录网站，点击右上角的“Services” $\rightarrow$ “My Domains”，找到你刚刚获取的域名，点击 “Manage Domain” $\rightarrow$ “Management Tools” $\rightarrow$ “Nameservers”。 再回到 cloudfare，就在刚刚 DNS 设置的下面，有两个域名： 再回到 Freenom，把这两个域名复制进去，然后点”Change Nameservers”。 连接域名和 GitHub在 hexo 根目录的 source 子目录下新建文件 CNAME（没有后缀名），用文本编辑器打开，输入如下内容： 当然要替换成你获取的域名。 然后再输入命令 hexo d ，过几分钟应该就可以从你获取的域名访问你的博客了。 开启https如果不开启的话，访问 https://你的域名 就会显示警告，访问 http://你的域名 就会显示不安全。 当然如果因为某种原因访问 https://你的域名 已经不会显示警告而且浏览器左上角有绿锁了，就不需要再进行额外的设置了。 其实很简单，浏览器打开 https://github.com/yourname/yourname.github.io/settings ，找到这里： 如果”Enforce HTTPS”前没有打勾，打勾即可。 如果”Enforce HTTPS”前面是灰色的，无法打勾： 删掉”Save”前面的域名，点击”Save”。 重新输入域名，点击”Save”。 重新发布博客（hexo d）。 等待几分钟~几小时，再访问你的博客应该就OK了。 博客的配置与美化根目录下的 _config.yml这部分参考官网教程即可。 主题目录下的 _config.yml主题目录下的 _config.yml 指 \themes\主题名\_config.yml。 这里以 NexT 主题为例，这个主题的 _config.yml 非常完备，修改配置基本上只需删除/添加注释符号 # 以及改变 true/false 即可。 选择 NexT 主题的四种之一12345# Schemesscheme: Muse#scheme: Mist#scheme: Pisces#scheme: Gemini 将想用的主题前的 # 删掉，在 scheme: Muse 前加上 # 即可。 例如： 12345# Schemes#scheme: Muse#scheme: Mist#scheme: Piscesscheme: Gemini 四种主题的预览在 NexT 主题的官网有。 改变网站图标12345favicon: small: /images/favicon-16x16-next.png medium: /images/favicon-32x32-next.png apple_touch_icon: /images/apple-touch-icon-next.png safari_pinned_tab: /images/logo.svg 将你想用的图标放在 \themes\next\source\images 里，然后修改上面的文件名即可。 例如： 123favicon: small: /images/favicon16.png medium: /images/favicon32.png 页脚设置1234567891011121314151617181920212223242526272829303132333435footer: # Specify the date when the site was setup. # If not defined, current year will be used. #since: 2015 # Icon between year and copyright info. icon: # Icon name in fontawesome, see: https://fontawesome.com/v4.7.0/icons # `heart` is recommended with animation in red (#ff0000). name: user # If you want to animate the icon, set it to true. animated: false # Change the color of icon, using Hex Code. color: &quot;#808080&quot; # If not defined, will be used `author` from Hexo main config. copyright: # ------------------------------------------------------------- powered: # Hexo link (Powered by Hexo). enable: false # Version info of Hexo after Hexo link (vX.X.X). version: true theme: # Theme &amp; scheme info link (Theme - NexT.scheme). enable: false # Version info of NexT after scheme info (vX.X.X). version: true # ------------------------------------------------------------- # Beian icp information for Chinese users. In China, every legal website should have a beian icp in website footer. # http://www.miitbeian.gov.cn beian: enable: false icp: icon： © 2018 与用户名之间的图标。（图中 $1$） 图标名称为 Font Awesome 上的图标名称。 powered.enable：为 true 则会显示“由 Hexo 强力驱动”。（图中 $2$） powered.version：为 true 则会显示 Hexo 的版本。（图中 $3$） powered.enable：为 true 则会显示“主题 – NexT.XX”。（图中 $4$） powered.version：为 true 则会显示主题的版本。（图中 $5$） “关于”&amp;”标签”123456789menu: home: / || home about: /about/ || user tags: /tags/ || tags #categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 将需要的项目取消注释即可在侧边栏显示。 如果需要使用“关于”页面，输入命令 hexo new page &quot;about&quot;。 然后在 \source\about\index.md 中就可以编辑“关于”页面了。 可以修改 \source\about\index.md 中的 title 项来显示“关于”而非“about”。 如果需要使用“标签”功能，需要在博文中添加选项 tags ： 如果有多个标签，每行一个，以 - 开头： 1234tags:- 标签1- 标签2- 标签3 如果需要使用“标签”页面，输入命令 hexo new page &quot;tags&quot;。 然后向 source\tags\index.md 中添加一行： 1type: &quot;tags&quot; 站内搜索输入命令 npm install hexo-generator-searchdb --save 安装所需的库。 在根目录下的 _config.yml 的结尾加入： 12345search: path: search.xml field: post format: html limit: 10000 然后在 \themes\next\_config.yml 中，打开 local_search： 12local_search: enable: true 社交网站123456789101112131415# Social Links.# Usage: `Key: permalink || icon`# Key is the link label showing to end users.# Value before `||` delimeter is the target permalink.# Value after `||` delimeter is the name of FontAwesome icon. If icon (with or without delimeter) is not specified, globe icon will be loaded.social: GitHub: https://github.com/ouuan || github 洛谷: https://www.luogu.org/space/show?uid=49742 || code Codeforces: https://www.codeforces.com/profile/ouuan || code b站: https://space.bilibili.com/11067182 || tvsocial_icons: enable: true icons_only: false transition: false 在 social 下每行一个，格式为：名称: 地址 || 图标。 其中，“图标”为 Font Awesome 图标名称，但有些图标是不可用的，而且图标也不全，使用的时候要尝试一下图标是否可用。 12social_icons: enable: false 这样设置可以只显示名称不显示图标。 友情链接（或其它链接）123456789101112# Blog rollslinks_icon: globelinks_title: 友情链接# links_layout: blocklinks_layout: inlinelinks: Dew: https://www.cnblogs.com/ppprseter/ wjyyy: https://www.wjyyy.top/ Sooke: https://www.luogu.org/blog/Sooke/ huyufeifei: https://www.cnblogs.com/huyufeifei/ Rye_Catcher: https://rye-catcher.github.io/ 额冻豆腐: http://www.mayflyyh.com/ links_icon：显示在标题前的图标。 links_title：标题。 links_layout：block 一行一个，inline 一行多个。 links：要显示的链接以及名称。 头像123456789101112# Sidebar Avataravatar: # in theme directory(source/images): /images/avatar.gif # in site directory(source/uploads): /uploads/avatar.gif # You can also use other linking images. url: /images/avatar.jpg # If true, the avatar would be dispalyed in circle. rounded: true # The value of opacity should be choose from 0 to 1 to set the opacity of the avatar. opacity: 1 # If true, the avatar would be rotated with the cursor. rotated: false url：头像地址，留空则不显示头像。 rounded：圆/方头像。 opacity：不透明度。 rotated：随光标旋转。 回到顶部按钮/阅读百分比12345# Back to top in sidebar (only for Pisces | Gemini).b2t: true# Scroll percent label in b2t button.scrollpercent: true 博客首页不显示全文在博文里可以用 &lt;!-- more --&gt; 来标识在首页显示到哪为止。 可以在 \themes\next\_config.yml 里设置到一定字数自动不显示全文： 123456789# Automatically Excerpt. Not recommend.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt: enable: true length: 150# Read more button# If true, the read more button would be displayed in excerpt sectionread_more_btn: true length：不显示全文的字数上限。 read_more_btn： 代码块复制按钮123456789codeblock: # Manual define the border radius in codeblock # Leave it empty for the default 1 border_radius: # Add copy button on codeblock copy_button: enable: true # Show text copy result show_result: true enable：启用复制按钮。 show_result： $\LaTeX$1234567891011# Math Equations Render Supportmath: enable: true # Default(true) will load mathjax/katex script on demand # That is it only render those page who has &apos;mathjax: true&apos; in Front Matter. # If you set it to false, it will load mathjax/katex srcipt EVERY PAGE. per_page: false engine: mathjax #engine: katex enable：启用 $\LaTeX$ 。 per_page：为 true 则只有博文中有 mathjax: true 才会启用 $\LaTeX$，否则每篇博客都会启用 $\LaTeX$ 。 engine：推荐使用 mathjax 。 hexo 博客的 mathjax 和 Markdown 有一些冲突，将在后文专门讲解如何解决冲突。 评论功能由于 gitment 的服务器有一些问题，推荐使用 gitalk： 1234567gitalk: enable: true github_id: yourname repo: yourname.github.io client_id: client_secret: admin_user: yourname 这里需要在 GitHub 新建一个 OAuth App，”Homepage URL”和”Authorization callback URL”填你的域名（如果没有申请域名的话就填 yourname.github.io）： 需要注意的是，如果开启了 https，url 里一定要填 https 而非 http 。 然后将 Client ID 和 Client Secret 填入 \themes\next\_config.yml 中。 访客记录12busuanzi_count: enable: true 书签书签的功能是关闭页面/手动点击书签按钮时，保存这篇博客看到的位置，下次点进这篇博客时继续从这个位置开始。 安装插件：git clone https://github.com/theme-next/theme-next-bookmark.git source/lib/bookmark 更改 \themes\next\_config.yml： 123456789# Bookmark Support# Dependencies: https://github.com/theme-next/theme-next-bookmarkbookmark: enable: true # if auto # - save the reading position when closing the page # - or clicking the bookmark-icon # if manual, only save it by clicking the bookmark-icon save: manual 其它配置博客背景打开 \themes\next\source\css\_custom\custom.styl，输入： 1234body &#123; background-image:url(/images/background.jpg); background-size: cover;&#125; 把背景图片重命名为 background.jpg，放入 \themes\source\images（当然也可以更改background-image:url()）。 background-size: cover; 表示宽度缩放至页面大小。 123456body &#123; background-image:url(/images/background.jpg); background-repeat: no-repeat; background-attachment:fixed; background-size: cover;&#125; 如果修改成这样的话背景图片就不会滚动。 如果不想让博客内容挡住背景，可以设置博客内容的透明度，在 \themes\next\source\css\_custom\custom.styl 中加入下面的代码即可： 123.main-inner &#123; opacity: 0.8;&#125; 博文自定义排序打开 \node_modules\hexo-generator-index\lib\generator.js 。 在末尾添加如下代码： 1234567891011121314151617posts.data = posts.data.sort(function(a, b) &#123;if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排&#125;else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面 return -1;&#125;else if(!a.top &amp;&amp; b.top) &#123; return 1;&#125;else return b.date - a.date; // 都没定义按照文章日期降序排--------------------- 作者：DimpleMe 来源：CSDN 原文：https://blog.csdn.net/qq_32454537/article/details/79482920 版权声明：本文为博主原创文章，转载请附上博文链接！ 在博文设置中加入 top: x 即可，会以 top 为第一关键字，时间为第二关键字排序。若 top 为空则视作 -INF 。 README.md如果想在 https://github.com/yourname/yourname.github.io 让别人看到你的博客的简介，就需要写一个 README.md 放在根目录下的 source 文件夹内。 然而，只是这样的话， README.md 会被渲染成 html，所以需要更改根目录下 _config.yml 的设置： 1skip_render: README.md 博客的写作Markdown 的使用网上有很多 Markdown 的学习资源，我自己是在洛谷剪贴板学会的。 我以前一般都用洛谷剪贴板编辑 Markdown，但 hexo 博客需要在本地编辑 .md 文件，这时普通的文本编辑器就不太方便了。我推荐 Typora 这款软件，还是挺方便的。 撰写博客前的准备打开根目录下的 _config.yml ，将 post_asset_folder 设为 true。 这样就可以把图片放到博客里而不用其它图床了。 然后把 \source\_posts\hello-world.md 删除。 Hexo 博客的撰写新建一篇博客：hexo new &quot;博客名&quot;。 然后等几秒钟，在 \source\_posts 文件夹下，就会生成 博客名 这个文件夹（如果你把 post_asset_folder 设为 true 了）以及 博客名.md。 撰写博客就是编辑 博客名.md。 这个文件的开头是博客的一些设置，可以在 scaffolds\posts.md 中修改默认设置，我的默认设置是： 123456---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;tags: top: --- 然后就可以写 Markdown 格式的文章了。（top 是自定义文章排序，上文中介绍过） 需要注意的是，在洛谷代码块可以不加”cpp”，但在 hexo 上，一定要加上”cpp”： 12345#include &lt;iostream&gt;int main()&#123; cout&lt;&lt;&quot;hello world!&quot;&#125; 12345#include &lt;iostream&gt;int main()&#123; cout&lt;&lt;"hello world!"&#125; 引用本地图片引用链接/网络上的图片格式与普通 Markdown 相同（[链接名称](链接地址) 和 ![图片描述](图片地址)），引用本地图片需要把 post_asset_folder 设为 true ，然后把图片放在与博客同名的文件夹中，然后只用 ![图片描述](图片文件名) 就可以引用了。 在编辑器里显示不出图片是正常的。 还有另一种方式引用图片， 用这种方式引用图片的话，把鼠标放在上面会显示图片描述（上面这张图就是用这种方式引用的）。 只有这种方式引用图片才能在博客首页正常显示图片，否则只能点进博客才能看到图片。 $\LaTeX$ 的使用$\LaTeX$ 概述$\LaTeX$ 主要用于编辑数学公式，十分方便，网上也有很多学习资源，比如：LaTeX数学公式大全。 在支持 $\LaTeX$ 的 Markdown 文档里，使用两个美元符号将 $\LaTeX$ 公式括起来，例如： 1~~QAQ$f_i=\sum\limits_&#123;j=1&#125;^ia_j$f_i=\sum\limits_&#123;j=1&#125;^ia_j~~ QAQ$f_i=\sum\limits_{j=1}^ia_j$f_i=\sum\limits_{j=1}^ia_j 也可以用一对双美元符号使公式居中显示在单行，例如： 123$f_i=1$$$f_i=1$$ $f_i=1$ $$f_i=1$$ 在 Typora 中使用 $\LaTeX$ 需要将设置中的”Markdown 扩展语法”全部勾选。 P.S. $\LaTeX$：\LaTeX 启用 $\LaTeX$在 \themes\next\_config.yml 中将 mathjax 设为 true，然后将 per_page 设为 false 或者在需要启用 \LaTeX 的博文开头加上 mathjax: true 。 解决冲突由于hexo博客中即使是$$内的字符也会被当成 Markdown 渲染，类似于 $f_{f_i}$、$a*b*c$、$[x,y](1&lt;x&lt;y&lt;2)$ 之类的，都会被错误地渲染。 解决这个问题，首先要打开 \node_modules\marked\lib\marked.js，搜索 nolink，应该在 $470$ 行左右。 然后，将这一块修改为： 123456789101112131415var inline = &#123; escape: /^\\([`*\[\]()# +\-.!_&gt;])/, autolink: /^&lt;(scheme:[^\s\x00-\x1f&lt;&gt;]*|email)&gt;/, url: noop, tag: /^&lt;!--[\s\S]*?--&gt;|^&lt;\/?[a-zA-Z0-9\-]+(?:&quot;[^&quot;]*&quot;|&apos;[^&apos;]*&apos;|\s[^&lt;&apos;&quot;&gt;\/\s]*)*?\/?&gt;/, link: /^!?\[(inside)\]\(href\)/, reflink: /^!?\[(inside)\]\s*\[([^\]]*)\]/, nolink: /^!?\[((?:\[[^\[\]]*\]|\\[\[\]]|[^\[\]])*)\]/, strong: /^__([\s\S]+?)__(?!_)|^\*\*([\s\S]+?)\*\*(?!\*)/, em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/, code: /^(`+)\s*([\s\S]*?[^`]?)\s*\1(?!`)/, br: /^ &#123;2,&#125;\n(?!\s*$)/, del: noop, text: /^[\s\S]+?(?=[\\&lt;!\[`*]|\b_| &#123;2,&#125;\n|$)/&#125;; 这样做取消了 _text_ 的斜体意义，但 *text* 仍会被转义为斜体。 解决办法有两种： 放弃使用 * ，全部用 \times 代替或者省略掉。 取消 * 的转义。 推荐使用第一种方法，否则你的博客中就无法使用斜体了。 如果想要使用 * 而放弃斜体： 在 \node_modules\marked\lib\marked.js 中搜索 Renderer.prototype.em ，应该在 $884$ 行左右。 将这一段改为： 123Renderer.prototype.em = function(text) &#123; return &apos;*&apos; + text + &apos;*&apos;;&#125;; 前文提到了，hexo博客中即使是$$内的字符也会被当成 Markdown 渲染，所以类似于 $[x,y](1&lt;x&lt;y&lt;2)$ 的，要在 ] 和 ( 中间加一个空格，就不会被错误地转义了。 博客的发布其实前文提到过，依次输入以下三条命令即可： 123hexo clhexo ghexo d 发布之前还可以执行 hexo s 并在本地使用浏览器打开 localhost:4000 进行预览。 当然也可以使用 hexo g -d 命令。]]></content>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WC2019 全国模拟赛第一场 T1 题解]]></title>
    <url>%2FWC2019-%E5%85%A8%E5%9B%BD%E6%A8%A1%E6%8B%9F%E8%B5%9B%E7%AC%AC%E4%B8%80%E5%9C%BA-T1-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[由于只会T1，没法写游记，只好来写题解了… 题目链接题目大意给你一个数列，每次可以任取两个不相交的区间，取一次的贡献是这两个区间里所有数的最小值，求所有取法的贡献和，对 $10^9+7$ 取模。 数列长度 $2\times 10^5$ ，值域 $1$ ~ $10^9$ 。 $O(n^4)$ 做法预处理区间最小值，枚举选的两个区间。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int M=1000000007;int n,a[60][60],ans;int main()&#123; int i,j,k,l; cin&gt;&gt;n; for (i=1;i&lt;=n;++i) &#123; cin&gt;&gt;a[i][i]; &#125; for (i=1;i&lt;n;++i) &#123; for (j=i+1;j&lt;=n;++j) &#123; a[i][j]=min(a[i][j-1],a[j][j]); &#125; &#125; for (i=1;i&lt;n;++i) &#123; for (j=i;j&lt;n;++j) &#123; for (k=j+1;k&lt;=n;++k) &#123; for (l=k;l&lt;=n;++l) &#123; ans=(ans+min(a[i][j],a[k][l]))%M; &#125; &#125; &#125; &#125; cout&lt;&lt;ans; return 0;&#125; $O(nlogn)$ 做法 warning：接下来的文章里“的”字嵌套情况非常严重，文字叙述比较繁杂，看不懂十分正常，建议看懂一小部分然后自己推。 考虑每个元素作为贡献的区间是哪些，为了把每个区间分给唯一的元素，规定一个区间的贡献是最小值里最靠左的（ e.g. 4 3 2 4 2 2 的贡献是 $3$ 号元素，即最左边的 $2$ ）。所以，可以利用栈在 $O(n)$ 的时间内预处理出每个元素作为贡献的区间的左端点和右端点的范围： 123456789101112131415161718192021222324252627for (i=1;i&lt;=n;++i)&#123; while (top&amp;&amp;a[sta[top]].w&gt;a[i].w) &#123; a[sta[top--]].r=i-1; &#125; sta[++top]=i;&#125;while (top)&#123; a[sta[top--]].r=n;&#125;for (i=n;i&gt;=1;--i)&#123; while (top&amp;&amp;a[sta[top]].w&gt;=a[i].w) &#123; a[sta[top--]].l=i+1; &#125; sta[++top]=i;&#125;while (top)&#123; a[sta[top--]].l=1;&#125; 每个元素作为贡献的区间就是 $[x,y] (l_i\le x\le i\le y\le r_i)$，每个元素作为贡献的区间数就是 $t_i=(i-l_i+1)\times(r_i-i+1)$ 。 然后，将元素按值从大到小排序，就能计算出区间数的后缀和 $suf[i]$，但一个元素的总贡献并不是 $t_i\times suf[i+1]$，因为这些区间可能与当前元素作为贡献的区间相交。 注意到，要想和当前元素作为贡献的区间相交，必须 $[x,y] (l_i\le x\le y\le r_i)$ ，而这样的区间除了当前元素作为贡献的区间，贡献都排在当前元素之后（值比当前元素大或值相等但位置靠后），所以这样的区间除了当前元素作为贡献的区间，都是我们要找的与当前元素作为贡献的区间相交的贡献更靠后的区间。 注：下面这段话中“相交的区间对”指（与当前元素作为贡献的区间相交的贡献更靠后的区间，当前元素作为贡献的区间）这样的一对区间；“相交的区间”指与当前元素作为贡献的区间相交的贡献更靠后的区间。 接下来就要计算相交的区间有多少对。首先，相交的区间不可能跨过当前元素，否则就是当前元素作为贡献的区间；所以，相交的区间要么是 $[x,y] (l_i\le x\le y&lt;i)$ ，要么是 $[x,y] (i&lt;x\le y\le r_i)$。先计算 $[x,y] (l_i\le x\le y&lt;i)$ 与当前元素作为贡献的区间相交的对数，先考虑 $y$ 固定时，个数为 $(r_i-i+1)\times(y-l_i+1)^2$ ，其中：$y-l_i+1$ 既是相交的区间左端点的个数，也是与相交的区间相交的当前元素作为贡献的区间的左端点的个数；$r_i-i+1$ 是与相交的区间相交的当前元素作为贡献的区间的右端点的个数。所以，总数是 $(r_i-i+1)\times\sum\limits_{y=l_i}^{i-1}(y-l_i+1)^2$ ，乘号右边是自然数平方和，可以用公式计算，所以就是 $(r_i-i+1)\times\frac{(i-l_i)\times(i-l_i+1)\times(2i-2l_i+1)}6$ 。$[x,y] (i&lt;x\le y\le r_i)$ 同理，总数为 $(i-l_i+1)\times\frac{(r_i-i)\times(r_i-i+1)\times(2r_i-2i+1)}6$ 。 所以，把相交的总对数减掉就可以了。 参考代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;using namespace std;int read()&#123; int out=0; char c; while (!isdigit(c=getchar())); for (;isdigit(c);c=getchar()) &#123; out=out*10+c-'0'; &#125; return out;&#125;const int N=200010;const int M=1000000007;const int SIX=166666668; //6模1e9+7的逆元struct Node&#123; long long id,w,l,r,t; bool operator&lt;(const Node&amp; b) const &#123; return w&lt;b.w; &#125;&#125; a[N];long long n,suf[N],sta[N],top,ans;int main()&#123; int i; n=read(); for (i=1;i&lt;=n;++i) &#123; a[i].w=read(); a[i].id=i; &#125; for (i=1;i&lt;=n;++i) &#123; while (top&amp;&amp;a[sta[top]].w&gt;a[i].w) &#123; a[sta[top--]].r=i-1; &#125; sta[++top]=i; &#125; while (top) &#123; a[sta[top--]].r=n; &#125; for (i=n;i&gt;=1;--i) &#123; while (top&amp;&amp;a[sta[top]].w&gt;=a[i].w) &#123; a[sta[top--]].l=i+1; &#125; sta[++top]=i; &#125; while (top) &#123; a[sta[top--]].l=1; &#125; for (i=1;i&lt;=n;++i) &#123; a[i].t=(i-a[i].l+1)*(a[i].r-i+1)%M; &#125; sort(a+1,a+n+1); for (i=n;i&gt;=1;--i) &#123; suf[i]=(suf[i+1]+a[i].t)%M; &#125; for (i=1;i&lt;=n;++i) &#123; ans=(ans+(a[i].w*suf[i+1]%M)*a[i].t)%M; ans=(ans-(a[i].id-a[i].l)*(a[i].id-a[i].l+1)%M*(2*a[i].id-2*a[i].l+1)%M*SIX%M*(a[i].r-a[i].id+1)%M*a[i].w%M+M)%M; //重复区间在左 ans=(ans-(a[i].r-a[i].id)*(a[i].r-a[i].id+1)%M*(2*a[i].r-2*a[i].id+1)%M*SIX%M*(a[i].id-a[i].l+1)%M*a[i].w%M+M)%M; //重复区间在右 &#125; cout&lt;&lt;ans; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>noi.ac</tag>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树上背包的上下界优化]]></title>
    <url>%2F%E6%A0%91%E4%B8%8A%E8%83%8C%E5%8C%85%E7%9A%84%E4%B8%8A%E4%B8%8B%E7%95%8C%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[最近做了几道树上背包的题目，很多题目的数据范围都很小，但实际上树上背包有多种方式可以优化到 $O(nm)$ （$n$ 为节点数，$m$ 为体积的值域），比如先序遍历优化（何森《先序遍历用于优化树形背包问题》），求泛化物品的并（徐持衡《浅谈几类背包题》）……经过一番学习，觉得还是上下界优化理解起来最简单，也比较好写，适用范围广，唯一比其它做法复杂的地方就是复杂度分析。 例题讲解这里以一道经典的树上背包作为例题：【数据加强版】选课 直接把我出的数据加强版放上来了..反正题面里有原题链接QAQ 注：本文中用 $a_i$ 代指题面中的 $s_i$ 。 $O(nm^2)$ 做法用 $f_{u,i}$ 表示以 $u$ 为根的子树中选 $i$ 门课的最大得分，那么 $f_{u,i}=\min\limits_{\forall fa[v_j]=u,\sum k_j=i-1}(\sum f[v_j][k_j])+a_u$，而这个转移可以通过背包实现，依次合并每棵子树，每次合并时枚举 $i$ 和 $k_j$ ，$f_{u,i}=\max(f_{u,i},f_{u,i-k_j}+f_{v_j,k_j})$ 。 需要倒序枚举 $i$ 防止状态在转移前被覆盖。否则的话dp数组要多一维。 由于可能是森林，所有没有直接先修课的节点，父亲视为节点 $0$，实际上就要选 $m+1$ 个节点。 参考代码： 1234567891011121314151617void dfs(int u)&#123; f[u][1]=a[u]; int i,j,k,v; for (i=head[u];i;i=nxt[i]) &#123; v=to[i]; dfs(v); for (j=m+1;j&gt;=1;--j) &#123; for (k=1;k&lt;j;++k) &#123; f[u][j]=max(f[u][j],f[u][j-k]+f[v][k]); &#125; &#125; &#125;&#125; 上下界优化注意背包转移的这部分： 1234567for (j=m+1;j&gt;=1;--j)&#123; for (k=1;k&lt;j;++k) &#123; f[u][j]=max(f[u][j],f[u][k]+f[v][j-k]); &#125;&#125; 实际上，这里面有很多状态都是没有意义的： 转移时已经合并了大小之和为 $s$ 的一些子树，那么 $f_{u,i}(i&gt;s)$ 实际上是没有意义的。 $f_{v,i}(i&gt;siz[v])$ 也是没有意义的。 $f_{u,i}(i&gt;m)$ 是没有作用的。 所以，可以对 $j$ 和 $k$ 的枚举范围进行优化： 12345678910111213141516171819void dfs(int u)&#123; siz[u]=1; f[u][1]=a[u]; int i,j,k,v; for (i=head[u];i;i=nxt[i]) &#123; v=to[i]; dfs(v); for (j=min(m+1,siz[u]+siz[v]);j&gt;=1;--j) &#123; for (k=max(1,j-siz[u]);k&lt;=siz[v]&amp;&amp;k&lt;j;++k) &#123; f[u][j]=max(f[u][j],f[u][j-k]+f[v][k]); &#125; &#125; siz[u]+=siz[v]; &#125;&#125; 复杂度分析可以参考这篇博客。 形象的解释每个点对都只会在 $lca$ 处合并一次，所以总的复杂度是 $O(n^2)$ 的。 这个解释很简洁，需要自己意会一下.. 严格？证明令 $T_u$ 为处理子树 $u$ 的总用时，那么： $\begin{aligned}T_u&amp;=\left(\sum\limits_{\forall fa[v_i]=u}T_{v_i}\right)+t_u\\\\t_u&amp;=1+(1+siz[v_1])\times siz[v_1]+(1+siz[v_1]+siz[v_2])\times siz[v_2]+\cdots+siz[u]\times siz[v_k]\\&amp;=1+\sum\limits_{\forall fa[v_i]=u}siz[v_i]\times(siz[u]+1)\\&amp;=siz[u]^2\end{aligned}$ 对于叶子节点 $u$ ，$T(u)=1$ ，是 $O(siz[u]^2)$ 的。 对于儿子都是叶子节点的节点 $u$，由于平方和小于和平方，$\sum\limits_{\forall fa[v_i]=u}T_{v_i}$ 也是 $O(siz[u]^2)$ 的。 可以这样递归地说明，对于任意节点 $u$ ，$\sum\limits_{\forall fa[v_i]=u}T_{v_i}$ 都是 $O(siz[u]^2)$ 的。 又因为 $t(u)$ 是 $O(siz[u]^2)$ 的，$T(u)$ 就是 $O(siz[u]^2)$ 的。 所以解决整个问题就是 $O(n^2)$ 的。 严格！证明枚举过程中还要对 $m$ 取 min ，所以应该是这样的： $\begin{aligned}t_u&amp;=1+\min(m,1+siz[v_1])\times \min(m,siz[v_1])+\min(m,1+siz[v_1]+siz[v_2])\times \min(m,siz[v_2])+\cdots+\min(m,siz[u])\times \min(m,siz[v_k])\\&amp;\le m\times siz[u]\end{aligned}$ 所以，$t(u)$ 是 $O(\min(siz[u],m)\times siz[u])$ 的。 对于 $siz[u]\le m$，$T(u)$ 是 $O(siz[u]^2)$ 的。 对于 $siz[u]&gt;m$，$\sum\limits_{\forall fa[v_i]=u,siz[v_i]\le m}T_{v_i}$ 是 $O\left(\left(\sum\limits_{\forall fa[v_i]=u,siz[v_i]\le m}siz[v_i]\right)^2\right)$ 的；$\sum\limits_{\forall fa[v_i]=u,siz[v_i]&gt;m}T_{v_i}$ 是 $O\left(m\times\sum\limits_{\forall fa[v_i]=u,siz[v_i]&gt;m}siz[v_i]\right)$ 的；所以，$T(u)$ 是 $O(m\times siz[u])$ 的。 所以，解决整个问题是 $O(nm)$ 的。 其它例题【数据加强版】道路重建 dl代码我出的那两道数据加强版略有些毒瘤..（$n\times m\le 10^8$） 大约需要这样写： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;void dfs(int u);void add(int u,int v);const int N=100010;int head[N],nxt[N],to[N],cnt;int n,m,a[N],f[100000010],siz[N];int main()&#123; int i,k; scanf("%d%d",&amp;n,&amp;m); for (i=1;i&lt;=n;++i) &#123; scanf("%d%d",&amp;k,a+i); add(k,i); &#125; dfs(0); printf("%d",f[m+1]); return 0;&#125;void add(int u,int v)&#123; nxt[++cnt]=head[u]; head[u]=cnt; to[cnt]=v;&#125;void dfs(int u)&#123; siz[u]=1; f[u*(m+2)+1]=a[u]; int i,j,k,v; for (i=head[u];i;i=nxt[i]) &#123; v=to[i]; dfs(v); for (j=min(m+1,siz[u]+siz[v]);j&gt;=1;--j) &#123; for (k=max(1,j-siz[u]);k&lt;=siz[v]&amp;&amp;k&lt;j;++k) &#123; f[u*(m+2)+j]=max(f[u*(m+2)+j],f[u*(m+2)+j-k]+f[v*(m+2)+k]); &#125; &#125; siz[u]+=siz[v]; &#125;&#125; 关于另一种 $O(nm)$ 做法一开始我在洛谷发了篇选课的题解，然后没过… 那篇题解用的是求泛化物品的并（徐持衡《浅谈几类背包题》） 虽然说洛谷好像还没有上下界优化的题解..但最近好几篇题解没过审，都不太想在洛谷发题解了…]]></content>
      <tags>
        <tag>算法</tag>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIp2018提高组游记]]></title>
    <url>%2FNOIp2018%E6%8F%90%E9%AB%98%E7%BB%84%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Day1T1 积木大赛NOIp2013D2T1…..看到的时候我还以为我记错了，以为原题是一次可以随便加，这题只能加一，出考场后查了下发现一模一样。 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int N=100010;int n,d[N],ans;int main()&#123; int i; scanf("%d",&amp;n); for (i=1;i&lt;=n;++i) &#123; scanf("%d",d+i); if (d[i]&gt;d[i-1]) &#123; ans+=d[i]-d[i-1]; &#125; &#125; cout&lt;&lt;ans; return 0;&#125; T2 货币系统去掉可以由其它货币拼成的货币，这个结论倒是很快猜到了。但由于xkdyh留下的阴影，一开始我还写了个exgcd…幸好大样例比较良心，有一组数据是三种货币拼成另一种。然后再仔细一看，发现是个完全背包… 简单证明一下： 结论：对于一个没有任何一种货币可以由系统内其它货币拼成的货币系统 $(n,A)$，与其等价的货币系统 $(m,B)$ 只能是 $(n,A)$ 自身或者加上一些能由 $(n,A)$ 表示的数。 若 $A\not\subseteq B$，任取 $t\in (A-B)$，那么在 $B$ 中必然有一些元素能够拼成 $t$，而这些元素在 $A$ 中必然有不能表示的（否则与 $A$ 中没有任何一种货币可以由系统内其它货币拼成矛盾），而存在 $(m,B)$ 能表示而 $(n,A)$ 不能表示的数与 $(n,A),(m,B)$ 等价矛盾，不成立。 若 $B$ 中有 $(n,A)$ 所不能表示的元素，依然与 $(n,A),(m,B)$ 等价矛盾，不成立。 所以命题得证。 排个序然后完全背包去掉能被系统内其它货币表示的货币即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int t,n,a[110],maxx;bool f[25010];int main()&#123; int i,j,ans; scanf("%d",&amp;t); while (t--) &#123; scanf("%d",&amp;n); ans=n; maxx=0; for (i=1;i&lt;=n;++i) &#123; scanf("%d",a+i); maxx=max(maxx,a[i]); &#125; sort(a+1,a+n+1); memset(f,false,sizeof(f)); f[0]=true; for (i=1;i&lt;=n;++i) &#123; if (f[a[i]]) &#123; --ans; continue; &#125; for (j=0;j+a[i]&lt;=maxx;++j) &#123; if (f[j]) &#123; f[j+a[i]]=true; &#125; &#125; &#125; printf("%d\n",ans); &#125; return 0;&#125; T3 赛道修建看到这题就想起了ylh当时跟我一个房间的时候切掉的 CF div.2 E，但赛后发现不一样… 出考场得知dew、ylh都切掉了这题，然而我只写了直径、链和菊花图的 $55$ 分…凉凉凉 Day2T1 旅行一开始看错题了，以为是最小字典序生成树，还在想为什么 $m$ 这么小..然后仔细一看题，发现一条边只能回溯时重复经过，也就是最后得到的序列只能是个dfs序…数据范围很小，所以就枚举断边写了个 $O(n^2)$ 的，预处理边排序。然后出考场听一堆dalao在那说各种 $O(nlogn)$，$O(n)$ 做法…都不会QAQ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;const int N=5010;void dfs(int u);int n,m,cut,a[N][N],tot,e[N][2];bool vis[N],used[N]; //used用于对m个字典序取min，若used[i]=true说明断开第 i 条边时一定不是答案vector&lt;int&gt; g[N];int main()&#123; int i,j,u,v,minn; scanf("%d%d",&amp;n,&amp;m); for (i=0;i&lt;m;++i) &#123; scanf("%d%d",&amp;u,&amp;v); e[i][0]=u; e[i][1]=v; g[u].push_back(v); g[v].push_back(u); &#125; for (i=1;i&lt;=n;++i) &#123; sort(g[i].begin(),g[i].end()); &#125; if (n==m) &#123; for (cut=0;cut&lt;m;++cut) &#123; memset(vis,false,sizeof(vis)); tot=0; dfs(1); if (tot&lt;n) &#123; used[cut]=true; &#125; &#125; for (i=1;i&lt;=n;++i) &#123; minn=n; for (j=0;j&lt;m;++j) &#123; if (!used[j]&amp;&amp;a[j][i]&lt;minn) &#123; minn=a[j][i]; &#125; &#125; for (j=0;j&lt;m;++j) &#123; if (a[j][i]&gt;minn) &#123; used[j]=true; &#125; &#125; printf("%d",minn); if (i&lt;n) &#123; putchar(' '); &#125; &#125; &#125; else &#123; cut=m; dfs(1); for (i=1;i&lt;=n;++i) &#123; printf("%d",a[m][i]); if (i&lt;n) &#123; putchar(' '); &#125; &#125; &#125; return 0;&#125;void dfs(int u)&#123; if (vis[u]) &#123; return; &#125; vis[u]=true; a[cut][++tot]=u; int v,i; for (i=0;i&lt;g[u].size();++i) &#123; v=g[u][i]; if ((u!=e[cut][0]||v!=e[cut][1])&amp;&amp;(u!=e[cut][1]||v!=e[cut][0])) &#123; dfs(v); &#125; &#125;&#125; T2 填数游戏要是数据范围给到 $10^9$ 我就不会在考场上推半天了…一开始想了好久怎么 $O(nm)$ dp，虽然没想出来怎么做，但发现了暴力怎么写：一种方案合法等价于：对于每个点，它右边的点先往下再往右的路径小于它下面的点先往右再往下的路径。因为这两条路径分别是一个点向右走后最大的路径和向下走后最小的路径。然后打了个表，发现 $(n,m)=(n,n+1)\times 3^{m-n-1} (n\ge 2,m\ge n+1)$。于是开始跑 $(8,9)$ ，跑到11:50 还没跑出来…幸好发现了 $(n,n)$ 和 $(n,n+1)$ 之间也有一定的规律，把 $(8,9)$ 算出来了… 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const long long Ans[9][10]=&#123;&#123;0,0,0,0,0,0,0,0,0,0&#125;, &#123;0,0,0,0,0,0,0,0,0,0&#125;, &#123;0,4,12,36,0,0,0,0,0,0&#125;, &#123;0,8,36,112,336,0,0,0,0,0&#125;, &#123;0,16,108,336,912,2688,0,0,0,0&#125;, &#123;0,32,324,1008,2688,7136,21312,0,0,0&#125;, &#123;0,64,972,3024,8064,21312,56768,170112,0,0&#125;, &#123;0,128,2916,9072,24192,63936,170112,453504,1360128,0&#125;, &#123;0,256,8748,27216,72576,191808,510336,1360128,3626752,10879488&#125;&#125;; //其实有一部分表是不必要（没有意义）的... const long long M=1000000007;long long n,m,ans=1;int main()&#123; int i; cin&gt;&gt;n&gt;&gt;m; if (n&gt;m) &#123; swap(n,m); &#125; if (n==1) &#123; for (i=30;i&gt;=0;--i) &#123; ans=ans*ans%M; if (m&amp;(1&lt;&lt;i)) &#123; ans=ans*2%M; &#125; &#125; cout&lt;&lt;ans; &#125; else &#123; if (m&lt;=n+1) &#123; cout&lt;&lt;Ans[n][m]; return 0; &#125; else &#123; for (i=30;i&gt;=0;--i) &#123; ans=ans*ans%M; if ((m-n-1)&amp;(1&lt;&lt;i)) &#123; ans=ans*3%M; &#125; &#125; cout&lt;&lt;ans*Ans[n][n+1]%M; &#125; &#125; return 0;&#125; T3 保卫王国据说是ddp…考场上先10min写了44分（一开始还以为是55分Orz），然后看了下，觉得B1挺可写的，更新向上的链貌似就可以了，但最后没调出来.. Day7上（tui）了一个星期的whk..个鬼啊，三天在考期中，就上了两天whk。感觉从零开始的whk没有想象中那么恐怖… 一周不让去机房，一到家就在洛谷上测了一下公布的代码.其它题都和预估的一样，D2T1可能会被卡常，洛谷上开了O2最慢点 $0.9s$ ，而且不用vector好像也过不了，不知道是不是洛谷上内存开小了的原因… D1T3大众AC题我爆菊（花图）了… 幸好菊花图的数据分治放在了最后面，还有 $40$ 分。发现自己傻了，不知道为什么会认为只有最短的两条边可以拼在一起，其它边都只能自成一条道……. 听说D2T3不用ddp，还是我太菜了… 估分：$100+100+40+88/100+100+44=472/484$ Day10GGF咕咕咕，然而我把两个T3写了一下.. D1T3真的好简单…二分答案，check的时候dfs处理每棵子树并返回块数最多时最大剩余，具体就是把子树返回值排个序，双指针配对得到最多块数，然后从最后一个配对的左指针开始往前这么多个依次配对，最后看剩下的没配对的里面最大的是多少。（第二天换成CCF数据发现做法挂了）处理子树的时候二分返回值不影响复杂度但能保证正确性。 D2T3做法挺有趣的..倍增题做少了，估计做多了就比较套路了…预处理出 $f[u][1],f[u][0],g[u][1],g[u][0]$，分别代表选/不选 $u$ 时 子树 $u$ 答案，选/不选 $u$ 时 $u$ 往上（整颗树减去子树 $u$）的答案。倍增处理出祖先 $fa[u][i]$ 表示 $u$ 的 $2^i$ 祖先，用 $bz[u][i][0/1][0/1]$ 表示子树 $fa[u][i]$ 除去子树 $u$ ，其中 $u$ 选/不选，$fa[u][i]$ 选/不选的答案，可以在dfs预处理 f 和 g 的同时算出 $bz[u][0][0/1][0/1]$ ，然后 $bz[u][i][a][b]=\min(bz[u][i-1][a][0]+bz[fa[u][i-1]][i-1][0][b],bz[u][i-1][a][1]+bz[fa[u][i-1]][i-1][1][b])$ 。计算答案的时候如果是祖先关系直接倍增计算链上答案，再加上子树的 f 和 祖先上方的 g；否则倍增到 $lca$ 计算路径上的答案，两棵子树以及 $lca$ 上方的答案就是对应的 $f$ 和 $g$ 。然后写到 $22:15$，交上去 $68$ 分，回寝室…ab相邻的 $16$ 分真的好简单，不用倍增，考场上应该写出来的… Day11刚到学校听说自己 $480$ ，还在想8700k这么强，能把我的 travel 卡成 $96$ … 中午一看是 $489$，数据真有趣…D1T3 隔壁原 $95$ 变成 $80$，我昨天A的变成 $90$ 了，考场写的还骗到了 $5$ 分（$45$）…8700k天下第一！ Day25咕咕咕咕咕，$\mathrm{CN} 329$。]]></content>
      <tags>
        <tag>游记</tag>
        <tag>CCF系列赛事</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二维莫队解题报告]]></title>
    <url>%2F%E4%BA%8C%E7%BB%B4%E8%8E%AB%E9%98%9F%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[我写的莫队教程 其实这是一道bzoj上的题（bzoj2639，貌似是权限题，反正我看不了），在YALI做模拟赛的时候遇到了. 然后在网上查到了几篇关于这道题的博客，都和我的做法略有不同… 题目大意给你一个 $r*c$ 的矩阵，每个点有一个颜色， $m$ 个询问，每次询问一个子矩阵内，每种颜色出现次数的平方和。 $r,c\le 200,m\le 100000$ 做法简述首先我们要明白，莫队究竟在干什么。 莫队其实就是几个指针在那跳来跳去，每跳一步都需要一定的时间，通过对询问排序使得指针跳的总次数尽量小。 所以，这题中询问为 $(x_1,y_1,x_2,y_2)$ ，也就是四个指针在那跳，分别分块再排序就可以了，即： 123456789//为避免和cmath库中的y0y1重名，下文中代码内的x1,y1,x2,y2都用x,y,xx,yy代替struct Query&#123; int x,y,xx,yy,id; bool operator&lt;(Query&amp; b) &#123; return x/B==b.x/B?(y/B==b.y/B?(xx/B==b.xx/B?yy&lt;b.yy:xx&lt;b.xx):y&lt;b.y):x&lt;b.x; //B为分块大小 &#125;&#125; q[M]; 答案更新一般的莫队都是 $O(1)$ 更新答案的，然而这题是 $O(n)$ （用 $n$ 代表 $r,c$ ） 更新。 移动指针的时候，把一排一起修改。 需要注意的是，8个while的顺序如果排列不当在某些情况下会导致答案出错，所以最好是将所有add都放在del前面（实际上有多种排列顺序都可以在不进行“反操作”的情况下保证答案正确，所有add放在del前面只是其中一种），或者是对“反区间”进行“反操作”。 所谓“反区间”，如：修改 $x_1$ 指针时，本应进行add操作，而此时$y_1&gt;y_2+1$，那么就要将 $(y_2,y_1)$ 这个开区间内的所有点进行del。 while的排列顺序得当可以使“反区间”不可能出现。 “反操作”参考代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697while (x&lt;q[i].x)&#123; for (j=y;j&lt;=yy;++j) &#123; del(a[x][j]); &#125; for (j=yy+1;j&lt;y;++j) &#123; add(a[x][j]); &#125; ++x;&#125;while (y&lt;q[i].y)&#123; for (j=x;j&lt;=xx;++j) &#123; del(a[j][y]); &#125; for (j=xx+1;j&lt;x;++j) &#123; add(a[j][y]); &#125; ++y;&#125;while (xx&gt;q[i].xx)&#123; for (j=y;j&lt;=yy;++j) &#123; del(a[xx][j]); &#125; for (j=yy+1;j&lt;y;++j) &#123; add(a[xx][j]); &#125; --xx;&#125;while (yy&gt;q[i].yy)&#123; for (j=x;j&lt;=xx;++j) &#123; del(a[j][yy]); &#125; for (j=xx+1;j&lt;x;++j) &#123; add(a[j][yy]); &#125; --yy;&#125;while (x&gt;q[i].x)&#123; --x; for (j=y;j&lt;=yy;++j) &#123; add(a[x][j]); &#125; for (j=yy+1;j&lt;y;++j) &#123; del(a[x][j]); &#125;&#125;while (y&gt;q[i].y)&#123; --y; for (j=x;j&lt;=xx;++j) &#123; add(a[j][y]); &#125; for (j=xx+1;j&lt;x;++j) &#123; del(a[j][y]); &#125;&#125;while (xx&lt;q[i].xx)&#123; ++xx; for (j=y;j&lt;=yy;++j) &#123; add(a[xx][j]); &#125; for (j=yy+1;j&lt;y;++j) &#123; del(a[xx][j]); &#125;&#125;while (yy&lt;q[i].yy)&#123; ++yy; for (j=x;j&lt;=xx;++j) &#123; add(a[j][yy]); &#125; for (j=xx+1;j&lt;x;++j) &#123; del(a[j][yy]); &#125;&#125;out[q[i].id]=ans; 分块大小具体计算清楚非常复杂，这里只是估算一下. $x_1$ 指针的移动次数为 $O(mB)$，$y_2$ 指针的移动次数渐进复杂度中含有 $O\left(\frac{n^4}{B^3}\right)$，取 $mB=\frac{n^4}{B^3}$，得到 $B=nm^{-\frac{1}{4}}$ 总时间复杂度为 $O(mlogm+n^2m^{\frac{3}{4}})$ 反正这样的分块大小实测比 $\sqrt{n}$ 优秀…有兴趣的话可以严谨地算一算（如果发现我这个估算有问题可以直接在这篇博客下评论） 初始子矩阵任意一个空矩阵就可以了，如 $x_1=y_1=1,x_2=y_2=0$ 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N=210;const int M=100010;void add(int x);void del(int x);int r,c,m,B,a[N][N],lsh[N*N],tot,cnt[N*N],ans,out[M];struct Query&#123; int x,y,xx,yy,id; bool operator&lt;(Query&amp; b) &#123; return x/B==b.x/B?(y/B==b.y/B?(xx/B==b.xx/B?yy&lt;b.yy:xx&lt;b.xx):y&lt;b.y):x&lt;b.x; &#125;&#125; q[M];int main()&#123; int i,j,x=1,y=1,xx=0,yy=0; cin&gt;&gt;r&gt;&gt;c&gt;&gt;m; B=pow(r*c,0.5)/pow(m,0.25)+1.0; for (i=1;i&lt;=r;++i) &#123; for (j=1;j&lt;=c;++j) &#123; cin&gt;&gt;a[i][j]; lsh[tot++]=a[i][j]; //这题要离散化 &#125; &#125; sort(lsh,lsh+tot); tot=unique(lsh,lsh+tot)-lsh; for (i=1;i&lt;=r;++i) &#123; for (j=1;j&lt;=c;++j) &#123; a[i][j]=lower_bound(lsh,lsh+tot,a[i][j])-lsh; &#125; &#125; for (i=0;i&lt;m;++i) &#123; cin&gt;&gt;q[i].x&gt;&gt;q[i].y&gt;&gt;q[i].xx&gt;&gt;q[i].yy; q[i].id=i; &#125; sort(q,q+m); for (i=0;i&lt;m;++i) &#123; while (x&gt;q[i].x) &#123; --x; for (j=y;j&lt;=yy;++j) &#123; add(a[x][j]); &#125; &#125; while (xx&lt;q[i].xx) &#123; ++xx; for (j=y;j&lt;=yy;++j) &#123; add(a[xx][j]); &#125; &#125; while (y&gt;q[i].y) &#123; --y; for (j=x;j&lt;=xx;++j) &#123; add(a[j][y]); &#125; &#125; while (yy&lt;q[i].yy) &#123; ++yy; for (j=x;j&lt;=xx;++j) &#123; add(a[j][yy]); &#125; &#125; while (x&lt;q[i].x) &#123; for (j=y;j&lt;=yy;++j) &#123; del(a[x][j]); &#125; ++x; &#125; while (xx&gt;q[i].xx) &#123; for (j=y;j&lt;=yy;++j) &#123; del(a[xx][j]); &#125; --xx; &#125; while (y&lt;q[i].y) &#123; for (j=x;j&lt;=xx;++j) &#123; del(a[j][y]); &#125; ++y; &#125; while (yy&gt;q[i].yy) &#123; for (j=x;j&lt;=xx;++j) &#123; del(a[j][yy]); &#125; --yy; &#125; out[q[i].id]=ans; &#125; for (i=0;i&lt;m;++i) &#123; cout&lt;&lt;out[i]&lt;&lt;endl; &#125; return 0;&#125;void add(int x)&#123; ans=ans+2*cnt[x]+1; ++cnt[x];&#125;void del(int x)&#123; ans=ans-2*cnt[x]+1; --cnt[x];&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018国庆YALI集训游记]]></title>
    <url>%2F2018%E5%9B%BD%E5%BA%86YALI%E9%9B%86%E8%AE%AD%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[想了想，像之前那样简略地叙述题意和做法，根本没讲清楚，没有任何意义，还不如写写自己的感受。 感觉YALI真的是一所挺不错的学校吧。总是能有一机房的julao轮番吊打你，总是能有集训队的奆佬来给你出dltm、给你讲题。每天放学回酒店的路上还能看到操场上一群目测是田径队之类的同学在努力地训练着。到处都洋溢着「青春」的氛围，反倒是老师见得很少（或许是国庆的缘故吧..）。YALI在我心中已经不止是那个在OIerDb的“全国信息学竞赛学校排名2018”上排名第一的学校了。 这几天去掉失误基本上都能排在前 $20$，但其他julao也会失误，所以是不存在“如果没有失误”的… 既然生在了弱省，就更要把眼光放在省外。OIerDb学校排行榜$rank1\sqrt{}$，OIerDb学校排行榜$rank5\sqrt{}​$。 虽然写的很短，还是比之前几乎什么都没写好吧. ———————————————以上于7号上午——————————————— 到了YALI的学生们返校的下午，YALI变得和外高没什么两样了…或许是那些国庆还在学校的人们让我看到了YALI不同的一面吧.]]></content>
      <tags>
        <tag>游记</tag>
        <tag>集训</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[莫队、带修莫队、树上莫队详解]]></title>
    <url>%2F%E8%8E%AB%E9%98%9F%E3%80%81%E5%B8%A6%E4%BF%AE%E8%8E%AB%E9%98%9F%E3%80%81%E6%A0%91%E4%B8%8A%E8%8E%AB%E9%98%9F%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[这几天学习了莫队算法，试着写一篇比较详细的莫队教程吧… 普通莫队简介莫队是一种基于分块思想的离线算法，用于解决区间问题，适用范围如下： 只有询问没有修改。 允许离线。 在已知询问 $[l,r]$ 答案的情况下可以 $O(1)$ 得到 $[l,r-1],[l,r+1],[l-1,r],[l+1,r]$ 的答案。 满足以上三个条件就可以在 $O(n\sqrt{m}+mlogm)$ 的时间复杂度下得到每个询问的解。 算法思想莫队的精髓就在于通过对询问进行排序，并把询问的结果作为下一个询问求解的基础，使得暴力求解的复杂度得到保证。 上文中“适用范围”的第三点“在已知询问 $[l,r]$ 答案的情况下可以 $O(1)$ 得到 $[l,r-1],[l,r+1],[l-1,r],[l+1,r]$ 的答案”即是“把询问的结果作为下一个询问求解的基础”的方法。 例：[国家集训队]小Z的袜子 在这题中，用 $cnt_i$ 表示当前处理的区间内颜色为i的袜子出现的次数，用 $\mathrm{len}$ 表示当前处理的区间的长度，用 $x$ 表示新增的那只袜子的颜色。 以已知区间 $[l,r]$ 的答案求解区间 $[l,r+1]$ 为例。分别处理分子和分母： 分母为任选两只袜子的组合总数，原先是 $\frac{\mathrm{len}(\mathrm{len}-1)}{2}$，现在是 $\frac{\mathrm{len}(\mathrm{len}+1)}{2}$，增加了 $\mathrm{len}$ 。 分子为两只袜子颜色相同的组合总数，比原来增加了 $cnt_x$，即新增的这只袜子和原本就在当前区间内的相同颜色的袜子的组合。 因此，将一只颜色为x的袜子计入答案的函数就可以写出来了： 12345678//fz代表分子，fm代表分母void add(int x)&#123; fz+=cnt[x]; ++cnt[x]; fm+=len; ++len;&#125; 同理可以写出将一只颜色为x的袜子移出答案的函数： 1234567void del(int x)&#123; --cnt[x]; fz-=cnt[x]; --len; fm-=len;&#125; 于是，我们就可以得到一个暴力的算法：用 $l$ 和 $r$ 分别记录当前区间的两个端点，然后用下面这段代码来更新答案（q[i].l,q[i].r代表正在处理的询问的两个端点，col[p]代表第 $p$ 只袜子的颜色）： 12345678910111213141516while (l&gt;q[i].l)&#123; add(col[--l]);&#125;while (r&lt;q[i].r)&#123; add(col[++r]);&#125;while (l&lt;q[i].l) &#123; del(col[l++]);&#125;while (r&gt;q[i].r)&#123; del(col[r--]);&#125; 然而，这个算法的时间复杂度是 $O(nm)$ 的（因为最坏情况下每次 $l$ 和 $r$ 两个指针都要走 $O(n)$ 的距离，而一共有 $m$ 次询问），和暴力完全一样甚至跑的更慢。 别忘了，之前我说过，莫队的精髓就在于通过对询问进行排序，使得暴力求解的复杂度得到保证。 我们的目的是使 $l$ 和 $r$ 两个指针走过的总距离尽量的小，这时候就要用到分块的思想了。 把整个区间 $[1,n]$ 分成若干块，以询问的左端点所在块为第一关键字，以询问的右端点大小为第二关键字，对询问进行排序，那么： 对于同一块的询问，$l$ 指针每次最多移动块的大小，$r$ 指针的移动则是单调的，总共移动最多 $n$ 。 对于不同块的询问，$l$ 每次换块时最多移动两倍块的大小， $r$ 每次换块时最多移动 $n$ 。 总结：（用 $B$ 表示块的大小）$l$ 指针每次移动 $O(B)$，$r$ 指针每块移动 $O(n)$ 。 所以： $l$ 的移动次数最多为询问数×块的大小，即 $O(mB)$ 。 $r$ 的移动次数最多为块的个数×总区间大小，即 $O(n^2/B)$ 。 因此，总移动次数为 $O(mB+n^2/B)$ 。 没错，这就是个双勾函数，所以当 $B=\sqrt{\frac{n^2}{m}}$ 即 $\frac{n}{\sqrt{m}}$ 时复杂度最小，为 $O(n\sqrt{m})$ 。 剩下的最后一个问题：初始的当前区间是什么？ 只要任意指定一个空区间就好了，如 $l=1,r=0$ 。 所以，整个莫队算法就可以概括为： 将询问记录下来。 以 $\frac{n}{\sqrt{m}}$ 为块的大小，以询问的左端点所在块为第一关键字，以询问的右端点大小为第二关键字，对询问进行排序。 暴力处理每个询问。 输出答案。 总的复杂度为 $O(n\sqrt{m}+mlogm)$ 。 P.S. 网上很多教程说分块大小取 $\sqrt{n}$ 最优，复杂度为 $O(n\sqrt{n})$，这是不严谨的，当n、m差别较大时使用 $\sqrt{n}$ 作为分块大小效率会明显偏低。 例题代码[国家集训队]小Z的袜子 AC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N=50010;void add(int x);void del(int x);int gcd(int a,int b);int n,m,B,fz,fm,len,col[N],cnt[N],ans[N][2];struct Query&#123; int l,r,id; bool operator&lt;(Query&amp; b) &#123; return l/B==b.l/B?r&lt;b.r:l&lt;b.l; &#125;&#125; q[N];int main()&#123; int i,l=1,r=0,g; cin&gt;&gt;n&gt;&gt;m; B=n/sqrt(m); for (i=1;i&lt;=n;++i) &#123; cin&gt;&gt;col[i]; &#125; for (i=0;i&lt;m;++i) &#123; cin&gt;&gt;q[i].l&gt;&gt;q[i].r; q[i].id=i; &#125; sort(q,q+m); for (i=0;i&lt;m;++i) &#123; if (q[i].l==q[i].r) &#123; ans[q[i].id][0]=0; ans[q[i].id][1]=1; continue; &#125; while (l&gt;q[i].l) &#123; add(col[--l]); &#125; while (r&lt;q[i].r) &#123; add(col[++r]); &#125; while (l&lt;q[i].l) &#123; del(col[l++]); &#125; while (r&gt;q[i].r) &#123; del(col[r--]); &#125; g=gcd(fz,fm); ans[q[i].id][0]=fz/g; ans[q[i].id][1]=fm/g; &#125; for (i=0;i&lt;m;++i) &#123; printf("%d/%d\n",ans[i][0],ans[i][1]); &#125; return 0;&#125;void add(int x)&#123; fz+=cnt[x]; ++cnt[x]; fm+=len; ++len;&#125;void del(int x)&#123; --cnt[x]; fz-=cnt[x]; --len; fm-=len;&#125;int gcd(int a,int b)&#123; return b==0?a:gcd(b,a%b);&#125; 其它例题小B的询问 带修莫队前面说过，普通的莫队只能解决没有修改的问题，那么带修改的问题怎么解决呢？带修莫队就是一种支持单点修改的莫队算法。 算法简介还是对询问进行排序，每个询问除了左端点和右端点还要记录这次询问是在第几次修改之后（时间），以左端点所在块为第一关键字，以右端点所在块为第二关键字，以时间为第三关键字进行排序。 暴力查询时，如果当前修改数比询问的修改数少就把没修改的进行修改，反之回退。 需要注意的是，修改分为两部分： 若修改的位置在当前区间内，需要更新答案（del原颜色，add修改后的颜色）。 无论修改的位置是否在当前区间内，都要进行修改（以供add和del函数在以后更新答案）。 ##分块大小的选择以及复杂度证明 （用 $B$ 表示分块大小，$c$ 表示修改个数，$q$ 表示询问个数，l块表示以 $l/B$ 分的块，r块表示以 $r/B$ 分的块，每个l块包含 $n/B$ 个r块） 对于时间指针 $now$：对于每个r块，最坏情况下会移动 $c$，共有 $\left(\frac{n}{B}\right)^2$ 个r块，所以总移动次数为 $\frac{cn^2}{B^2}$ 。 对于左端点指针 $l$ ：l块内移动每次最多 $B$，换l块每次最多 $2B$，所以总移动次数为 $O(qB)$ 。 对于右端点指针 $r$：r块内移动每次最多 $B$，换r块每次最多 $2B$，所有l块内移动次数之和为 $O(qB)$；换l块时最多移动 $n$，总的换l块时移动次数为 $O\left(\frac{n^2}{B}\right)$；所以总的移动次数为 $O\left(qB+\frac{n^2}{B}\right)$ 。 所以：总移动次数为 $O\left(\frac{cn^2}{B^2}+qB+\frac{n^2}{B}\right)$ 。 由于一般的题目都不会告诉你修改和询问分别的个数，所以统一用 $m$ 表示，即 $O\left(\frac{mn^2}{B^2}+mB+\frac{n^2}{B}\right)$ 。 那么 $B$ 取多少呢…Mathematica告诉我大约是这个： 所以还是不要纠结带修莫队的最佳分块大小好了…视作 $n=m​$ 的话，就可以得到总移动次数为 $O\left(\frac{n^3}{B^2}+nB+\frac{n^2}{B}\right)​$，那么 $B=n^{\frac{2}{3}}​$ 时取最小值 $O\left(n^{\frac{5}{3}}\right)​$ 。 所以：带修莫队的渐进时间复杂度为 $O\left(nlogn+n^{\frac{5}{3}}\right)$ （视作 $n=m$）。 例题代码这次就不详细分析例题了，直接上代码。 [国家集训队]数颜色 AC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;void add(int x);void del(int x);void modify(int x,int ti); //这个函数会执行或回退修改ti（执行还是回退取决于是否执行过，具体通过swap实现），x表明当前的询问是x，即若修改了区间[q[x].l,q[x].r]便要更新答案int n,m,B,cnt[1000010],a[50010],ans,ccnt,qcnt,now,out[50010];struct Change&#123; int p,col;&#125; c[50010];struct Query&#123; int l,r,t,id; bool operator&lt;(Query&amp; b) &#123; return l/B==b.l/B?(r/B==b.r/B?t&lt;b.t:r&lt;b.r):l&lt;b.l; &#125;&#125; q[50010];int main()&#123; int i,l=2,r=1; char type[10]; cin&gt;&gt;n&gt;&gt;m; B=pow(n,0.66666); for (i=1;i&lt;=n;++i) &#123; cin&gt;&gt;a[i]; &#125; for (i=1;i&lt;=m;++i) &#123; scanf("%s",type); if (type[0]=='Q') &#123; ++qcnt; cin&gt;&gt;q[qcnt].l&gt;&gt;q[qcnt].r; q[qcnt].t=ccnt; q[qcnt].id=qcnt; &#125; else &#123; ++ccnt; cin&gt;&gt;c[ccnt].p&gt;&gt;c[ccnt].col; &#125; &#125; sort(q+1,q+qcnt+1); for (i=1;i&lt;=qcnt;++i) &#123; while (l&gt;q[i].l) &#123; add(a[--l]); &#125; while (r&lt;q[i].r) &#123; add(a[++r]); &#125; while (l&lt;q[i].l) &#123; del(a[l++]); &#125; while (r&gt;q[i].r) &#123; del(a[r--]); &#125; while (now&lt;q[i].t) &#123; modify(i,++now); &#125; while (now&gt;q[i].t) &#123; modify(i,now--); &#125; out[q[i].id]=ans; &#125; for (i=1;i&lt;=qcnt;++i) &#123; cout&lt;&lt;out[i]&lt;&lt;endl; &#125; return 0;&#125;void add(int x)&#123; if (cnt[x]++==0) &#123; ++ans; &#125;&#125;void del(int x)&#123; if (--cnt[x]==0) &#123; --ans; &#125;&#125;void modify(int x,int ti)&#123; if (c[ti].p&gt;=q[x].l&amp;&amp;c[ti].p&lt;=q[x].r) &#123; del(a[c[ti].p]); add(c[ti].col); &#125; swap(a[c[ti].p],c[ti].col); //下次执行时必定是回退这次操作，直接互换就可以了 &#125; 其它例题CF940F Machine Learning 树上莫队其实，莫队算法除了序列还可以用于树。复杂度同序列上的莫队（不带修 $O(n\sqrt{m}+mlogm)$，带修 $O\left(nlogn+n^{\frac{5}{3}}\right)$）。 例题：[WC2013]糖果公园 分块方式这里需要看一道专门为树上莫队设计的题目 [SCOI2005]王室联邦。 用这道题所要求的方式进行分块，并用后文的方式更新答案，就能保证复杂度（复杂度分析见后文）。 那么如何满足每块大小在 $[B,3B]$，块内每个点到核心点路径上的所有点都在块内呢？ 这里先提供一种构造方式，再予以证明： dfs，并创建一个栈，dfs一个点时先记录初始栈顶高度，每dfs完当前节点的一棵子树就判断栈内（相对于刚开始dfs时）新增节点的数量是否&gt;=B，是则将栈内所有新增点分为同一块，核心点为当前dfs的点，当前节点结束dfs时将当前节点入栈，整个dfs结束后将栈内所有剩余节点归入已经分好的最后一个块。 参考代码： 12345678910111213141516171819202122232425262728void dfs(int u,int fa)&#123; int t=top; for (int i=head[u];i;i=nxt[i]) &#123; int v=to[i]; if (v!=fa) &#123; dfs(v,u); if (top-t&gt;=B) &#123; ++tot; while (top&gt;t) &#123; bl[sta[top--]]=tot; &#125; &#125; &#125; &#125; sta[++top]=u;&#125;dfs(1,0);while (top)&#123; bl[sta[top--]]=tot;&#125; 如果你看懂了这个方法的话，每块大小&gt;=B是显然的，下面证明为何每块大小&lt;=3B： 对于当前节点的每一棵子树： 若未被分块的节点数&gt;B，那么在dfs这棵子树的根节点时就一定会把这棵子树的一部分分为一块直至这棵子树的剩余节点数&lt;=B，所以这种情况不存在。 若未被分块的节点数=B，这些节点一定会和栈中所有节点分为一块，栈中之前还剩 $[0,B-1]$ 个节点，那么这一块的大小为 $[B,2B-1]$ 。 若未被分块的节点数&lt;B，当未被分块的节点数+栈中剩余节点数&gt;=B时，这一块的大小为 $[B,2B-1)$，否则继续进行下一棵子树。 对于dfs结束后栈内剩余节点，数量一定在 $[1,B]$ 内，而已经分好的每一块的大小为 $[B,2B-1]$，所以每块的大小都在 $[B,3B)$ 内（我看有的博客写的剩余节点数量在 $[1,B+1]$ 内，所以最后一块可能达到 $3B$…然而我觉得最多 $3B-1$啊QAQ）。 修改方式所谓“修改”，就是由询问 $(cu,cv)$ 更新至询问 $(tu,tv)$ 。 如果把两条路径上的点全部修改..显然是和暴力一样的嘛！ 这里直接给出结论好了… （下文中 $T(u,v)$ 表示 $u$ 到 $v$ 的路径上除 $lca(u,v)$ 外的所有点构成的集合，$S(u,v)$ 代表u到v的路径，$xor$ 表示集合对称差（就跟异或差不多）） 两个指针 $cu,cv$ （相当于序列莫队的 $l,r$ 两个指针）， $ans$记录$T(cu,cv)$ 的答案，$vis$ 数组记录每个节点是否在 $T(cu,cv)$ 内； 由 $T(cu,cv)$ 更新至 $T(tu,tv)$ 时，将 $T(cu,tu)$ 和 $T(cv,tv)$ 的 $vis$ 分别取反，并相应地更新答案； 将答案记录到 $out$ 数组（离线后用于输出那个）时对 $lca(cu,cv)$ （此时的 $cu,cv$ 已更新为上一步中的 $tu,tv$） 的 $vis$ 取反并更新答案，记录完再改回来（因为lca比较烦，所以就这样做了QAQ）。 第二步证明如下： $\quad\,T(cu,cv) xor T(tu,tv)$ $=[S(cu,root) xor S(cv,root)] xor [S(tu,root) xor S(tv,root)]$ （lca及以上相消） $=[S(cu,root) xor S(tu,root)] xor [S(cv,root) xor S(tv,root)]$ （交换律、结合律） $=T(cu,tu) xor T(cv,tv)$ 之所以要把 $T(cu,cv) xor T(tu,tv)$ 转化成 $T(cu,tu) xor T(cv,tv)$，是因为这样的话就能通过对询问排序来保证复杂度。 关于单点修改树上莫队的单点修改和序列莫队类似，唯一不同就是，修改后是否更新答案通过vis数组判断。 复杂度分析每块大小在 $[B,3B)$，所以两点间路径长度也在 $[B,3B)$，块内移动就是 $O(B)$ 的；编号相邻的块位置必然是相邻的，所以两块间路径长度也是 $O(B)$；然后就和序列莫队的复杂度分析类似了… 例题代码[WC2013]糖果公园 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N=100010;void pathmodify(int u,int v); //将T(u,v)取反并更新答案void opp(int x); //将节点x取反并更新答案void modify(int ti); //进行或回退修改tiint lca(int u,int v);void dfs(int u); //进行分块并记录dep数组、f数组（用于求lca、两点间路径）void add(int u,int v);int head[N],nxt[N&lt;&lt;1],to[N&lt;&lt;1],cnt;int n,m,Q,B,bl[N],tot,V[N],W[N],a[N],sta[N],top,qcnt,ccnt,dep[N],f[20][N],num[N],now;long long ans,out[N];bool vis[N];struct Query&#123; int u,v,t,id; bool operator&lt;(Query&amp; y) &#123; return bl[u]==bl[y.u]?(bl[v]==bl[y.v]?t&lt;y.t:bl[v]&lt;bl[y.v]):bl[u]&lt;bl[y.u]; &#125;&#125; q[N];struct Change&#123; int p,x;&#125; c[N];int main()&#123; int i,j,u,v,lc,type; cin&gt;&gt;n&gt;&gt;m&gt;&gt;Q; B=pow(n,0.666); for (i=1;i&lt;=m;++i) &#123; cin&gt;&gt;V[i]; &#125; for (i=1;i&lt;=n;++i) &#123; cin&gt;&gt;W[i]; &#125; for (i=1;i&lt;n;++i) &#123; cin&gt;&gt;u&gt;&gt;v; add(u,v); add(v,u); &#125; dfs(1); for (i=1;i&lt;=16;++i) &#123; for (j=1;j&lt;=n;++j) &#123; f[i][j]=f[i-1][f[i-1][j]]; &#125; &#125; while (top) &#123; bl[sta[top--]]=tot; &#125; for (i=1;i&lt;=n;++i) &#123; cin&gt;&gt;a[i]; &#125; for (i=0;i&lt;Q;++i) &#123; cin&gt;&gt;type; if (type==0) &#123; ++ccnt; cin&gt;&gt;c[ccnt].p&gt;&gt;c[ccnt].x; &#125; else &#123; cin&gt;&gt;q[qcnt].u&gt;&gt;q[qcnt].v; q[qcnt].t=ccnt; q[qcnt].id=qcnt; ++qcnt; &#125; &#125; sort(q,q+qcnt); u=v=1; for (i=0;i&lt;qcnt;++i) &#123; pathmodify(u,q[i].u); pathmodify(v,q[i].v); u=q[i].u; v=q[i].v; while (now&lt;q[i].t) &#123; modify(++now); &#125; while (now&gt;q[i].t) &#123; modify(now--); &#125; lc=lca(u,v); opp(lc); out[q[i].id]=ans; opp(lc); &#125; for (i=0;i&lt;qcnt;++i) &#123; cout&lt;&lt;out[i]&lt;&lt;endl; &#125; return 0;&#125;void pathmodify(int u,int v)&#123; if (dep[u]&lt;dep[v]) &#123; swap(u,v); &#125; while (dep[u]&gt;dep[v]) &#123; opp(u); u=f[0][u]; &#125; while (u!=v) &#123; opp(u); opp(v); u=f[0][u]; v=f[0][v]; &#125;&#125;void opp(int x)&#123; if (vis[x]) &#123; ans-=1ll*V[a[x]]*W[num[a[x]]--]; &#125; else &#123; ans+=1ll*V[a[x]]*W[++num[a[x]]]; &#125; vis[x]^=1;&#125;void modify(int ti)&#123; if (vis[c[ti].p]) &#123; opp(c[ti].p); swap(a[c[ti].p],c[ti].x); opp(c[ti].p); &#125; else &#123; swap(a[c[ti].p],c[ti].x); &#125;&#125;int lca(int u,int v)&#123; if (dep[u]&lt;dep[v]) &#123; swap(u,v); &#125; int i; for (i=0;i&lt;=16;++i) &#123; if ((dep[u]-dep[v])&amp;(1&lt;&lt;i)) &#123; u=f[i][u]; &#125; &#125; if (u==v) &#123; return u; &#125; for (i=16;i&gt;=0;--i) &#123; if (f[i][u]!=f[i][v]) &#123; u=f[i][u]; v=f[i][v]; &#125; &#125; return f[0][u];&#125;void dfs(int u)&#123; int t=top; for (int i=head[u];i;i=nxt[i]) &#123; int v=to[i]; if (v!=f[0][u]) &#123; f[0][v]=u; dep[v]=dep[u]+1; dfs(v); if (top-t&gt;=B) &#123; ++tot; while (top&gt;t) &#123; bl[sta[top--]]=tot; &#125; &#125; &#125; &#125; sta[++top]=u;&#125;void add(int u,int v)&#123; nxt[++cnt]=head[u]; head[u]=cnt; to[cnt]=v;&#125; 莫队的扩展其实莫队可以扩展到高维，参见二维莫队解题报告。 更一般地，若 $Q(x_1,x_2,\cdots,x_k)$ 为一个询问，$\forall i\in[1,k]$，$x_i$ 的规模都为 $n$，可以在时间 $\mathrm{T}$ 内求解 $Q(x_1,x_2,\cdots,x_i\pm 1,\cdots,x_n)$，共有 $m$ 个询问，那么就可以在 $O\left(kmlogm+nTm^\frac{k-1}{k}\right)$ 的时间复杂度下离线求解。 （蒟蒻的大胆猜想而已..并没有严格证明） To be finished:回滚莫队（只增莫队）..（有时间再填坑吧Orz）]]></content>
      <tags>
        <tag>莫队</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[好用的网站]]></title>
    <url>%2F%E5%A5%BD%E7%94%A8%E7%9A%84%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[$\text{图床}$ $\text{几何}$ $\text{图论}$ $\text{函数}$ $\text{找规律}$ $\text{矩阵运算}$ $\text{在线汇编编译器}$ $\mathrm{C++}$ $\LaTeX\text{公式大全}​$ $\LaTeX\text{公式奆全}$ $\text{.tex}$教程 $\text{OI Wiki}$ $\text{Wolfram Alpha}$ $\text{oier数据库}$]]></content>
      <tags>
        <tag>收藏</tag>
      </tags>
  </entry>
</search>
