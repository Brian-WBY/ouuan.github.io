<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[n方过百万 暴力碾标算——指令集优化的基础使用]]></title>
    <url>%2Fn%E6%96%B9%E8%BF%87%E7%99%BE%E4%B8%87-%E6%9A%B4%E5%8A%9B%E7%A2%BE%E6%A0%87%E7%AE%97%E2%80%94%E2%80%94%E6%8C%87%E4%BB%A4%E9%9B%86%E4%BC%98%E5%8C%96%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[感谢 yfz 和 mcfx 在 WC 营员交流上的分享！ 然而只看那个课件来学习指令集好像略有困难..所以我来分享一下我自学一晚上的成果。 希望能帮助大家暴力过题，考场上再也写不出标算。 你问学了指令集之后如何保持对标算的信仰？当然是每天%神橡树 ok不扯了，进入正题… 注：本文省略了无数个 unsigned，请自行把所有 int 视作 unsigned int，把所有 long long 视作 unsigned long long。 适用范围环境不要尝试在OI竞赛中使用指令集优化。 只适用于提供资瓷的OJ，具体列表参照营员交流ppt： sse2，avx 什么的都是指令集的名字。 作用适用于方便对连续内存空间进行批量处理的题目。大约可以视作每 $8$ 个 int 为一个分块，块内进行赋值、修改等操作常数为 $1$，也就实现了常数/=$8$。当然如果是 long long 就只能除以四。 具体使用pragma&amp;include12345#pragma GCC optimize("Ofast,no-stack-protector,unroll-loops,fast-math")#pragma GCC target("sse,sse2,sse3,ssse3,sse4.1,sse4.2,avx,avx2,popcnt,tune=native")#include &lt;immintrin.h&gt;#include &lt;emmintrin.h&gt; 第一行是优化，如果你都用指令集了当然是能优化尽量优化。 第二行是告诉编译器你要使用指令集。 后面两个头文件是 C++ 将指令集封装成了函数，这样就不用在代码中内联汇编了。 变量类型大约有 __m256i __m256 __m256d 三种，分别存储 long long，float 和 double，实际上 __m256i 也可以用来存储 int。 实际使用的时候由于__m256i打起来比较麻烦，建议typedef __m256i oak 指令使用可以在一个神奇的网站查需要的指令，左边选指令集以及指令类型，右边是指令，点开指令可以查看函数原型以及伪代码。 这里列几条常用指令： __m256i _mm256_set_epi32 (int e7, int e6, int e5, int e4, int e3, int e2, int e1, int e0)：参数是八个数，也就是一个“分块”里的数，注意是逆序的。返回值是一个含这八个数的“分块”。 __m256i _mm256_set_epi64x (__int64 e3, __int64 e2, __int64 e1, __int64 e0)：和上面一样，只不过是 $64$ 位整数，也就是 long long。 __m256i _mm256_set1_epi32 (int a)：相当于 _mm256_set_epi32(a,a,a,a,a,a,a,a)。 __m256i _mm256_add_epi32 (__m256i a, __m256i b)：把两个“分块”的对应位置分别相加，返回结果。 __m256i _mm256_cmpeq_epi32 (__m256i a, __m256i b)：判断两个“分块”的对应位置是否相等，若相等则返回的“分块”对应位置是 0xffffffff，否则是 0。 __m256i _mm256_cmpgt_epi32 (__m256i a, __m256i b)：和上面一样，只不过比较符是大于而不是相等。 __m256i _mm256_and_si256 (__m256i a, __m256i b)：返回两个“分块”的按位与，可以配合上面两条比较指令来使用。 访问数据可以直接通过下标访问： 123456789101112131415161718#include &lt;cstdio&gt;#pragma GCC optimize("Ofast,no-stack-protector,unroll-loops,fast-math")#pragma GCC target("sse,sse2,sse3,ssse3,sse4.1,sse4.2,avx,avx2,popcnt,tune=native")#include &lt;immintrin.h&gt;#include &lt;emmintrin.h&gt;typedef __m256i oak;oak a;int main()&#123; a=_mm256_set_epi32(1,2,3,4,5,6,7,8); printf("%d",a[2]); return 0;&#125; 你们可以猜猜这个的结果是什么。 答案是..4。 为什么呢，首先 _mm256_set_epi32 的参数是逆序的，所以实际上存储的数顺序是 8,7,6,5,4,3,2,1。其次，__m256i 类型是存储 long long 的，所以直接通过下标访问实际上是在访问 long long，如果 cout&lt;&lt;a[2]就会返回 12884901892（$3\times2^{32}+4$）。所以，这句话实际上是在 printf(&quot;%d&quot;,12884901892ll);。 那么如何访问 int（甚至 short，如果题目允许这样就可以常数除以 $16$）呢？ 其实搞个指针就可以了： 123a=_mm256_set_epi32(1,2,3,4,5,6,7,8);int *b=(int *)&amp;a;printf("%d",b[2]); 这样子的输出就是 $6$ 了。 用这种方法就可以方便地处理序列问题了： 12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#pragma GCC optimize("Ofast,no-stack-protector,unroll-loops,fast-math")#pragma GCC target("sse,sse2,sse3,ssse3,sse4.1,sse4.2,avx,avx2,popcnt,tune=native")#include &lt;immintrin.h&gt;#include &lt;emmintrin.h&gt;typedef __m256i oak;int A[80],*b;oak a[10],x;int main()&#123; int i; for (i=0;i&lt;80;++i) scanf("%d",A+i); for (i=0;i&lt;10;++i) a[i]=_mm256_set_epi32(A[i*8+7],A[i*8+6],A[i*8+5],A[i*8+4],A[i*8+3],A[i*8+2],A[i*8+1],A[i*8]); b=(int *)&amp;a; x=_mm256_set1_epi32(233); for (i=0;i&lt;10;++i) a[i]=_mm256_add_epi32(a[i],x); for (i=0;i&lt;80;++i) printf("%d ",b[i]); return 0;&#125; 上面是一个简单的示例，读入 $80$ 个数，然后输出它们加上 $233$ 的结果。 例题这种东西为什么还会有例题啊。 教主的魔法，这题比较简单（废话暴力当然简单）。 【模板】线段树1，这题其实是最简单的，然而由于 dl 出题人把值域搞到了 long long，常数只能除以四，需要卡卡常，多提交几次才能过。 [Ynoi2018]五彩斑斓的世界，神司怒艹lxl标算的课件例题。 Simple Tree，这个还要树剖，只不过也还好，神司是直接内嵌汇编写的，没有测过用函数能不能过.. 然后以教主的魔法为例讲一下代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;cstdio&gt;#pragma GCC optimize("Ofast,no-stack-protector,unroll-loops,fast-math")#pragma GCC target("sse,sse2,sse3,ssse3,sse4.1,sse4.2,avx,avx2,popcnt,tune=native")#include &lt;immintrin.h&gt;#include &lt;emmintrin.h&gt;const int N=1000010;typedef __m256i oak;int n,m,tot,*a;oak A[N&gt;&gt;3];char op[10];void modify(int l,int r,int x)&#123; while ((l&amp;7)&amp;&amp;l&lt;r) a[l++]+=x; //处理左边不是整块的部分，和分块的处理方法是一样的 if (l==r) return; while (r&amp;7) a[--r]+=x; //处理右边不是整块的部分 if (l==r) return; oak t=_mm256_set1_epi32(x); //剩下的部分整块加上x for (l&gt;&gt;=3,r&gt;&gt;=3;l&lt;=r;++l) A[l]=_mm256_add_epi32(A[l],t);&#125;int query(int l,int r,int x)&#123; int out=0; while ((l&amp;7)&amp;&amp;l&lt;r) out+=int(a[l++]&gt;=x); //处理左边不是整块的部分 if (l==r) return out; while (r&amp;7) out+=int(a[--r]&gt;=x); //处理右边不是整块的部分 if (l==r) return out; oak t=_mm256_set1_epi32(1); //这个1是每个大于等于x的数的贡献 oak ans=_mm256_set1_epi32(0); //这个ans是用来存答案的 oak cp=_mm256_set1_epi32(x-1); //这个是用来比较的，题目中是大于等于，所以和x-1比较 for (l&gt;&gt;=3,r&gt;&gt;=3;l&lt;r;++l) ans=_mm256_add_epi32(ans,_mm256_and_si256(t,_mm256_cmpgt_epi32(A[l],cp))); //这个意会一下，作用是数当前块有几个大于x-1的数 for (int i=0;i&lt;4;++i) out+=(ans[i]&amp;0xffffffff)+(ans[i]&gt;&gt;32); //最后统计答案，因为ans[i]是一个long long，所以要前32位和后32位分别统计 return out;&#125;int main()&#123; int i,l,r,x,aa[8]; scanf("%d%d",&amp;n,&amp;m); while (n) //读入比较鬼畜，需要每次读8个数 &#123; if (n&lt;8) &#123; for (i=0;i&lt;n;++i) scanf("%d",aa+i); n=0; &#125; else &#123; for (i=0;i&lt;8;++i) scanf("%d",aa+i); n-=8; &#125; A[tot++]=_mm256_set_epi32(aa[7],aa[6],aa[5],aa[4],aa[3],aa[2],aa[1],aa[0]); &#125; a=(int*)&amp;A; while (m--) &#123; scanf("%s%d%d%d",op,&amp;l,&amp;r,&amp;x); if (op[0]=='M') modify(l-1,r,x); else printf("%d\n",query(l-1,r,x)); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>黑科技</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019THUWC/WC冬眠记]]></title>
    <url>%2F2019THUWC-WC%E5%86%AC%E7%9C%A0%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[又到了 Kanon 的季节呢，快乐的冬眠生活开始了_(:з」∠)_ Day 0/-8Day -1 被归到广二避寒记去了.. 上午在水群的时候吐槽 Kanon 结局，然后和 yfz 稍微聊了一下，又看了看萌百，的确あゆ就是和风子、面码差不多的思念体鸭，为什么我会觉得看不懂呢..大约不止是因为あゆ的存在？ 下午只做了一道题…淀粉质竟然能把 solve(rt) 写成 solve(v)…退役吧 然后不知道为什么去试了下自走棋，连续垫底了一下午，算是明示WC垫底了。 RNG居（guo）然连跪两把，继续暗示窝WC的命运。 Day 1/-7上午报到的时候没能和 BlackRedRabbit 面基，只不过试机的时候发现brr就在窝左边的左边的左边，然后就愉快的面基了。 哦对了，晚上跟 jxl 还有 hyf 住。好像是女生宿舍？被子是粉的..然而听说A栋住女生，B栋住男生，感觉不会特意反过来.. 试机题目T1（听别人说）是AC自动机上dp..本来就不会，AC自动机也几年没打过了…T2是THUSC2017提答，于是没做试机题，打了个NTT，还没一遍打对..丢人。 下午果然垫底了..T1一个简单 $12$ 分暴力打了 1h，然后 T2 的第一档 $26$ 分写了 1h 才过大（xiao）样例，交上去没过pt..然后又调了 50min，还是没过..然后花了 0.5h 重构代码，莫名其妙就过了..T3看了看感觉第一档都不会，回去看T2，T2是答对第一问有 $60\%$ 的分那种，发现自己会另一档的 $27\times60\%$，然后又花了 50min 写.. 最后 30min 的时候发现 T2 还有 $43\times 60\%$ 可以用可持久化并查集写，然而时间不够了… T2 第一次写了 6K…（菜死了连 6K 都没写过..）也是第一次用 namespace 写 subtask。 1234if (r&lt;=10&amp;&amp;c&lt;=10)&#123; using namespace subtask1;&#125; 这样写真的爽_(:з」∠)_ T1是道期望，输出格式是最简分数，而且不约分的话数会非常大。当时我就在想为什么不取模..然后出考场听说 T1 的式子有一堆可以约分，剩下的形式特别简单… 我的游记好像经常不写题目就瞎bb..还是简单说一下吧。 T1：给两个数列 $a_{1..n},\,b_{1..n}$，多组询问，每次给 $c,\,d,\,e,\,f$ ，需要从 $a_{c..d}$ 和 $b_{e..f}$ 中各取 $d-c+1$ 个数然后两两配对，问配对的两个数相同的对数的期望，以最简分数形式输出。$n$ 和询问数好像大约是 $10^5$ ，因为只打了第一档暴力不记得了… T2：一个网格图，有两种连边： 一整行/列两两连边。 一些特殊点之间两两连边。 有 $m$ 个被破坏的点，在某个时间点（每个被破坏的点独立）被修好，修好前所在行/列的整行/列连边不会连上。每个特殊点在某个时间点（每个特殊点独立）前不会和其它特殊点连边。多组询问问两个点联通的最早时间点，以及这个时间点的最短路。 网格大小 $10^5$，询问数 $10^6$，被破坏的点数和特殊点数都是 $2\times 10^5$。 T3：求有多少个不同的长度不超过 $m$ 的 区间取min操作序列 使得进行最后一次操作后原序列恰好变成指定序列。值域和序列大小一样都是 $n$。$n$ 好像是一两百的样子，$m$ $10^9$。 数据范围可能记错了，题意可能简述成看不懂了..QAQ就这样吧。 晚上开营仪式，先是清华系主任自吹，然后是广二校长继续吹+拉拢和THU的关系，然后请一个现在在THU的NOI2017Au爷上台念了篇游记…感觉那如果是篇游记还是写的挺好的，然而当众念出来..然后请了广二的一个妹子OIer 讲了一点，就结束了。 Day 2/-6今天是上午考试..T1是给你一棵树，每个点有 $a_i,\,b_i$，每条边有 $c_i,\,d_i$，$u$ 到 $v$ 的费用为 $\sum\limits_{i\text{ on path }(u,v)}\min(a_u+c_i,b_u+d_i)$，求每个点到其它所有点的费用之和。树大小 $5\times 10^5$，值域 $10^5$。开场先打了个暴力，然后感觉可以枚举每条边把树分成两半，然后就可以计算 $\sum\limits_{c-d&lt;b-a} c$ 和 $\sum\limits_{c-d\ge b-a}d$ 来做，然而一开始没想到怎么做。继续去想链的部分分，发现可以主席树，然后花了 $1.5h$ 过 pt。然后发现可以用线段树合并搬到树上，又花了 $1h$ 过掉 pt。在 THUWC 过 pt 还是挺爽的.. T2是道通过询问得到树的形态的交互，没仔细看… T3是给平面上一些点，定义“好的多边形”为取一些点构成的没有三点共线的凸四边形，求所有“好的多边形”的面积的平均值和方差，对 $998244353$ 取模。点数 $400$ ，值域 $10^9$。有个点在坐标轴上的部分分，然而WA了两个小时..至今不知道哪错了.. 中午回寝室发现两边隔壁寝室分别有 nzhtl1984 和 yyb..然而最后和 lk 面基了。 下午推了会儿 Kanon。 去吃晚饭的时候碰见了 pr 和 lk。 晚上是图像处理题： 任务一把 $B\times65536+A$ 看成 $A\times65536+B$，调了 20min… 任务二任务三也写的特别慢，最后任务四没时间了.. 三场加起来没别人一场高，whkwhk 最后离场的时候发现了这个： 那两个红红的桌面壁纸是今天的样例… Day 3/-5今天应该是我来广二之后最有趣的一天了，本来拍了一堆照片，录了一堆视频，还有一堆录音，好多想说的。可是记（gu）忆（gu）是个好东西，它会帮你筛去那些不重要的，留在脑海中的便是那些真正值得写的吧。 讲题Day2+讲题的时候听到最多的一句话就是“然后就可以跳到”….. 讲完之后还讲了一些关于图像的其它内容，比如把图片的某些 bit 异或一下来加密： D1T2的讲题是带动画的，非常有意思，虽然有一些录像，然而还是放几张图片凑合一下吧： 好像 ctr 还觉得 D1T2 可以放 NOIp T2T3 左右… 然后是什么 ”圆梦清华路上有力的援助“什么的… 反正讲题特别有意思。 扯皮下午是扯皮介绍THU的时间。 能发弹幕，所以现场特别欢乐。 先是介绍了算协，然后介绍了科协，然后是一个去年THUWC签约然后进队今年过来当工作人员的介绍自己这一年的经历，然后是一个人介绍了一下科研相关。 反正当时感觉超有意思的..然而不太记得算协具体讲了啥了..科协讲的就记得智能体大赛..那位神仙 lzj 讲的倒记得比较清楚。大约是说他签约后写了个光线追踪的工程，然后写了个“二维屁股守望”还现场演示了，之后还去参加了智能体（注意他现在才高三..）。科研相关的讲的非常科研，可能是比较硬核而且互动/玩梗不够，当时现场也不太活跃，弹幕都没什么人刷… 结营感觉贵系招生主任的演讲水平真的超棒..弹幕都能迅速地扯到相关话题并且立刻扯回原本的主线，衔接自然流畅，感觉可以去当主播。 中途提了个问题，问我们为什么选择OI。 有回答“不想上文化课”“不想高考_(:з」∠)_”的，有回答“因为兴趣（略略略”“好玩”的，有回答“希望在有生之年解决曾经无法解决的问题”的，也有回答“能结识好多厉害的同学！”的。可能大多数人都是如此吧。因为兴趣开始，时而有宏大的理想，时而又为现实所迫，最后才发现不是自己菜，而是结识了越来越多越来越强的同学们。 约咕咕了一个小时才发，窝自然是没有的，pr签了，lk签了，yyb签了，nzhtlshadowice1984签了，joker签了，窝认识的都签了。 一天下来那么多的感想竟然短短几行就写完了呢…遗憾没有拍到的照片也只是和其它拍到了的照片一样没有被放上来。 Day -4今天早上一起来就是愉快的卷铺盖走人，虽然路程比去 THUWC 的时候近（从“苏元”（好像是初中部？）到“二高”），然而要搬被子床单什么的..分了两趟搬QAQ 然后颓推了一天一会儿Kanon，魔芋的翻译真有意思： 报到的时候有个签名墙，中午和晚上各拍了一张，晚上的比较全（废话），然而中午的拍的比较清楚，所以都放上来好了.. 看到窝写的 &lt;font color=&quot;grey&quot;&gt;ouuan&lt;/font&gt; 了吗qwq 晚上是开幕式，掌声最热烈的有两个地方。 第一个是广二的一个妹子OIer的演讲：“OI到底在学什么？班主任眼中最会修电脑的一批人，旁人眼中前途一片平坦通向美好未来的道路，同班同学眼中那个经常消失不知道去哪的神秘人”，“OI 已不只是一个竞赛，也不只是一门学科，而是存在于群聊中一句句 Orz 和三个百分号里，存在于看到十的九次方加七时的熟悉感以及看到 998244353 时的心里默默的波动中，抑或是一步步化难为简，最终得出正解的喜悦，也可能是自闭场后一个人独自惆怅的身影”。 第二个有js风险，所以..： 当NOI科学委员会主席念到“WC性价比高”的时候（copy这行） Day -3~0自闭。 放几张图好了。 把汐里线（推了游戏之后更喜欢这个翻译了..和香里也有姐妹的感觉）推完了。算是理解了为什么汐里的“名言”是“起きないから奇跡って言うんですよ”，这句话有好几层意思，光是看动画不会明白的吧..也稍微明白了“梦境”与“第三个愿望”是怎么回事了。虽然还是不完全懂..（都是不合理的，好像也没什么“完全懂”） 第二场营员交流上 yfz 和 mcfx 讲的指令集真好玩。 Day 1打铁。 开场先写了 $T1$ $34$ 分，一出考场就听说自己挂了 $8$ 分。 然后去想 $T3$ 交互，发现不会做，先把强制数据分治的 $13$ 分写了，调了一会儿，继续想 $O(n^2)$。 感觉不会，这时候已经过去 $3.5h$ 了（鬼知道前面那点分为什么写了这么久..），去玩 $T2$ 提答，前面 $60$ 分还是很好写的，然后作死的想了一会儿第四个点，发现不会，已经只剩 $0.5h$ 了。 问题是我这个时候还在想 $T3​$ 的 $n^2​$ 怎么写…最后 $15min​$ 的时候决定写个随机询问打表对照，直接随便打了个表都没有检查结果是否两两不同，本来还把原来的代码复制了一份，最后 $1min​$ 写好的时候竟然把代码复制回去编译的..随手输了个数据，一测，既不是 correct 也不是 incorrect，然后就考试结束了..估计连那 $13​$ 分一起没了，爆零了。 写了的分：$34+60+44=138$，Cu/Ag。 估分 at 考试结束前 $15min$ ：$34+60+13=107$，Cu。 估分 of 考试结束前 $15min$ ：$26+60+13=99$，Fe/Cu。 考试结束后的估分：$26+60+0=86$，Fe。 保底估分：$18+38+0=56$，Fe。 最高可能得分：$26+60+44=130$，Cu/Ag。 Day 1.5虽然只有下午+晚上，然而发生了好多事鸭。 先是 GGF 把选手复读复测鸽到了讲题开始之后.. 然后窝去看成绩，$T3$ 竟然没挂（$13$），然而 $T2$ 的第二个点莫名挂了..仔细看了半天都是对的，问别人也是对的，群里更有趣了，$O(1)$ 的题目 $O(n)$ 做法有 $0,\,6,\,20$ 分的..然后找到了工作人员，咕了一会儿之后帮我重测过了..然后去申诉，还不知道能不能加回来。讲题没去听..听了也是自闭。 OIer真能搞，说搞就搞出来了一个文艺汇演。 LCA nb！Joker nb！大连24 nb！zzt nb！ 感觉这一晚上更加了解 OI 了。要变得更强，和更强的人在一起，去喜欢正确的事情，再用尽全力去喜欢自己喜欢的事情。 完整版文艺汇演录制今晚压制出来，大约要回武汉之后才能传到b站上。 Day 2上午去科学中心冬眠。在车上用 zar 的热点把文艺汇演传了。 下午听说 $T2$ 重测了，然后窝莫名 Ag 了.. 这场 WC 好像是暴力 Au，只要 $127$ 分，然而窝暴力没打满，又疯狂挂分，只好滚粗了.. 另外好像人人都有一枚铁牌。 睡前看了两集《比宇宙更远的地方》。 Day 3上午看了两集《比宇宙更远的地方》，然后去火车站。发现竟然和 PinkRabbit 一辆（去火车站的）车。 中午吃了干拌面（来火车站之前买的），然后有个卖方便面的小哥让我们帮忙把方便面看着，他去上个厕所。$20min$ 后，他从厕所出来，去问 ylh 在玩什么游戏： 本来想对广二说 さようなら 的，想了想应该是 またね 。 感觉 cl 中渚对朋也说的那句“离开的时候一定要是笑着离开的，不然就再也回不来了”莫名可以用在这里。]]></content>
      <tags>
        <tag>游记</tag>
        <tag>CCF系列赛事</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UER #8 游记 —— 通信题：打雪仗]]></title>
    <url>%2FUER-8-%E6%B8%B8%E8%AE%B0-%E2%80%94%E2%80%94-%E9%80%9A%E4%BF%A1%E9%A2%98%EF%BC%9A%E6%89%93%E9%9B%AA%E4%BB%97%2F</url>
    <content type="text"><![CDATA[为什么这篇博客又是游记又是题解呢？因为这是我做的第一道通信题！感觉通信题真有意思QAQ. T3随便打了打暴力，T2由于没啥时间了感觉rush不出来就没写。（没错这就是这篇“游记”里唯一和通信题无关的部分） T1题目链接 大意：Alice 有一个长度为 $2n$ 的 $01$ 串 $s_{1..2n}$，Bob 有 $n$ 个下标 $p_{1..n}$，Alice 和 Bob 只能用 $01$ 通信，需要在每人各 $m$ 个 bit 内使 Bob 输出 $s_{p_1..p_n}$ . $n=1000, m=1350$ Part 1 通信题 只是说一下我做了这道题后对通信题的理解，可能有误。 赛时：通信题是啥？？？作为一个从未做过通信题的选手，遇到这题自然是百度了一下“通信题”。如果你尝试一下，会搜到《移动通信试题库》。 尝试搜索 “通信题 OI”——OI是什么意思? - 问通信专家；”通信题 CSDN”——通信原理考试题-CSDN下载。 ok，只能自己看样例程序了。 于是我比赛的第一个小时就在对着样例代码懵逼中度过了….. 然后发现我sb了，忘记了一件事：标准输入是会等待输入的！ 可能是我 OI 题做傻了，以为输入一定要一连串不停地输入…导致我一直没有理解为什么两个程序之间可以来回通信… （上面那段话纯属我sb了，请跳过不看） 通信题是……根据我的理解，通信题就是：两个程序，分别从文件读入数据，从标准输入读入另一个程序的标准输出。最后其中一个程序按要求输出到文件。 （好像跟题面描述的差不多…） 那就说说我sb了而卡住的地方好了..一个程序 getchar() 的时候会暂停执行，直到另一个程序输出，就跟手动输入数据时等待回车一样。 关于调试广二机房是 win7，不太方便复制… 于是只好手动输入了，只不过感觉 copy 两个程序的输出看它们相互配合着工作，还是蛮有趣的。 Part 2 解法其实我 $5min$ 就想到怎么做了..（但好像做法比最短解那些神仙做法麻烦的多？）其实也不是很难写，但由于第一次写通信题不太习惯，各种细节写挂，最后写了一个小时才A… 解决问题可以想到这样一个做法（如果想不到也没关系..看懂就好了）：选择一个区间 $[l,r]$ ，Bob 用一个长度为 $r-l+1$ 的 $01$ 串告诉 Alice 这个区间内每个位置是否是一个下标，对于每个下标 Alice 告诉 Bob 对应的值；对于不在 $[l,r]$ 内的其它部分，Alice 把所有值（不管是不是一个下标）都告诉 Bob . 优化通信数考虑一下，这样做需要的 bit 数是多少： Bob 给 Alice 的：首先 Bob 要告诉 Alice $l$ 和 $r$ , 用二进制表示，需要 $22$ 个 bit；其次，Bob 要询问 $[l,r]$ ，需要 $r-l+1$ 个 bit 。 Alice 给 Bob 的：首先 Alice 要回答 Bob 在 $[l,r]$ 内的询问，需要 “ $[l,r]$ 内下标个数” 个 bit；其次，Alice 要告诉 Bob 除了 $[l,r]$ 其它区域的所有值，需要 $n-(r-l+1)$ 个 bit 。 那么，我们需要最小化：$\max(r-l+23, [l,r]\text{ 内下标个数}+n-r+l-1)$ 。 用 $[l,l+len)$ 来表示会简洁一些，所以下文都使用这种方式，即需要最小化：$\max(len+22, [l,l+len)\text{ 内下标个数}+n-len)$ 。 预处理前缀和即可快速算出 $[l,l+len)$ 内的下标个数，$O(n^2)$ 枚举区间取最小值即可。 参考代码Bob1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;ifstream fin("bob.in");ofstream fout("bob.out");char rd() //读入一个bit&#123; return getchar();&#125;void wt(int x) //输出一个bit&#123; putchar(x+'0'); fflush(stdout);&#125;int n,m,p[1010],rk[4010],pre[4010],minn=0x7fffffff,l,len;char ans[1010];int main()&#123; int i,j,t; fin&gt;&gt;n&gt;&gt;m; for (i=1;i&lt;=n;++i) //读入并记录是第几个下标（便于存答案），并且复制一份拼在后面，这样如果询问的区间跨过首尾可以方便地处理 &#123; fin&gt;&gt;p[i]; rk[p[i]]=rk[p[i]+2*n]=i; &#125; for (i=1;i&lt;=4*n;++i) //预处理前缀和 &#123; pre[i]=pre[i-1]+(rk[i]&gt;0); &#125; for (i=1;i&lt;=2*n;++i) //枚举找最优方案 &#123; for (j=1;j&lt;=2*n;++j) &#123; t=max(pre[i+j-1]-pre[i-1]+2*n-j,j+22); if (t&lt;minn) &#123; minn=t; l=i; len=j; &#125; &#125; &#125; for (i=10;i&gt;=0;--i) //告诉Alice l和len &#123; wt(bool((1&lt;&lt;i)&amp;l)); &#125; for (i=10;i&gt;=0;--i) &#123; wt(bool((1&lt;&lt;i)&amp;len)); &#125; for (i=l;i&lt;l+len;++i) //询问区间 &#123; if (rk[i]) &#123; wt(1); ans[rk[i]-1]=rd(); //存答案 &#125; else &#123; wt(0); &#125; &#125; for (i=l+len;i&lt;l+2*n;++i) //读取剩余部分 &#123; if (rk[i]) &#123; ans[rk[i]-1]=rd(); &#125; else &#123; rd(); &#125; &#125; fout&lt;&lt;ans; return 0;&#125; Alice12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;cstdio&gt;using namespace std;ifstream fin("alice.in");int rd() //为了方便，两个程序中rd()和wt()的char/int是反的&#123; return getchar()-'0';&#125;void wt(char x)&#123; putchar(x); fflush(stdout);&#125;int n,m;char s[4010];int main()&#123; int i,l=0,len=0; fin&gt;&gt;n&gt;&gt;m&gt;&gt;(s+1); for (i=2*n+1;i&lt;=4*n;++i) //复制一遍放在后面 &#123; s[i]=s[i-2*n]; &#125; for (i=0;i&lt;=10;++i) //读入l和len &#123; l=l*2+rd(); &#125; for (i=0;i&lt;=10;++i) &#123; len=len*2+rd(); &#125; for (i=l;i&lt;l+len;++i) //回答询问 &#123; if (rd()) &#123; wt(s[i]); &#125; &#125; for (i=l+len;i&lt;l+2*n;++i) //告诉Bob剩下的部分 &#123; wt(s[i]); &#125; return 0;&#125; Part 3 证明取询问区间为 $[l,l+1318]$ ，这样的话 Bob 发给 Alice 的 bit 数就为 $1319+22=1341$ . 区间 $[l,l+1318]$ 内下标的期望个数为 $\frac{1319}2$ ，所以一定存在某个区间使得下标个数小于等于 $659$ ，再加上剩余部分 $681$ ，Alice 发给 Bob 的 bit 数就为 $1340$ 。 事实上，我提交的评测记录里通信次数最多的就是 $1341+1340$ 。 Part 4 优化只取 $len=1325$ ，少枚举一维，可以优化到时间复杂度 $O(n)$ ；少传 $11$ 个 bit，可以优化到最大通信次数 $1336+1337$ 。证明从略。 提交记录]]></content>
      <tags>
        <tag>游记</tag>
        <tag>UOJ</tag>
        <tag>题解</tag>
        <tag>通信题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随机生成图片展示]]></title>
    <url>%2F%E9%9A%8F%E6%9C%BA%E7%94%9F%E6%88%90%E5%9B%BE%E7%89%87%E5%B1%95%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[传送门 源码按F12即可查看（当然也可以在 repo 里面看） 看到一个帖子里提到了一个140字符画图比赛，看到了 Martin Büttner’s code ，然后就随便写了一个. JavaScript 都是要用啥现场百度… 已经更新了（存档？）功能，在地址栏后以 ? 开头 &amp; 分隔即可输入参数。例如：https://ouuan.github.io/randpic/generator/?width=512&amp;height=512&amp;blocksize=75&amp;qwq=2&amp;minred=100&amp;maxred=255&amp;mingreen=100&amp;maxgreen=255&amp;minblue=200&amp;maxblue=255&amp;minalpha=0&amp;maxalpha=255 下面是一些图片（附有参数链接）：]]></content>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Avito Cool Challenge 2018 游记]]></title>
    <url>%2FAvito-Cool-Challenge-2018-%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[这两天比赛是真的多..碰上了场 Chinese Legends Round / HackForces 竟然在紫名涨了点分QAQ 看到 A，$gcd(x,x-1)=1$ ，这不是sb题吗？然后愉快地WA了…互质 $\ne$ 不为倍数鸭QAQ还有 $1$ 呢.开场-50分.. B貌似比C难，但A的人比C多..其实当时交的时候还没想清楚 $p$ 个一样的人数是 $p$ 的倍数这个结论，就感觉好像是对的，就交了。 C 很快就想到了结论，排列组合乘一乘随便做，而且数据范围小到可以用杨辉三角算组合数+不用快速幂。 D 感觉要搞个MST，然后就真的先搞了个MST，然后就没有想到简单的解法..正解是MST搞完所有关键点就不搞了。一开始写挂了，然而pt特别水（好像直接输出MST最大边就可以），A完E之后看到jason的D被叉了，就仔细看了下，发现自己写挂了..然后重交，少了 $400$ 多分。 E 贪心搞一搞就行了，据说ylh没有做出来是忘了积一定差越小和越小.. F 看了看感觉不会，于是锁了 D 开始叉人。看到room rank1的正解感觉自己整个人都sb了..在离比赛结束 $5$ 分钟的时候看到一个感觉写挂了的，然而不敢hack，于是一直盯着看，直到离比赛结束还有 $1$ 分钟的时候才hack，然而一不小心把数据打错了..幸好格式错误不扣分，赶紧点回去重新hack，最后在离比赛结束 $4s$ 的时候提交了hack，然后绿了！喜提 $100$ 分、$50​$ 名。 当时比赛一结束我就跟 ylh 说我感觉如果我不 fst能再涨 $100$ 名，然后最后真的又涨了 $100$ 名.. B和D一堆fst的。 F 用奇偶性判断选择的哪边，感觉很妙。 G 没仔细看。 H： and we didn’t except anyone to pass. 不知道会在紫名待多久QAQ]]></content>
      <tags>
        <tag>游记</tag>
        <tag>CodeForces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF edu 56 & AT Grand 029 游记]]></title>
    <url>%2FCF-edu-56-AT-Grand-029-%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[今天 AT 和 CF 刚好连上了，于是就都打了一下。 关于模板今天心血来潮把用于在线比赛的模板换了一下，加了点东西，然后发现 rep(1,l,r) 写起来非常不顺手..保留了部分比较好用的。 测试的时候忘记开数组了（都是些什么sb错误），然后以为 ll 不能作下标，于是没有 #define long long，然后 CF 挂惨了.. AtCoder上一场打的 Beginner，这场难度正常多了。 A 是个值域为 $2$ 的逆序对.. B 用 multiset 乱搞了一下，对于每个数枚举组成的数，然后从大到小匹配，不知道是不是正解，反正过了，而且是 $log^2$ 的。 C 感觉挺可做的..可能有细节没调出来，赶着回酒店打 CF 就没有继续调了.. D 一开始还在想博弈论完全不会..然后仔细看了一眼，如果 A 不走，B 就会不走，就结束了；所以 A 一定能走则走。然后就随便做了。 只不过 AT 的 rating 真的涨的好快.. CodeforcesABC 三道 spj ？？？ 都是随便构造就能做的.. 然而 C 一开始忘开 ll 了….. D 黑白染色一下，连通块内两种节点分别有 $a$ 个和 $b$ 个答案就是 $2^a+2^b$ ，把每个连通块的答案加起来就好了。 由于 $O(nq)$ memset 会爆掉，不能 memset 整个数组，于是愉快地在开了 ll 的情况下 memset(…sizeof(int)…)；发现了之后不小心把开 int 的另一个数组也改成 memset(…sizeof(long long)..) 了.. 开场 $40$ 分钟的时候这 $3$ 个关于 ll 的罚时让我排名翻了三倍… 于是，A 了 D 之后我就在板子里加上了 #define int long long。 看了会儿 E 不会做，然后一看 standing，惊奇地发现 G 有一堆（$15$ 个，当时 E $7$ F $1$）人 A 了，然后一看，就是POJ 2926+动态RMQ… 感觉自己几年没有写过普通线段树了（最近写的全是平衡树/动态开点线段树），写了半个多小时还写错了..毕竟是 CF，应该去复制个模板才对的…一交，MLE 了，woc我好不容易#define int long long了就是这个结果？？改成 int，跑了 $5.4s$，巨方，于是手动开了 O3，$4.8s$ ，但重交竟然没有罚时。应该去找个 BIT 动态求 RMQ 的模板的… 看到 halyavin 参赛了，感觉自己要 fst ，赶紧把博客写了睡觉去。 UPDhalyavin 竟然没有 hack…然而 D 有一堆 memset 整个数组的，我也去 hack 了一个（edu hack $\sqrt{}$）。 没有 fst，第一次 A $5$ 题，上 $2k$ 了，感觉海星。 UUPD题解 CF1093D 【Beautiful Graph】 题解 CF1093G 【Multidimensional Queries】]]></content>
      <tags>
        <tag>游记</tag>
        <tag>CodeForces</tag>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html实现随机图片]]></title>
    <url>%2Fhtml%E5%AE%9E%E7%8E%B0%E9%9A%8F%E6%9C%BA%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[注：暂时还不知道如何制作能被引用的随机图片，只能查看图片，而不能通过类似于![](图片地址)的方式查看。 demo 欢迎投稿图片：投稿地址 核心代码12345&lt;script type="text/javascript" src="imagelist.json"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var r=Math.floor(Math.random()*images.length) document.write("&lt;img src="+images[r]+"&gt;")&lt;/script&gt; 图片列表保存在 imagelist.json 内。 参考示例https://ouuan.github.io/randpic/people/index.html： 123456789101112131415161718192021&lt;html&gt;&lt;head&gt; &lt;script type="text/javascript" src="imagelist.json"&gt;&lt;/script&gt; &lt;title&gt;随机图片-人物类&lt;/title&gt; &lt;link rel="icon" type="image/png" sizes="32x32" href="/images/favicon32.png"&gt; &lt;link rel="icon" type="image/png" sizes="16x16" href="/images/favicon16.png"&gt; &lt;style&gt; img &#123; width: 100%; height: auto; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;script type="text/javascript"&gt; var r=Math.floor(Math.random()*images.length) document.write("&lt;img src="+images[r]+"&gt;") &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; https://ouuan.github.io/randpic/people/imagelist.json： 123456789101112131415161718192021var images=[ "https://z4a.net/images/2018/12/12/70469686_p0.png", "https://z4a.net/images/2018/12/12/69212051_p0.jpg", "https://z4a.net/images/2018/12/12/64660644_p0.jpg", "https://z4a.net/images/2018/12/12/61438972_p0.jpg", "https://z4a.net/images/2018/12/12/60141148_p0.png", "https://z4a.net/images/2018/12/12/1200296-20170715113653118-1762611401.jpg", "https://z4a.net/images/2018/12/12/71631241_p0.jpg", "https://z4a.net/images/2018/12/12/f0Q5-g62pXkZ5lT3cS1hc-rs.jpg", "https://z4a.net/images/2018/12/12/36224612_p0.jpg", "https://z4a.net/images/2018/12/12/64702477_p0.jpg", "https://z4a.net/images/2018/12/12/64670588_p0.jpg", "https://z4a.net/images/2018/12/12/61815260_p0.jpg", "https://i.loli.net/2018/12/12/5c10a02b0831b.jpg", "https://i.loli.net/2018/12/12/5c1119665c83a.jpg", "https://i.loli.net/2018/12/12/5c111a8bed8e8.jpg", "https://i.loli.net/2018/12/12/5c111ab43f7cf.jpg", "https://i.loli.net/2018/12/12/5c111ade38590.jpg", "https://i.loli.net/2018/12/12/5c111b8240591.png"] UPD研究了一下 js 后写了一下图片缩放：（代码很丑，毕竟是靠百度学了一个小时写出来的）（大括号不换行是因为sublime缩进写着写着就炸了，只好在网上格式化了一下） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107&lt;html&gt; &lt;head&gt; &lt;script type="text/javascript" src="imagelist.json"&gt; &lt;/script&gt; &lt;title&gt; 随机图片-人物类 &lt;/title&gt; &lt;link rel="icon" type="image/png" sizes="32x32" href="/images/favicon32.png"&gt; &lt;link rel="icon" type="image/png" sizes="16x16" href="/images/favicon16.png"&gt; &lt;/head&gt; &lt;body style="margin: 0px; background: #0e0e0e;"&gt; &lt;script type="text/javascript"&gt; var cur = 1; var xx = 0; var yy = 0; var rx = 0; var ry = 0; var nw; var nh; var mw; var mh; var w; var h; function setSize() &#123; if (cur == 1) &#123; var p = document.getElementsByTagName("img")[0]; nw = p.naturalWidth; nh = p.naturalHeight; mw = window.innerWidth; mh = window.innerHeight; if (nw &gt; mw || nh &gt; mh) &#123; p.style = "cursor: zoom-in"; &#125; else &#123; p.style = "cursor: auto"; &#125; if (nw * mh &gt; nh * mw) &#123; h = nh * mw / nw; w = mw; &#125; else &#123; w = nw * mh / nh; h = mh; &#125; p.style.width = w; p.style.height = h; p.style.marginTop = (mh - h) / 2; p.style.marginLeft = (mw - w) / 2; &#125; else &#123; if (nw &gt; mw || nh &gt; mh) &#123; p.style = "cursor: zoom-out"; &#125; else &#123; p.style = "cursor: auto"; &#125; &#125; &#125; function picLoaded() &#123; setSize(); window.onresize = function() &#123; setSize(); &#125; &#125; function BigSmall() &#123; mw = window.innerWidth; mh = window.innerHeight; if (nw &gt; mw || nh &gt; mh) &#123; if (cur == 1) &#123; cur = 2; var p = document.getElementsByTagName("img")[0]; p.style = "cursor: zoom-out"; var e = event || window.event; mw = window.innerWidth; mh = window.innerHeight; if (nw * mh &gt; nh * mw) &#123; h = nh * mw / nw; w = mw; &#125; else &#123; w = nw * mh / nh; h = mh; &#125; if (nw &lt;= mw) &#123; xx = (mw - nw) / 2; rx = 0; &#125; else &#123; xx = 0; rx = (nw - mw) * (e.clientX - (mw - w) / 2) / w; &#125; if (nh &lt;= mh) &#123; yy = (mh - nh) / 2; ry = 0; &#125; else &#123; yy = 0; ry = (nh - mh) * (e.clientY - (mh - h) / 2) / h; &#125; p.style.marginTop = yy; p.style.marginLeft = xx; document.body.scrollLeft = rx; document.body.scrollTop = ry; &#125; else &#123; cur = 1; setSize(); &#125; &#125; &#125; var r = Math.floor(Math.random() * images.length); document.write("&lt;img src=" + images[r] + " onload=\"picLoaded()\" onclick=\"BigSmall()\"&gt;"); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018~2019冬 广二避寒记]]></title>
    <url>%2F2018-2019%E5%86%AC-%E5%B9%BF%E4%BA%8C%E9%81%BF%E5%AF%92%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[迎风迈出的步伐更艰难，即使走的不远，但踩得更深。一代人只能做一代人的事，完成这个时代赋予的使命就是英雄，大地也会将他的脚印铭记。 ——乒乓帝国（句子迷上说是《孤杂记》..） 突然就得知了要去广二集训。 然后知道了这次出去可能要一直到 WC，差不多有 $50$ 天。这样一算这个学期我在武汉的时间可能和外出的时间一样多了。 毕竟是去广州，会暖和很多，也许看不到武汉的雪了。 Day 0Railway在站台上遇到了 Dew、ylh，感觉自己活尸化严重，都是我妈先看见的… 中午吃了泡面（有汤的那种），之前出去都比较近，在火车上不用吃饭，印象中上次吃方便面还是初三的时候在学校里吃的（桶装的泡面，愣是被我当成干拌面吃的）。 在火车上看看手机、看看《大卫·科波菲尔》，当然我现在在写博客。 途中看到了一幅非常………..ok我承认我词穷了。云很低，好像不比火车高多少，环绕在山的周围，山脚下是一些平房，在远处插入了几栋现代化的高楼大厦，有一种违和却奇妙的美感。 赶紧掏出手机，可毕竟只是手机，拍不出云那种虚无缥缈的立体感，匆忙中也没能选好角度，没拍到那几栋高楼大厦。 已经逝去了，经纬度也没有记下来，不能在回来的火车上再览其景，只能用粗浅的文字将其略微地记录下来罢。 Underground进地铁前忘记上厕所了Orz 和 ylh 一起体验了一次换票出站上厕所。 然后是 huangbei 站： 人特别多，特别热。毕竟是来避寒的 Restaurant和广二的教练谈了谈人生，建议我和 ylh 先系统地学知识点，不着急打套题，结果 dew 想先学知识点，我和 ylh 想在广二做题.. 然后就是住宿的事，貌似准备先住两个星期三人间，等 ylh 回去了就去教练家里住（教练一个星期只回家一天）。今晚是先各自和家长住双人间。房号 1216. Day 1上午教练咕咕了，中午才来接我们。 然后让我们不着急打比赛，给我们三个人安排了个机房做题。 $5$ 道左偏树，派遣、罗马游戏和Joint Stacks比较轻松地做出来了；Sequence看了看题解，感觉还没完全搞懂，但A了；魔法猪学院用A*在广二的OJ和BZOJ上过了，暂时放弃可持久化左偏树，以后再学吧.. 山、河、树（不只是路边那种）（当然也不是可持久化那种），游泳池，令人联想起 Angel Beats! 的食堂，各式各样的社团活动。 Day 2-3把题目列表搞到了洛谷团队里. 搞了搞平衡树、启发式合并之类的，感觉自己啥都不会.. 搞了个随机图片 。 Day 4一天就写了[NOI2004]郁闷的出纳员和LCT模板… 然后搞了个stylus插件：洛谷犇犇、讨论隐藏。 果然整天待机房效率低. Day 5上午听隔壁机房的讲了下回文自动机、后缀数组、后缀自动机，但由于手头上的题还没搞完就没做相关的题目。 [NOI2005]维护数列做了好久..本来操作就多，取的子段还不能为空… 然后学了下LCT。 Day 6-7就做了几道 LCT 的题…学了学虚树，还没做题。 然后这几天比赛挺多的，at+cf 还有洛谷比赛。感觉洛谷比赛都挺dl的… 然后今天看了几篇vfk的博客，感觉都写的挺好的。 里面提到了CFctr的自我修养，感觉以后出题时要牢记（虽然里面有些是只适用于CF的）： 准备一场CF包括：题目、比赛通知、题解。 你的题目必须是独一无二的。你不能从以前用过的题目中抄袭它的想法。PLEASE BE FAIR WITH THE COMMUNITY。（ 空间限制必须是256MB，时间限制至少是出题人的java程序运行时间的两倍。 题面必须清晰好懂，没有语法错误。建议写得短短的…… 题目背景中不要写数据范围，全部都要写在输入格式里。 请参考以前CF的题目描述的格式来写题目描述。如果你不知道怎么清晰地描述输入输出格式，请找与之类似的题目进行仿写。 题目描述中的数组下标最好从1开始。 你必须限制被你提到的所有的变量的范围。如果你提到一个字符串，你必须写明哪些字符可以出现在这个字符串内。 题目的tests中必须包括各种各样的数据，而且应该有各种各样的达到最小数据范围的数据和达到最大数据范围的数据。也就是说如果1 &lt;= n &lt;= 100000，那么数据中既应该有n = 1，也应该有n = 100000。 你应该写个暴力。 你应该拿标程与暴力对拍。 Div.2的题的pretests要很强，能让应该超时的程序在pretests上就TLE掉。但是你可以让这个点毫无意义。比如给n个数排序，你可以用n个1来确保选择排序不能过。 确保读错题的人不能过pretests。 建议添加极端数据，但是不必是所有极端数据。确保数组开小的人不能过pretests。 不要让时间复杂度很高但做了大量常数优化的人AC。 每道题至少2个样例。每道Div.2的题目的前两个样例必须有样例解释。 如果要使用long long，请确保不开long long的人不能过pretests。 哦对了，自定义域名总是炸，以后这个博客就用 ouuan.github.io 作为地址了。（正好避免了一年后域名到期的问题） Day 8今天好像啥都没干..估计是每天都没睡好导致白天效率低下.. 好像看了好几篇淀粉质的教程，但就是不想写题.. 和 memset0 讨论关于保留几位小数与精度限制的问题..感觉其他人总是不能轻松地理解保留几位小数是卡精度的… 翻译了CF的几道题，写了写题解。 继续yy自己口胡的题的优秀做法，依然没什么进展。 跟 Sooke 说了说自己出 CF 的想法，Sooke 表示想一起出，然后在还没想好一道题的情况下大谈怎么出 CF.. 说实话出 div.2 的话会有些不甘，哪怕晚点也想出 div.1+div.2 的.. 第一次用洗衣机，感觉洗衣机真有趣 （好像暴露了我一周没洗衣服…） （hexo 貌似不支持行内图片？） Day 9搞了个 随机生成图片 ，感觉自己自从用了 Hexo 日益由 OIer 变成码农了。 Day 10-11这几天忙着搞比赛，博客可能咕咕咕了..准备比赛记大约会在比赛出来之后发QAQ. Day ?-?咕咕咕咕咕咕咕 Day 14广二先是四楼停电，用了一上午笔记本，准备回酒店的时候门卫告诉我们电来了，然后回去一看发现四楼没电三楼有电。下午突然就又停电了，幸好我和 dew 都没有在写代码.. ylh 走了，然而住教练家被咕咕了，好像是因为又来了几个外省的。 新酒店..发几张图感受一下吧： 没错 p3 是 dew 在吊椅上 然而不敢对着 dew 拍… wifi 特别神仙： 被夹在了一个没有 wifi 的世界里.. 然后貌似明天还是什么时候开始要打比赛了，然后这篇游记就不会继续真的成“游记”了。 Day 15今天是集训队爷 zjt 出的 集训队互测。 T1 一道带权带花树好题的确是带权带花树裸题（求一般图最大权值匹配），然而不需要输出方案。 虽然说 OI 题名无正解，然而我还是百度了一下..然后学了一个半小时带花树，没学会！ 然后再一看，$n\le20$ 不会做？ 只好写了二分图的 $20$ 分滚粗.. 然而发现一个严重的问题，这貌似是我第一次写二分图最大权值匹配..百度了一下，发现全是KM算法，没有一篇费用流？然后仔细想了好多遍，感觉费用流应该没问题，就写了。然而一开始写挂了（连图中的边时没判哪个点是起点），幸好后来发现了。 后来听说这题 std 是一个线代做法，由于不用输出方案码量非常小。具体可以参考2017年集训队论文。然而看不懂鸭… 这题不卡随机化乱搞.（嘤嘤嘤？） T2 一道拉格朗日反演好题看到 T1 真的是一般图最大权值匹配的我真的信了题名的鬼话.. 一个 $01$ 序列，初始为空，有三种操作： 往末尾加个 $0$ . 删掉一个子序列，包含 $x$ 个 $0$ ，$y$ 个 $1$ ，然后往末尾加个 $1$ 。其中 $x\in A$ 。 删掉一个子序列，只包含 $x$ 个 $0$ ，然后往末尾加个 $1$ 。其中 $x\in B$ 。 $A$ 和 $B$ 还有操作总数 $n$ 是给你的，让你求 $n$ 次操作完成后序列长度为 $1$ 的方案数。 一开始还以为只用管 $01$ 分别的个数，后来才发现选的子序列位置不同也算不同的方案… 数据范围：いいよ,こいよ $114514$ 不太会做，好像是转化成一个树上的 dp，然后再算一波式子，分治FFT/牛顿迭代？ 不得不说样例十分lx： 12310 10 100 1 2 3 4 5 6 7 8 90 1 2 3 4 5 6 7 8 9 1362880 愉快地拿到了 $|A|=|B|=n$ 这档部分分。 T3 一道 Top cactus 好题仙人掌上 $q$ 次询问求经过某个点的路径贡献之和。模 $998244353$。“不在简单环上的边数”为 $x$ 的路径贡献为 $v_x$ 。 部分分第一档，树，$n\le2000$ 。 woc我只会 $O(n^3)$ .. 冷静了一下，发现可以枚举路径树上差分.. 愉快地拿到了这 $10$ 分。 正解好像是淀粉质+NTT。然后搬到圆方树上去。 总结队爷出的题就是神仙..之前一直感觉多项式看起来没啥用？请julao们看到这句话别打我..感觉很有必要早点去学多项式全家桶了。 另外题名里的算法真的 $99\%$ 不可信。 另外由于打比赛换了个机房，貌似机房里都是一些外省的？ OIer居然是可以有npy的！ Day 16yww咕咕了，myh出的题。这场题面太赞了！据说题意不清被吐槽的很厉害，但我貌似还是第一次碰见YNOI型题面，背景是自己看过的番，题意瞬间理解。 这场还有个有趣的地方，T1 和 T3 的 subtask 一开始放反了，而且 T3 的变量 T1 都有，于是我比赛开始 $2h$ 才发现..（当然我发现的时候已经改回来了） T1 青春野狼不做理性小魔女的梦题意简述，题目背景太棒了，所以我要题面简述。 在咖啡厅，双叶不说话，只是推给了你一张纸，上面写着一个不定方程： $A_1x_1+A_2x_2+\cdots+A_kx_k\equiv1\mod m$，然而其中的一些 $A_i$ 被咖啡打湿了，需要给被打湿的 $A_i$ 们赋值（$A_i\in[0,m)$），使得不定方程有整数解；同时，双叶也不记得 $m$ 是多少了，所以要求 $m\in[1,n]$ 的方案数之和。$1\le k\le50,1\le n \le10^9$。 大约想到怎么做了，然而感觉无法实现（事实是正解要用杜教筛），会写的特别麻烦复杂度还不对，于是就只打了 $k\le5,\,n\le10$ 的暴力和没有数字被打湿的分。然而后面那档挂了，因为求区间内与某个数互质的数个数时没有容斥，最神奇的是拍半个多小时没拍出来… T2 青春野狼不做姐控偶像的梦和花给麻衣的信很有规律，她写的信是一个 $1$ ~ $n$ 的排列，一段连续的信能给麻衣鼓励，当且仅当它的值也连续（noi.ac的whzzt邀请赛里把这玩意定义为“广义排列”，意思就是一个区间， $max-min=r-l$ 且没有重复的数），麻衣想知道如果只保留一段连续的信，她能收到多少鼓励（就是多组区间询问）。 其实..就是 CF997E Good Subsegments.. 千古神犇wxh log碾标算！lxctr myh n^2 送温暖！嗯，我拿了 $O(n^2)$ 的 $20$ 分… 做法参考 zzq的评论 T3 青春野狼不做小恶魔学妹的梦这道题题面写的最好！（貌似也被吐槽的最惨） 对学长的思念，深埋于心底。 难以表达。 与学长的记忆分为 $n$ 个部分，两个不同的部分间可能会有一种关系，也可能没有。 可是我知道，它们藕断丝连，注定联通。 想忘掉，可是却越来越难忘，$m$ 种关系会带给我 $m^k$ 的思念。 我不知道我有多思念学长，能告诉我如果关系随意出现，思念的和吗？ 我不想看到太大的数，只要告诉我它模 $998244353$ 的结果就好了。 题意简述：$n$ 个点组成无向图，求不同的方案边数的 $k$ 次方之和。 斯特林展开+大力推式子+NTT. 再见。 其它myh 问班上的女生：你怎么3.5k写完仙人掌剖分的。 嗯，女生就是昨天的总结里的女生。yqyry Day 17今天没有比赛。 Day 16 ~ Day 17 的这晚貌似是来广二之后睡的最长的一次（$6$ 小时 $40$ 分），然后效率果然略高了一些（一天只搞了FFT/NTT/多项式求逆，高个鬼），比起之前整天几乎啥都不干还是好多了..（有种如果睡8小时能一天搞完多项式全家桶的错觉） 希望这周能把多项式常见的一些东西搞完吧..到时候应该会写一篇博客。 Day 18颓颓颓。 T1题意大约是求 $l_i\le ki+b\le r_i$ 的 $k,b$ 方案数。 最低档暴力在考试结束前 $10min$ 才想出来一个特别麻烦的解法..然后爆零了。 正解半平面交。 T2线性同余找循环节海星。 T3给几个团，团内点连相同权值边，问点之间两两距离之和。 以团内边权为点权求出团之间的最短路，然后 $dist(i,j)=\min\{d(x,y)|x\in S_i,y\in S_j\}$（$S_i$ 表示 $i$ 所在团的集合）。 具体实现要用到 FMT 里的一个小 trick ，然而题解里一笔带过，我看了一下午题解都没看明白… 其它那位女生 $rank1$ 了… 然后今天才发现广二 OJ 外网是能上的..（当然注册不了账号QAQ） Day 19今天搬的 ACM 原题？CF 权限 gym Orz 题解给吉老师视频，太灵性了.. zjt 25（$rank 8$），myh 赛后五分钟提交 $15$ 快乐赛。 T1dp，好像没啥不会的知识点，然而没做出来。 T2把排列当成坐标放在平面上，分类讨论求上升块？表示完全没听懂，讲的时候 myh 在不停地提问。 黑科技听不懂，而这道题除了黑科技还要牛顿迭代…每场必有多项式的flag还是没倒. T3没听懂嘤嘤嘤。 Day 20颓颓颓。 今天没比赛，然而只搞了多项式除法和任意模数NTT。 多项式除法一开始 $B(x)$ 模了 $x^m$ ，然而应该模 $x^{n-m+1}$ ，然后挂了半天。 任意模数NTT因为数组开小挂了半天… 看到洛咕有绘板，就把晚上的at咕咕了，搞了个py脚本。一开始妄想手动把图片转成数据，差点一晚没睡，后来main包发了个脚本，转的效果还挺不错的。 Day 21-23基本上都在搞绘板，比赛记应该是永久咕咕了，绘板记这几天会写出来。 有一个小插曲，9102年第一个梗被我骗了点赞。 Day gugugu绘板记咕咕了，这两天的比赛记咕咕了，今晚的CF不咕咕！猝死！！ Day 27今天的T1非常有意思，$8$ 个 int 进行编码，编码长度至少是 $1000$ 个 int，随机打乱之后给你解码。标算是一个不确定性算法，所以这题是达到一定正确率就过，（然后我赛时第一次提交30，第二次提交20，脸黑选手zjt赛时90，赛后AC），然而有神仙想出了多点求值、快速插值的确定算法。 T2一看是几何题我就跳了..然而这题不怎么需要计算几何，而且有 $30$ 分挺好写的….. T3是个树上dp，部分分有个“与一条蛇同构”，然后： xswl 尝试着按myh的提交记录刷题，第一题是个字符串哈希，第一眼还以为是AC自动机..然后一发mapT飞，unordered就过了。第二题是个裸的单点、子树加，单点询问，竟然写错了3遍…..第三题是个数位dp，愉快地卡住了….再不好好学数位dp感觉会出事_(:з」∠)_ Day 28T1是树上在线多组多路径询问颜色种类数和mex，一开始看到部分分还在想为什么没给树上莫队分，然后一想多条路径莫队复杂度肯定不对，看题解才知道正解树分块…bitset能在线搞定的事，为什么要离线排序呢？然后成功在赛后A掉了（广二膜你赛赛后首A_(:з」∠)_）大约就是预处理关键点之间的bitset，块内暴力跳，关键点之间已经预处理了。 T2是道神仙题..好像从某外国比赛搬的，赛时0A，通过分治时判断左右一样来保证复杂度，没太听懂。 T3：“点分治然后建虚树再点分治就好了！”（mdzz）“听说fzy有两个log做法？treap/Splay合并就行了！”（mdzz） 然后用bitset水了点contribution，达成成就：contribution比friends多。 polygon真有意思！试着把一道题搞上去了。 Day 29-30稍微学了下莫比乌斯反演和杜教筛，感觉挺有意思的QAQ。 比赛全场就我不会马拉车，然而三题暴力排名还不错…貌似只要打了点非无脑的暴力就能考的还行。（A题就jxd了 Day 31今天比赛是zzq出的，上场 Chinese round 既视感严重.. T1树上有一些特殊点。 两两匹配特殊点使得距离之和最大。正解没听懂，然而直接扫一遍存为 $rk_{1..k}$ 然后输出 $(rk_i,rk_{i+\frac k 2})$ 就能过… T2“这是一道交互题”。 加了一些限制条件，不同排名的人在某些情况下可能不回答询问，对其排序。 并不是很难然而赛时没想到.. T3QuickSort伪代码。 求 $cnt$ 次操作后排序成啥样了。又是只需要大小时转化为 $0/1$,$0/\pm1$ 的 trick. 然后，今天写了 $5$ 道莫比乌斯反演，100+600，感觉海星。 Day 32改题日→出题日 Day 33比赛的时候OJ挂了海星，最后修好了。 感受一下刚修好时的提交。这次题目时限又大，当时卡了好几页。 T1一开始时限是 $2s$，后来开成 $4s$ 了，然后一排人 $3.9s$… T3一开始时限是 $6s$，myh NTT被卡常，赛后给自己开到 $12s$ 重测，$9s$ 过了…然后他成功 $rank1$。 Day 34 这个是我们刚来时就在画的，最近画好了，趁着迟到没人拍了一下。 上午被告知学校有考试，机房被占用了，让我们下午不要去机房，在打比赛的体育馆待着。于是很多人都提前跑了..我也下午就走了，走的时候看到一堆小学生模样的孩子和家长，听到了“XX考试的第二场和XX时间一样，不让考完第一场就跑”之类的话，听到了“二火”之类曾经熟悉的名词。我是为什么放弃了华一寄来到外初的呢..早就忘得一干二净了，只记得来外高是因为wqs的寥寥几句话： 还听到一个孩子说：“二中环境真好。”我以为他也会感叹二中有山有水，没想到他说的是——“二中有专门的清洁工”。 Day 35改题日颓颓颓 Day 36OrangeRabbit tql!!! 去机房的路上发现这个： 我们刚来的时候就看到有人在画井盖了，然而才发现这个QAQ T2对自己 $20$ 分暴力过于自信，打了一个半小时表找不到规律后写了下 $20$ 分才发现是错的… T1写了一个半小时比暴力跑的还慢的树剖..稍微想想就可以发现复杂度完全不比暴力优的，然而想到就打了.. 最后没时间写T3暴力了，赛后听说T3数据特别水，随便写都能六七十分.. 于是炸的特别惨。 晚上学了下淀粉质（讲题的时候myh认为机房里没人不会动态点分树…），看题解怎么都看不懂，只不过自己yy很快就写出来了，然而第一次交的时候前向星存边数组没开两倍..？ Day 37今天又是zzq出的题，T1T2都是构造，其中T1没有输入..T1 rand跑了一个小时跑出来 $60$ 分（存种子提交），T2最低档爆搜不会..两个特殊性质subtask写了 $30$ 分。 T3 也是道思维好题，写了个 $O(n^3)$ 暴力 $30$ 分。 Day 38好像是最后一个改题日..又颓过去了没什么好说的。 Day 39Sooke跟我说他昨天做了这套题…然后告诉我不要看T3，会很惨。然而.. 这次好像是我拿到 $80$ 分最快的一次，打完T1T2拍了一下就开始玩提答了。看了一会儿大约看懂了一点，然后试着百度了一下“lambda”，啥都没查到，然后继续搜“lambda 邱奇”，发现“邱奇数 百度百科”，然后继续搜“邱奇数”，搜到了这个。于是开始研究..前面 $6$ 个点有的是自己想的，有的是看懂之后写的，78是直接抄的。最后混到个15名..lx特别ba…只不过今天又来了几个人，感觉不抄的话二三十名好像也有，也海星啦… Day 40最后一天了呢..已经在布置THUWC了。 今天的题暴力档特别少..又是1h拿到了 $48$ 然后肝不出了…T3有很多人A，和之前D16T2有点像，是给一个排列问划分成若干个连续段的方案数，做法也比较类似，然而没想起来，也不会做… 这 $40$ 天好多想补的知识点也没补完..题也没怎么改..总体来说挺颓的…最后两天再稍微补一补，调整一下状态吧，考出应有的成绩就好。这篇博客大概就这样完结了，下次就是THUWC/WC游记了。 Day 41本来应该结束了的..今天没去学校，10点的时候dew突然告诉我今天有场比赛？？一看是THUSCH2017原题，然后T1 dl线段树写了2h没调出来…只不过好像并不是膜你赛，广二OJ很早就有这几题了，今天的standing也只有6个人… 然后..窝竟然真的在WC前把kanon补完了..]]></content>
      <tags>
        <tag>游记</tag>
        <tag>集训</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AtCoder Beginner Contest 115 游记]]></title>
    <url>%2FAtCoder-Beginner-Contest-115%2F</url>
    <content type="text"><![CDATA[之前听教练安利，就来打了场 AtCoder。 -5h比赛地址 一开始看到 “Beginner”的时候我还迟疑了一下，看了下上一场 Beginner 的题目，又在网上搜了一下，想着可以熟悉一下 AtCoder ，就准备打了。 0min咕咕咕 5min咕咕咕咕咕咕 只不过幸好咕咕了，我的模板还没搞好..赶紧新建文件夹 atcoder\AtCoder Beginner Contest 115 ，把 $4$ 个用于 CF 的模板扔进去。 10min开始了！ 用了 $0.1s$ 决定用 switch 而不是 if else 。 用了不知道多久敲完。 没测样例（废话）直接交了。 其实我现在还在想，如果 WJ 的时候我去写 T2 而不是刷新看结果会不会涨个一两名… 12min看了下 $10\times10000&lt;10^9$ 。 用了不知道多久敲完。 测了样例交了。 其实我现在还在想，如果没测样例我会不会再涨个一两名… 14min想了想还是用了快读，毕竟模板里有。 测样例，没写cout&lt;&lt;ans; 。 其实我现在还在想，其实我现在还在想，如果没测样例我会不会掉个十几名。 16min数据范围看起来好小。 等等，$x$ 的范围？ 预处理汉堡的大小。 哦，爆 int 了。 其实我现在还在想，如果模板里有#define int long long我会不会再涨个一两名… 写个函数 work(int a) 处理大小为 $a$ 的汉堡，分类讨论乱搞一下应该就行了。 测样例，#3 看起来好大。 终于可以安心地看 judging 不用担心浪费时间了。 130minBeginner 定级貌似最高 400 点 rating..]]></content>
      <tags>
        <tag>游记</tag>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WC2019 全国模拟赛第二场 T1 题解]]></title>
    <url>%2FWC2019-%E5%85%A8%E5%9B%BD%E6%A8%A1%E6%8B%9F%E8%B5%9B%E7%AC%AC%E4%BA%8C%E5%9C%BA-T1-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[又只会写T1… 题目链接 题意简述给你一个排列 $p_{1..n}$，$a_{1..n}$ 为任意的一个排列，定义 $b[a_i]=a[p_i]$，求总共有多少个不同的 $b_{1..n}$ 。 做法首先，对 $(i,p_i)$ 连边，会得到若干个环。 环上旋转一下（$\forall i\text{ on the cycle : }i\rightarrow p_i$）得到的置换是本质相同的。节点个数相同的环互换一下是本质相同的。 先计算把 $n​$ 个节点分成若干个环的方案数：（用 $siz[i]​$ 表示第 $i​$ 个环的大小，$k​$ 表示环的个数，$sum[i]​$ 表示 $\sum\limits_{j=i}^ksiz[j]​$） $$S_1=\prod\limits_{i=1}^kC_{sum[i]}^{siz[i]}$$ 然后去掉节点个数相同的环互相交换：（用 $num[i]$ 表示节点个数为 $i$ 的环的个数） $$S_2=\frac{S_1}{\prod\limits_{i=1}^nnum[i]!}$$ 然后乘上每个环旋转（旋转造成的不同方案数即固定某个数后剩下的数的排列个数）： $$S_3=S_2\times\prod\limits_{i=1}^k(siz[i]-1)!$$ $S_3$ 就是最终的答案了。 参考代码noi.ac 上最短解（其实计算方式和我是一样的..）： 12345678910111213141516#include&lt;bits/stdc++.h&gt;#define mn 1111111using namespace std;long long n,i=1,s=1,j,x,p=998244353,a[mn],f[mn],v[mn],t[mn];int main()&#123; scanf("%lld",&amp;n); f[0]=f[1]=1; for (;i&lt;=n;i++) scanf("%lld",a+i); for (i=2;i&lt;=n;i++) f[i]=f[p%i]*(p-p/i)%p,(s*=i)%=p; for (i=1;i&lt;=n;i++) if (!v[i]) &#123; for (j=i,x=0;!v[j];x++,j=a[j]) v[j]=1; (s*=f[x]*f[++t[x]]%p)%=p; &#125; printf("%lld",s);&#125; 我自己赛时的辣鸡写法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cctype&gt;using namespace std;int read()&#123; int out=0; char c; while (!isdigit(c=getchar())); for (;isdigit(c);c=getchar()) &#123; out=out*10+c-'0'; &#125; return out;&#125;const int N=1000010;const int M=998244353;void dfs(int u);int c(int a,int b);int n,p[N],dfn[N],low[N],sta[N],dfncnt,top,siz[N],tot,num[N];int x,y,jc[N],inv[N],ans=1,sum;bool ins[N];int main()&#123; int i; n=sum=read(); for (i=1;i&lt;=n;++i) &#123; p[i]=read(); &#125; for (i=1;i&lt;=n;++i) &#123; if (dfn[i]==0) &#123; dfs(i); &#125; &#125; jc[0]=jc[1]=inv[0]=inv[1]=1; for (i=2;i&lt;=n;++i) &#123; inv[i]=(1ll*M*M-1ll*(M/i)*inv[M%i])%M; &#125; for (i=2;i&lt;=n;++i) &#123; jc[i]=(1ll*jc[i-1]*i)%M; inv[i]=(1ll*inv[i-1]*inv[i])%M; &#125; for (i=1;i&lt;=tot;++i) &#123; ans=1ll*ans*c(sum,siz[i])%M; sum-=siz[i]; &#125; for (i=1;i&lt;=n;++i) &#123; ans=1ll*ans*inv[num[i]]%M; &#125; for (i=1;i&lt;=tot;++i) &#123; ans=1ll*ans*jc[siz[i]-1]%M; &#125; cout&lt;&lt;ans; return 0;&#125;int c(int a,int b)&#123; if (a==b||b==0) &#123; return 1; &#125; return 1ll*(1ll*jc[a]*inv[b]%M)*inv[a-b]%M;&#125;void dfs(int u)&#123; dfn[u]=low[u]=++dfncnt; sta[++top]=u; ins[u]=true; if (dfn[p[u]]==0) &#123; dfs(p[u]); low[u]=min(low[u],low[p[u]]); &#125; else if (ins[p[u]]) &#123; low[u]=min(low[u],dfn[p[u]]); &#125; if (low[u]==dfn[u]) &#123; siz[++tot]=1; while (sta[top]!=u) &#123; ++siz[tot]; ins[sta[top--]]=false; &#125; ins[sta[top--]]=false; ++num[siz[tot]]; &#125;&#125; 所以说不要看到环就 tarjan…]]></content>
      <tags>
        <tag>题解</tag>
        <tag>noi.ac</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客搭建指北]]></title>
    <url>%2Fhexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8C%97%2F</url>
    <content type="text"><![CDATA[折腾了 $3$ 天终于把博客搭建好了…本文会简单介绍一下hexo博客的搭建，并选取一些我自己在配置博客的过程中遇到的问题，说明一下我的解决方案。 实际上，hexo博客的搭建并不难，难搞的是美化，我在这个过程中遇到了很多问题，不可能在这篇博客中全部陈述出来，最重要的还是勤于百度。 本篇博客不完全按照顺序撰写，可以通过页面左边的目录跳转阅读。 博客的搭建先推荐两篇比较好的教程：搭建个人博客-hexo+github详细完整步骤，使用github+Hexo人人都能拥有一个美美的博客。 这部分网上讲的已经比较好了，我在这就简单说一下。 安装软件需要安装的软件有：git，Node.js。 下载安装即可… 本地设置装好之后，在本地创建一个文件夹，下文中称其为“根目录”。 下文中“输入命令”均指在命令行中输入命令（并回车废话），既可以使用 git bash，也可以使用 cmd 或 powershell 。输入命令时若无特别说明都需要 cd 到根目录下。 输入命令 npm install -g hexo 来安装 hexo 。 输入命令 hexo init 来初始化 hexo 。 输入命令 npm install 来安装一些需要的包。 输入命令 hexo s，并在浏览器打开 localhost:4000，在本地预览博客；如果上文步骤进行正确，应该看到一个类似于这样的页面： 注：命令可以缩写，条件是没有开头几个字母相同的其它命令。hexo s 实际上是 hexo server 的缩写；下文中 hexo d 是 hexo deploy 的缩写，hexo g 是 hexo generate 的缩写；hexo clean 不能缩写为 hexo c，因为存在命令 hexo config ，但是可以缩写为 hexo cl 。 按 Ctrl+C 关闭 server 以继续操作。（若出现类似于 终止批处理操作吗(Y/N)? 的提示，输入 y 即可。） 接着安装博客的主题，可以在 hexo 官网 选择主题下载，本篇教程推荐使用 NexT 主题。 在 hexo 官网 点击图片下方蓝色的文字即可打开主题的 GitHub 主页，一般来说，一个主题的 GitHub 主页上是有用于安装的命令以及配置博客的教程的。 如果没有的话（或者即使有也一样），你应该输入命令 git clone 主题的Github主页地址 themes/主题名 。例如：git clone https://github.com/theme-next/hexo-theme-next themes/next 。 当然，你也可以使用默认的 landscape 主题，从而不用额外下载主题。 下载好主题后，用任何一款文本编辑器（记事本也可以），打开根目录下的 _config.yml ，将 theme: landscape 修改为 theme: 你想用的主题名 即可。 配置 GitHub 仓库首先你需要有一个 GitHub 账号。 然后点击右上角你的头像，打开“Your repositories”，点击绿色的按钮“New”。 在”Repository name”一栏填入 yourname.github.io （“yourname”指你的 GitHub ID，比如我就填 ouuan.github.io），”Description”可以随便填也可以不填，然后点绿色的按钮“Create repository”。 将博客上传至 GitHub输入命令 ssh-keygen 来生成 SSH，让你输入东西你就空着，按回车（应该要按三次回车）。 然后用任意的文本编辑器打开 C:\Users\电脑用户名\.ssh\id_rsa.pub（如果装了 vim 可以直接输入命令 vim ~/.ssh/id_rsa.pub），复制里面的内容。 打开 GitHub，点击右上角的头像，打开“Settings”，选择左边的“SSH and GPG keys”，点绿色的按钮“New SSH key”，Title 随便填，下面的 Key 把刚才复制的东西粘贴进去，然后点绿色的按钮“Add SSH key”。过程中可能需要输入密码。 输入命令 ssh -T git@github.com ，若出现 Hi yourname! You&#39;ve successfully authenticated, but GitHub does not provide shell access. 表示 SSH 配置成功。 输入命令 npm install hexo-deployer-git --save 安装 deployer 。 打开根目录下的 _config.yml ，将最后几行改为： 1234deploy: type: git repository: https://github.com/yourname/yourname.github.io.git branch: master 当然”yourname”要改成你的 GitHub ID 。 依次输入命令： 123hexo cleanhexo ghexo d 这一步可能要输入密码。 等几分钟，再用浏览器打开 yourname.github.io ，应该就可以看到你的博客了。（此时别人也可以通过这个网址看到你的博客） 域名的配置实际上，自定义域名基本上没有什么用。但是有一个自己的域名还是一件比较爽的事，会感觉摆脱了束缚（实际上你还是用着 GitHub…）。 域名的获取本篇教程只讲解如何免费获取域名（的 $12$ 个月使用权），当然你也可以通过其它方式购买域名。 打开 Freenom，输入自己想用的域名，点击”Check Availability”，有“Get it now”的就是能用的。 选择好你要的域名后，点右上角的”Checkout”，Period 选择”12 Months @ FREE”，然后点”Continue”，输入邮箱登录或使用其它账号（如 Google 账号）登录（输入邮箱登录经常会出错，而使用其它账号登录需要科学上网）。 DNS 配置我使用的是 cloudfare，（因为在学校搭建的博客，手机没电了，国内的服务商注册都需要短信验证码），还是比较方便的。 先注册一个账号，然后点”Add site”，输入你刚刚获取的域名。 然后进入站点设置里的 DNS 设置，如图添加两条记录： 1185.199.109.153 当然要记得把“yourname”换成你的 GitHub ID。推荐关闭 cdn 服务，即点击一下橙色的云使其变成灰色。 完成后应该是这样的： 连接域名和 DNS回到 Freenom，登录网站，点击右上角的“Services” $\rightarrow$ “My Domains”，找到你刚刚获取的域名，点击 “Manage Domain” $\rightarrow$ “Management Tools” $\rightarrow$ “Nameservers”。 再回到 cloudfare，就在刚刚 DNS 设置的下面，有两个域名： 再回到 Freenom，把这两个域名复制进去，然后点”Change Nameservers”。 连接域名和 GitHub在 hexo 根目录的 source 子目录下新建文件 CNAME（没有后缀名），用文本编辑器打开，输入如下内容： 当然要替换成你获取的域名。 然后再输入命令 hexo d ，过几分钟应该就可以从你获取的域名访问你的博客了。 开启https如果不开启的话，访问 https://你的域名 就会显示警告，访问 http://你的域名 就会显示不安全。 当然如果因为某种原因访问 https://你的域名 已经不会显示警告而且浏览器左上角有绿锁了，就不需要再进行额外的设置了。 其实很简单，浏览器打开 https://github.com/yourname/yourname.github.io/settings ，找到这里： 如果”Enforce HTTPS”前没有打勾，打勾即可。 如果”Enforce HTTPS”前面是灰色的，无法打勾： 删掉”Save”前面的域名，点击”Save”。 重新输入域名，点击”Save”。 重新发布博客（hexo d）。 等待几分钟~几小时，再访问你的博客应该就OK了。 停用域名由于免费的域名还是经常会出一些小问题，而且不可避免地会碰上域名到期的问题，所以我在用了半个月自定义域名后停用了.. 单纯停用只需删去 CNAME 文件即可，然后记得更改相关设置（在各种地方引用的博客链接、OAuth App 地址……）。 然而，在停用后，我自己的电脑上一直无法打开博客主页（会自动跳转到原自定义域名），别人的电脑/手机上可以正常打开。 解决方法：F12 $\rightarrow$ Network $\rightarrow$ Disable Cache 勾选后 Ctrl + F5 强制刷新博客主页，然后就可以进了，取消勾选 Disable Cache 后依然正常。 方法来源 博客的配置与美化根目录下的 _config.yml这部分参考官网教程即可。 主题目录下的 _config.yml主题目录下的 _config.yml 指 \themes\主题名\_config.yml。 这里以 NexT 主题（本文基于 NexT 6.6，其它版本可能有些区别）为例，这个主题的 _config.yml 非常完备，修改配置基本上只需删除/添加注释符号 # 以及改变 true/false 即可。 选择 NexT 主题的四种之一12345# Schemesscheme: Muse#scheme: Mist#scheme: Pisces#scheme: Gemini 将想用的主题前的 # 删掉，在 scheme: Muse 前加上 # 即可。 例如： 12345# Schemes#scheme: Muse#scheme: Mist#scheme: Piscesscheme: Gemini 四种主题的预览在 NexT 主题的官网有。 改变网站图标12345favicon: small: /images/favicon-16x16-next.png medium: /images/favicon-32x32-next.png apple_touch_icon: /images/apple-touch-icon-next.png safari_pinned_tab: /images/logo.svg 将你想用的图标放在 \themes\next\source\images 里，然后修改上面的文件名即可。 例如： 123favicon: small: /images/favicon16.png medium: /images/favicon32.png 页脚设置1234567891011121314151617181920212223242526272829303132333435footer: # Specify the date when the site was setup. # If not defined, current year will be used. #since: 2015 # Icon between year and copyright info. icon: # Icon name in fontawesome, see: https://fontawesome.com/v4.7.0/icons # `heart` is recommended with animation in red (#ff0000). name: battery-full # If you want to animate the icon, set it to true. animated: false # Change the color of icon, using Hex Code. color: &quot;#808080&quot; # If not defined, will be used `author` from Hexo main config. copyright: # ------------------------------------------------------------- powered: # Hexo link (Powered by Hexo). enable: false # Version info of Hexo after Hexo link (vX.X.X). version: true theme: # Theme &amp; scheme info link (Theme - NexT.scheme). enable: true # Version info of NexT after scheme info (vX.X.X). version: true # ------------------------------------------------------------- # Beian icp information for Chinese users. In China, every legal website should have a beian icp in website footer. # http://www.miitbeian.gov.cn beian: enable: false icp: icon： © 2019 与用户名之间的图标。（图中 $1$） 图标名称为 Font Awesome 上的图标名称。 powered.enable：为 true 则会显示“由 Hexo 强力驱动”。（图中 $2$） powered.version：为 true 则会显示 Hexo 的版本。（图中 $3$） powered.enable：为 true 则会显示“主题 – NexT.XX”。（图中 $4$） powered.version：为 true 则会显示主题的版本。（图中 $5$） 注：根据 NexT 主题的 LICENSE，footer 中必须开启 powered.enable 选项。 “关于”&amp;”标签”123456789menu: home: / || home about: /about/ || user tags: /tags/ || tags #categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 将需要的项目取消注释即可在侧边栏显示。 如果需要使用“关于”页面，输入命令 hexo new page &quot;about&quot;。 然后在 \source\about\index.md 中就可以编辑“关于”页面了。 可以修改 \source\about\index.md 中的 title 项来显示“关于”而非“about”。 如果需要使用“标签”功能，需要在博文中添加选项 tags ： 如果有多个标签，每行一个，以 - 开头： 1234tags:- 标签1- 标签2- 标签3 如果需要使用“标签”页面，输入命令 hexo new page &quot;tags&quot;。 然后向 source\tags\index.md 中添加一行： 1type: &quot;tags&quot; 站内搜索输入命令 npm install hexo-generator-searchdb --save 安装所需的库。 在根目录下的 _config.yml 的结尾加入： 12345search: path: search.xml field: post format: html limit: 10000 然后在 \themes\next\_config.yml 中，打开 local_search： 12local_search: enable: true 社交网站123456789101112131415# Social Links.# Usage: `Key: permalink || icon`# Key is the link label showing to end users.# Value before `||` delimeter is the target permalink.# Value after `||` delimeter is the name of FontAwesome icon. If icon (with or without delimeter) is not specified, globe icon will be loaded.social: GitHub: https://github.com/ouuan || github 洛谷: https://www.luogu.org/space/show?uid=49742 || code Codeforces: https://www.codeforces.com/profile/ouuan || code b站: https://space.bilibili.com/11067182 || tvsocial_icons: enable: true icons_only: false transition: false 在 social 下每行一个，格式为：名称: 地址 || 图标。 其中，“图标”为 Font Awesome 图标名称，但有些图标是不可用的，而且图标也不全，使用的时候要尝试一下图标是否可用。 12social_icons: enable: false 这样设置可以只显示名称不显示图标。 友情链接（或其它链接）123456789101112# Blog rollslinks_icon: globelinks_title: 友情链接# links_layout: blocklinks_layout: inlinelinks: Dew: https://www.cnblogs.com/ppprseter/ wjyyy: https://www.wjyyy.top/ Sooke: https://www.luogu.org/blog/Sooke/ huyufeifei: https://www.cnblogs.com/huyufeifei/ Rye_Catcher: https://rye-catcher.github.io/ 额冻豆腐: http://www.mayflyyh.com/ links_icon：显示在标题前的图标。 links_title：标题。 links_layout：block 一行一个，inline 一行多个。 links：要显示的链接以及名称。 头像123456789101112# Sidebar Avataravatar: # in theme directory(source/images): /images/avatar.gif # in site directory(source/uploads): /uploads/avatar.gif # You can also use other linking images. url: /images/avatar.jpg # If true, the avatar would be dispalyed in circle. rounded: true # The value of opacity should be choose from 0 to 1 to set the opacity of the avatar. opacity: 1 # If true, the avatar would be rotated with the cursor. rotated: false url：头像地址，留空则不显示头像。 rounded：圆/方头像。 opacity：不透明度。 rotated：随光标旋转。 回到顶部按钮/阅读百分比12345# Back to top in sidebar (only for Pisces | Gemini).b2t: true# Scroll percent label in b2t button.scrollpercent: true 博客首页不显示全文在博文里可以用 &lt;!-- more --&gt; 来标识在首页显示到哪为止。 可以在 \themes\next\_config.yml 里设置到一定字数自动不显示全文： 123456789# Automatically Excerpt. Not recommend.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt: enable: true length: 150# Read more button# If true, the read more button would be displayed in excerpt sectionread_more_btn: true length：不显示全文的字数上限。 read_more_btn： 代码块复制按钮123456789codeblock: # Manual define the border radius in codeblock # Leave it empty for the default 1 border_radius: # Add copy button on codeblock copy_button: enable: true # Show text copy result show_result: true enable：启用复制按钮。 show_result： $\LaTeX$1234567891011# Math Equations Render Supportmath: enable: true # Default(true) will load mathjax/katex script on demand # That is it only render those page who has &apos;mathjax: true&apos; in Front Matter. # If you set it to false, it will load mathjax/katex srcipt EVERY PAGE. per_page: false engine: mathjax #engine: katex enable：启用 $\LaTeX$ 。 per_page：为 true 则只有博文中有 mathjax: true 才会启用 $\LaTeX$，否则每篇博客都会启用 $\LaTeX$ 。 engine：推荐使用 mathjax 。 hexo 博客的 mathjax 和 Markdown 有一些冲突，将在后文专门讲解如何解决冲突。 评论功能由于 gitment 的服务器有一些问题，推荐使用 gitalk： 1234567gitalk: enable: true github_id: yourname repo: yourname.github.io client_id: client_secret: admin_user: yourname 这里需要在 GitHub 新建一个 OAuth App，”Homepage URL”和”Authorization callback URL”填你的域名（如果没有申请域名的话就填 yourname.github.io）： 需要注意的是，地址要严格和博客访问地址一样，http 和 https不能混，有无 www 也不能混。 然后将 Client ID 和 Client Secret 填入 \themes\next\_config.yml 中。 评论功能无法在本地正常预览，需要发布才能使用。 访客记录12busuanzi_count: enable: true 书签书签的功能是关闭页面/手动点击书签按钮时，保存这篇博客看到的位置，下次点进这篇博客时继续从这个位置开始。 安装插件：git clone https://github.com/theme-next/theme-next-bookmark.git source/lib/bookmark 更改 \themes\next\_config.yml： 123456789# Bookmark Support# Dependencies: https://github.com/theme-next/theme-next-bookmarkbookmark: enable: true # if auto # - save the reading position when closing the page # - or clicking the bookmark-icon # if manual, only save it by clicking the bookmark-icon save: manual 其它配置博客背景打开 \themes\next\source\css\_custom\custom.styl，输入： 1234body &#123; background-image:url(/images/background.jpg); background-size: cover;&#125; 把背景图片重命名为 background.jpg，放入 \themes\source\images（当然也可以更改background-image:url()）。 background-size: cover; 表示宽度缩放至页面大小。 123456body &#123; background-image:url(/images/background.jpg); background-repeat: no-repeat; background-attachment:fixed; background-size: cover;&#125; 如果修改成这样的话背景图片就不会滚动。 如果不想让博客内容挡住背景，可以设置博客内容的透明度，在 \themes\next\source\css\_custom\custom.styl 中加入下面的代码即可： 123.main-inner &#123; opacity: 0.8;&#125; 博文自定义排序打开 \node_modules\hexo-generator-index\lib\generator.js 。 在末尾添加如下代码： 12345678910111213posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; if(a.top == b.top) return b.date - a.date; else return b.top - a.top; &#125; else if(a.top &amp;&amp; !b.top) &#123; return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date;&#125;); 在博文设置中加入 top: x 即可，会以 top 为第一关键字，时间为第二关键字排序。若 top 为空则视作 -INF 。 README.md如果想在 https://github.com/yourname/yourname.github.io 让别人看到你的博客的简介，就需要写一个 README.md 放在根目录下的 source 文件夹内。 然而，只是这样的话， README.md 会被渲染成 html，所以需要更改根目录下 _config.yml 的设置： 1skip_render: README.md 自定义404页面首先写一个 \source\404.html 。 至于怎么写html..这里地方太小写不下 事实上可以新建一篇博客，用 Markdown 写一个 404 页面，然后 hexo g 在 \public 里找到博客的页面，把相关部分直接复制过来。 可以参考一下我的： 1234567&lt;body&gt; &lt;div&gt; &lt;p style="text-align: center;"&gt;&lt;strong&gt;您可能访问了错误的网址&lt;/strong&gt;&lt;img src="https://i.loli.net/2018/10/27/5bd4705dd844f.jpg"&gt;&lt;/p&gt; &lt;p style="text-align: center;"&gt;&lt;a href="https://www.ouuan.cf"&gt;&lt;strong&gt;回到博客主页&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt; &lt;p style="text-align: center;"&gt;&lt;a href="javascript:history.go(-1);"&gt;&lt;strong&gt;返回上一页&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt; &lt;/div&gt;&lt;/html&gt; 然后，如果直接这样发布，html 会被渲染，就跟一个自定义页面（hexo new page）一样了。 所以要修改根目录下的 _config.yml，在 skip_render: 后添加 404.html，如果有多项用 - 隔开： 123skip_render: - README.md - 404.html 发布完成后，访问一个错误的网址，比如 你的域名/qaq 就可以查看效果了。 一言（ヒトコト）大约是这个。 网上没找到教程，自己随便瞎研究了一波，所以方法比较丑陋，仅供参考.. 本来想稍微写一下自己研究的经过，想了想自己也没完全搞清楚，就来一波授人以鱼吧… \themes\next\layout\_macro\sidebar.swig: 1234567891011121314151617…… &lt;aside id="sidebar" class="sidebar"&gt; &lt;div class="sidebar-inner"&gt; &lt;div&gt; &lt;div style="display: table-cell;vertical-align: top; color:#B2B7F2;font-size:24px;font-family:'Times New Roman',serif;font-weight:bold;text-align:left;"&gt;“&lt;/div&gt; &lt;div style="display: table-cell;text-align: left; vertical-align: middle; text-indent: 2em; padding: 0.8em 0.2em 1em 0.2em"&gt;&lt;b&gt;&lt;span style="color:burlywood;"&gt;&lt;span id="hitokoto-content"&gt;&lt;/span&gt;&lt;/span&gt;&lt;/b&gt;&lt;/div&gt; &lt;div style="display: table-cell; vertical-align: bottom; color:#B2B7F2;font-size:24px;font-family:'Times New Roman',serif;font-weight:bold;text-align:left;"&gt;”&lt;/div&gt; &lt;/div&gt; &lt;div style="text-align: right; font-size: 0.8em; color: black;" id="hitokoto-from"&gt;&lt;/div&gt; &lt;div style="margin-top: 15px; font-size: 0.8em; color: black;"&gt;&lt;a href="https://hitokoto.cn/"&gt;Hitokoto&lt;/a&gt;&lt;/div&gt; &lt;/div&gt; &lt;div style="height: 15px"&gt;&lt;/div&gt; &#123;% if theme.sidebar.onmobile %&#125;…… \themes\next\layout\_scripts\commons.swig: 1234567……&lt;script type="text/javascript"&gt; $.get('https://v1.hitokoto.cn/?c=a', function (data) &#123; $('#hitokoto-content').css('display', '').text(data.hitokoto); $('#hitokoto-from').css('display', '').text('——' + data.from); &#125;);&lt;/script&gt; \themes\next\source\css\_custom\custom.styl: 1234…….sidebar &#123; background: rgba(0, 0, 0, 0);&#125; 大约就这样，省略号表示文件中本来就有的其它部分。不保证在其他人电脑上可以用。大致思路就是搞个空 div 指定一个 id，用 js 往里面塞东西。所以即使我这个“鱼”不能直接用大约也是可以稍微研究研究来用的。 博客的写作Markdown 的使用网上有很多 Markdown 的学习资源，我自己是在洛谷剪贴板学会的。 我以前一般都用洛谷剪贴板编辑 Markdown，但 hexo 博客需要在本地编辑 .md 文件，这时普通的文本编辑器就不太方便了。我推荐 Typora 这款软件，还是挺方便的。 撰写博客前的准备打开根目录下的 _config.yml ，将 post_asset_folder 设为 true。 这样就可以把图片放到博客里而不用其它图床了。 然后把 \source\_posts\hello-world.md 删除。 Hexo 博客的撰写新建一篇博客：hexo new &quot;博客名&quot;。 然后等几秒钟，在 \source\_posts 文件夹下，就会生成 博客名 这个文件夹（如果你把 post_asset_folder 设为 true 了）以及 博客名.md。 撰写博客就是编辑 博客名.md。 这个文件的开头是博客的一些设置，可以在 scaffolds\posts.md 中修改默认设置，我的默认设置是： 123456---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;tags: top: --- 然后就可以写 Markdown 格式的文章了。（top 是自定义文章排序，上文中介绍过） 需要注意的是，在洛谷代码块可以不加”cpp”，但在 hexo 上，一定要加上”cpp”： 12345#include &lt;iostream&gt;int main()&#123; cout&lt;&lt;&quot;hello world!&quot;&#125; 12345#include &lt;iostream&gt;int main()&#123; cout&lt;&lt;"hello world!"&#125; 引用本地图片引用链接/网络上的图片格式与普通 Markdown 相同（[链接名称](链接地址) 和 ![图片描述](图片地址)），引用本地图片需要把 post_asset_folder 设为 true ，然后把图片放在与博客同名的文件夹中，然后只用 ![图片描述](图片文件名) 就可以引用了。 在编辑器里显示不出图片是正常的。 还有另一种方式引用图片， 用这种方式引用图片的话，把鼠标放在上面会显示图片描述（上面这张图就是用这种方式引用的）。 只有这种方式引用图片才能在博客首页正常显示图片，否则只能点进博客才能看到图片。 $\LaTeX$ 的使用$\LaTeX$ 概述$\LaTeX$ 主要用于编辑数学公式，十分方便，网上也有很多学习资源，比如：LaTeX数学公式大全。 在支持 $\LaTeX$ 的 Markdown 文档里，使用两个美元符号将 $\LaTeX$ 公式括起来，例如： 1~~QAQ$f_i=\sum\limits_&#123;j=1&#125;^ia_j$f_i=\sum\limits_&#123;j=1&#125;^ia_j~~ QAQ$f_i=\sum\limits_{j=1}^ia_j$f_i=\sum\limits_{j=1}^ia_j 也可以用一对双美元符号使公式居中显示在单行，例如： 123$f_i=1$$$f_i=1$$ $f_i=1$ $$f_i=1$$ 在 Typora 中使用 $\LaTeX$ 需要将设置中的”Markdown 扩展语法”全部勾选。 P.S. $\LaTeX$：\LaTeX 启用 $\LaTeX$在 \themes\next\_config.yml 中将 mathjax 设为 true，然后将 per_page 设为 false 或者在需要启用 \LaTeX 的博文开头加上 mathjax: true 。 解决冲突由于hexo博客中即使是$$内的字符也会被当成 Markdown 渲染，类似于 $f_{f_i}$、$a*b*c$、$[x,y](1&lt;x&lt;y&lt;2)$ 之类的，都会被错误地渲染。 解决这个问题，首先要打开 \node_modules\marked\lib\marked.js，搜索 nolink，应该在 $470$ 行左右。 然后，将这一块修改为： 123456789101112131415var inline = &#123; escape: /^\\([`*\[\]()# +\-.!_&gt;])/, autolink: /^&lt;(scheme:[^\s\x00-\x1f&lt;&gt;]*|email)&gt;/, url: noop, tag: /^&lt;!--[\s\S]*?--&gt;|^&lt;\/?[a-zA-Z0-9\-]+(?:&quot;[^&quot;]*&quot;|&apos;[^&apos;]*&apos;|\s[^&lt;&apos;&quot;&gt;\/\s]*)*?\/?&gt;/, link: /^!?\[(inside)\]\(href\)/, reflink: /^!?\[(inside)\]\s*\[([^\]]*)\]/, nolink: /^!?\[((?:\[[^\[\]]*\]|\\[\[\]]|[^\[\]])*)\]/, strong: /^__([\s\S]+?)__(?!_)|^\*\*([\s\S]+?)\*\*(?!\*)/, em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/, code: /^(`+)\s*([\s\S]*?[^`]?)\s*\1(?!`)/, br: /^ &#123;2,&#125;\n(?!\s*$)/, del: noop, text: /^[\s\S]+?(?=[\\&lt;!\[`*]|\b_| &#123;2,&#125;\n|$)/&#125;; 这样做取消了 _text_ 的斜体意义，但 *text* 仍会被转义为斜体。 解决办法有两种： 放弃使用 * ，全部用 \times 代替或者省略掉。 取消 * 的转义。 推荐使用第一种方法，否则你的博客中就无法使用斜体了。 如果想要使用 * 而放弃斜体： 在 \node_modules\marked\lib\marked.js 中搜索 Renderer.prototype.em ，应该在 $884$ 行左右。 将这一段改为： 123Renderer.prototype.em = function(text) &#123; return &apos;*&apos; + text + &apos;*&apos;;&#125;; 前文提到了，hexo博客中即使是$$内的字符也会被当成 Markdown 渲染，所以类似于 $[x,y](1&lt;x&lt;y&lt;2)$ 的，要在 ] 和 ( 中间加一个空格，就不会被错误地转义了。 博客的发布其实前文提到过，依次输入以下三条命令即可： 123hexo clhexo ghexo d 发布之前还可以执行 hexo s 并在本地使用浏览器打开 localhost:4000 进行预览。 当然也可以使用 hexo g -d 命令。]]></content>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WC2019 全国模拟赛第一场 T1 题解]]></title>
    <url>%2FWC2019-%E5%85%A8%E5%9B%BD%E6%A8%A1%E6%8B%9F%E8%B5%9B%E7%AC%AC%E4%B8%80%E5%9C%BA-T1-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[由于只会T1，没法写游记，只好来写题解了… 题目链接 题目大意给你一个数列，每次可以任取两个不相交的区间，取一次的贡献是这两个区间里所有数的最小值，求所有取法的贡献和，对 $10^9+7$ 取模。 数列长度 $2\times 10^5$ ，值域 $1$ ~ $10^9$ 。 $O(n^4)$ 做法预处理区间最小值，枚举选的两个区间。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int M=1000000007;int n,a[60][60],ans;int main()&#123; int i,j,k,l; cin&gt;&gt;n; for (i=1;i&lt;=n;++i) &#123; cin&gt;&gt;a[i][i]; &#125; for (i=1;i&lt;n;++i) &#123; for (j=i+1;j&lt;=n;++j) &#123; a[i][j]=min(a[i][j-1],a[j][j]); &#125; &#125; for (i=1;i&lt;n;++i) &#123; for (j=i;j&lt;n;++j) &#123; for (k=j+1;k&lt;=n;++k) &#123; for (l=k;l&lt;=n;++l) &#123; ans=(ans+min(a[i][j],a[k][l]))%M; &#125; &#125; &#125; &#125; cout&lt;&lt;ans; return 0;&#125; $O(nlogn)$ 做法 warning：接下来的文章里“的”字嵌套情况非常严重，文字叙述比较繁杂，看不懂十分正常，建议看懂一小部分然后自己推。 考虑每个元素作为贡献的区间是哪些，为了把每个区间分给唯一的元素，规定一个区间的贡献是最小值里最靠左的（ e.g. 4 3 2 4 2 2 的贡献是 $3$ 号元素，即最左边的 $2$ ）。所以，可以利用栈在 $O(n)$ 的时间内预处理出每个元素作为贡献的区间的左端点和右端点的范围： 123456789101112131415161718192021222324252627for (i=1;i&lt;=n;++i)&#123; while (top&amp;&amp;a[sta[top]].w&gt;a[i].w) &#123; a[sta[top--]].r=i-1; &#125; sta[++top]=i;&#125;while (top)&#123; a[sta[top--]].r=n;&#125;for (i=n;i&gt;=1;--i)&#123; while (top&amp;&amp;a[sta[top]].w&gt;=a[i].w) &#123; a[sta[top--]].l=i+1; &#125; sta[++top]=i;&#125;while (top)&#123; a[sta[top--]].l=1;&#125; 每个元素作为贡献的区间就是 $[x,y] (l_i\le x\le i\le y\le r_i)$，每个元素作为贡献的区间数就是 $t_i=(i-l_i+1)\times(r_i-i+1)$ 。 然后，将元素按值从大到小排序，就能计算出区间数的后缀和 $suf[i]$，但一个元素的总贡献并不是 $t_i\times suf[i+1]$，因为这些区间可能与当前元素作为贡献的区间相交。 注意到，要想和当前元素作为贡献的区间相交，必须 $[x,y] (l_i\le x\le y\le r_i)$ ，而这样的区间除了当前元素作为贡献的区间，贡献都排在当前元素之后（值比当前元素大或值相等但位置靠后），所以这样的区间除了当前元素作为贡献的区间，都是我们要找的与当前元素作为贡献的区间相交的贡献更靠后的区间。 注：下面这段话中“相交的区间对”指（与当前元素作为贡献的区间相交的贡献更靠后的区间，当前元素作为贡献的区间）这样的一对区间；“相交的区间”指与当前元素作为贡献的区间相交的贡献更靠后的区间。 接下来就要计算相交的区间有多少对。首先，相交的区间不可能跨过当前元素，否则就是当前元素作为贡献的区间；所以，相交的区间要么是 $[x,y] (l_i\le x\le y&lt;i)$ ，要么是 $[x,y] (i&lt;x\le y\le r_i)$。先计算 $[x,y] (l_i\le x\le y&lt;i)$ 与当前元素作为贡献的区间相交的对数，先考虑 $y$ 固定时，个数为 $(r_i-i+1)\times(y-l_i+1)^2$ ，其中：$y-l_i+1$ 既是相交的区间左端点的个数，也是与相交的区间相交的当前元素作为贡献的区间的左端点的个数；$r_i-i+1$ 是与相交的区间相交的当前元素作为贡献的区间的右端点的个数。所以，总数是 $(r_i-i+1)\times\sum\limits_{y=l_i}^{i-1}(y-l_i+1)^2$ ，乘号右边是自然数平方和，可以用公式计算，所以就是 $(r_i-i+1)\times\frac{(i-l_i)\times(i-l_i+1)\times(2i-2l_i+1)}6$ 。$[x,y] (i&lt;x\le y\le r_i)$ 同理，总数为 $(i-l_i+1)\times\frac{(r_i-i)\times(r_i-i+1)\times(2r_i-2i+1)}6$ 。 所以，把相交的总对数减掉就可以了。 参考代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;using namespace std;int read()&#123; int out=0; char c; while (!isdigit(c=getchar())); for (;isdigit(c);c=getchar()) &#123; out=out*10+c-'0'; &#125; return out;&#125;const int N=200010;const int M=1000000007;const int SIX=166666668; //6模1e9+7的逆元struct Node&#123; long long id,w,l,r,t; bool operator&lt;(const Node&amp; b) const &#123; return w&lt;b.w; &#125;&#125; a[N];long long n,suf[N],sta[N],top,ans;int main()&#123; int i; n=read(); for (i=1;i&lt;=n;++i) &#123; a[i].w=read(); a[i].id=i; &#125; for (i=1;i&lt;=n;++i) &#123; while (top&amp;&amp;a[sta[top]].w&gt;a[i].w) &#123; a[sta[top--]].r=i-1; &#125; sta[++top]=i; &#125; while (top) &#123; a[sta[top--]].r=n; &#125; for (i=n;i&gt;=1;--i) &#123; while (top&amp;&amp;a[sta[top]].w&gt;=a[i].w) &#123; a[sta[top--]].l=i+1; &#125; sta[++top]=i; &#125; while (top) &#123; a[sta[top--]].l=1; &#125; for (i=1;i&lt;=n;++i) &#123; a[i].t=(i-a[i].l+1)*(a[i].r-i+1)%M; &#125; sort(a+1,a+n+1); for (i=n;i&gt;=1;--i) &#123; suf[i]=(suf[i+1]+a[i].t)%M; &#125; for (i=1;i&lt;=n;++i) &#123; ans=(ans+(a[i].w*suf[i+1]%M)*a[i].t)%M; ans=(ans-(a[i].id-a[i].l)*(a[i].id-a[i].l+1)%M*(2*a[i].id-2*a[i].l+1)%M*SIX%M*(a[i].r-a[i].id+1)%M*a[i].w%M+M)%M; //重复区间在左 ans=(ans-(a[i].r-a[i].id)*(a[i].r-a[i].id+1)%M*(2*a[i].r-2*a[i].id+1)%M*SIX%M*(a[i].id-a[i].l+1)%M*a[i].w%M+M)%M; //重复区间在右 &#125; cout&lt;&lt;ans; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>杂题</tag>
        <tag>noi.ac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树上背包的上下界优化]]></title>
    <url>%2F%E6%A0%91%E4%B8%8A%E8%83%8C%E5%8C%85%E7%9A%84%E4%B8%8A%E4%B8%8B%E7%95%8C%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[最近做了几道树上背包的题目，很多题目的数据范围都很小，但实际上树上背包有多种方式可以优化到 $O(nm)$ （$n$ 为节点数，$m$ 为体积的值域），比如先序遍历优化（何森《先序遍历用于优化树形背包问题》），求泛化物品的并（徐持衡《浅谈几类背包题》）……经过一番学习，觉得还是上下界优化理解起来最简单，也比较好写，适用范围广，唯一比其它做法复杂的地方就是复杂度分析。 例题讲解这里以一道经典的树上背包作为例题：【数据加强版】选课 直接把我出的数据加强版放上来了..反正题面里有原题链接QAQ 注：本文中用 $a_i$ 代指题面中的 $s_i$ 。 $O(nm^2)$ 做法用 $f_{u,i}$ 表示以 $u$ 为根的子树中选 $i$ 门课的最大得分，那么 $f_{u,i}=\min\limits_{\forall fa[v_j]=u,\sum k_j=i-1}(\sum f[v_j][k_j])+a_u$，而这个转移可以通过背包实现，依次合并每棵子树，每次合并时枚举 $i$ 和 $k_j$ ，$f_{u,i}=\max(f_{u,i},f_{u,i-k_j}+f_{v_j,k_j})$ 。 需要倒序枚举 $i$ 防止状态在转移前被覆盖。否则的话dp数组要多一维。 由于可能是森林，所有没有直接先修课的节点，父亲视为节点 $0$，实际上就要选 $m+1$ 个节点。 参考代码： 1234567891011121314151617void dfs(int u)&#123; f[u][1]=a[u]; int i,j,k,v; for (i=head[u];i;i=nxt[i]) &#123; v=to[i]; dfs(v); for (j=m+1;j&gt;=1;--j) &#123; for (k=1;k&lt;j;++k) &#123; f[u][j]=max(f[u][j],f[u][j-k]+f[v][k]); &#125; &#125; &#125;&#125; 上下界优化注意背包转移的这部分： 1234567for (j=m+1;j&gt;=1;--j)&#123; for (k=1;k&lt;j;++k) &#123; f[u][j]=max(f[u][j],f[u][k]+f[v][j-k]); &#125;&#125; 实际上，这里面有很多状态都是没有意义的： 转移时已经合并了大小之和为 $s$ 的一些子树，那么 $f_{u,i}(i&gt;s)$ 实际上是没有意义的。 $f_{v,i}(i&gt;siz[v])$ 也是没有意义的。 $f_{u,i}(i&gt;m)$ 是没有作用的。 所以，可以对 $j$ 和 $k$ 的枚举范围进行优化： 12345678910111213141516171819void dfs(int u)&#123; siz[u]=1; f[u][1]=a[u]; int i,j,k,v; for (i=head[u];i;i=nxt[i]) &#123; v=to[i]; dfs(v); for (j=min(m+1,siz[u]+siz[v]);j&gt;=1;--j) &#123; for (k=max(1,j-siz[u]);k&lt;=siz[v]&amp;&amp;k&lt;j;++k) &#123; f[u][j]=max(f[u][j],f[u][j-k]+f[v][k]); &#125; &#125; siz[u]+=siz[v]; &#125;&#125; 复杂度分析可以参考这篇博客。 形象的解释每个点对都只会在 $lca$ 处合并一次，所以总的复杂度是 $O(n^2)$ 的。 这个解释很简洁，需要自己意会一下.. 严格？证明令 $T_u$ 为处理子树 $u$ 的总用时，那么： $\begin{aligned}T_u&amp;=\left(\sum\limits_{\forall fa[v_i]=u}T_{v_i}\right)+t_u\\\\t_u&amp;=1+(1+siz[v_1])\times siz[v_1]+(1+siz[v_1]+siz[v_2])\times siz[v_2]+\cdots+siz[u]\times siz[v_k]\\&amp;=1+\sum\limits_{\forall fa[v_i]=u}siz[v_i]\times(siz[u]+1)\\&amp;=siz[u]^2\end{aligned}$ 对于叶子节点 $u$ ，$T(u)=1$ ，是 $O(siz[u]^2)$ 的。 对于儿子都是叶子节点的节点 $u$，由于平方和小于和平方，$\sum\limits_{\forall fa[v_i]=u}T_{v_i}$ 也是 $O(siz[u]^2)$ 的。 可以这样递归地说明，对于任意节点 $u$ ，$\sum\limits_{\forall fa[v_i]=u}T_{v_i}$ 都是 $O(siz[u]^2)$ 的。 又因为 $t(u)$ 是 $O(siz[u]^2)$ 的，$T(u)$ 就是 $O(siz[u]^2)$ 的。 所以解决整个问题就是 $O(n^2)$ 的。 严格！证明枚举过程中还要对 $m$ 取 min ，所以应该是这样的： $\begin{aligned}t_u&amp;=1+\min(m,1+siz[v_1])\times \min(m,siz[v_1])+\min(m,1+siz[v_1]+siz[v_2])\times \min(m,siz[v_2])+\cdots+\min(m,siz[u])\times \min(m,siz[v_k])\\&amp;\le m\times siz[u]\end{aligned}$ 所以，$t(u)$ 是 $O(\min(siz[u],m)\times siz[u])$ 的。 对于 $siz[u]\le m$，$T(u)$ 是 $O(siz[u]^2)$ 的。 对于 $siz[u]&gt;m$，$\sum\limits_{\forall fa[v_i]=u,siz[v_i]\le m}T_{v_i}$ 是 $O\left(\left(\sum\limits_{\forall fa[v_i]=u,siz[v_i]\le m}siz[v_i]\right)^2\right)$ 的；$\sum\limits_{\forall fa[v_i]=u,siz[v_i]&gt;m}T_{v_i}$ 是 $O\left(m\times\sum\limits_{\forall fa[v_i]=u,siz[v_i]&gt;m}siz[v_i]\right)$ 的；所以，$T(u)$ 是 $O(m\times siz[u])$ 的。 所以，解决整个问题是 $O(nm)$ 的。 其它例题【数据加强版】道路重建 dl代码我出的那两道数据加强版略有些毒瘤..（$n\times m\le 10^8$） 大约需要这样写： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;void dfs(int u);void add(int u,int v);const int N=100010;int head[N],nxt[N],to[N],cnt;int n,m,a[N],f[100000010],siz[N];int main()&#123; int i,k; scanf("%d%d",&amp;n,&amp;m); for (i=1;i&lt;=n;++i) &#123; scanf("%d%d",&amp;k,a+i); add(k,i); &#125; dfs(0); printf("%d",f[m+1]); return 0;&#125;void add(int u,int v)&#123; nxt[++cnt]=head[u]; head[u]=cnt; to[cnt]=v;&#125;void dfs(int u)&#123; siz[u]=1; f[u*(m+2)+1]=a[u]; int i,j,k,v; for (i=head[u];i;i=nxt[i]) &#123; v=to[i]; dfs(v); for (j=min(m+1,siz[u]+siz[v]);j&gt;=1;--j) &#123; for (k=max(1,j-siz[u]);k&lt;=siz[v]&amp;&amp;k&lt;j;++k) &#123; f[u*(m+2)+j]=max(f[u*(m+2)+j],f[u*(m+2)+j-k]+f[v*(m+2)+k]); &#125; &#125; siz[u]+=siz[v]; &#125;&#125; 关于另一种 $O(nm)$ 做法一开始我在洛谷发了篇选课的题解，然后没过… 那篇题解用的是求泛化物品的并（徐持衡《浅谈几类背包题》） 虽然说洛谷好像还没有上下界优化的题解..但最近好几篇题解没过审，都不太想在洛谷发题解了…]]></content>
      <tags>
        <tag>算法</tag>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈邻项交换排序的应用以及需要注意的问题]]></title>
    <url>%2F%E6%B5%85%E8%B0%88%E9%82%BB%E9%A1%B9%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F%E7%9A%84%E5%BA%94%E7%94%A8%E4%BB%A5%E5%8F%8A%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[邻项交换排序是一种常见的贪心算法，通过比较两个相邻元素交换前后的优劣对整个序列进行排序，从而使得这个序列成为题目所求的最优解。然而，邻项交换排序的应用有一些需要注意的地方，稍有不慎便会成为一个错误的算法。 算法简介例题引入题目来源NOIP2012提高组D1T2 国王游戏 题目描述恰逢 $H$ 国国庆，国王邀请 $n$ 位大臣来玩一个有奖游戏。首先，他让每个大臣在左、右手上面分别写下一个整数，国王自己也在左、右手上各写一个整数。然后，让这 $n $位大臣排成一排，国王站在队伍的最前面。排好队后，所有的大臣都会获得国王奖赏的若干金币，每位大臣获得的金币数分别是：排在该大臣前面的所有人的左手上的数的乘积除以他自己右手上的数，然后向下取整得到的结果。 国王不希望某一个大臣获得特别多的奖赏，所以他想请你帮他重新安排一下队伍的顺序，使得获得奖赏最多的大臣，所获奖赏尽可能的少。注意，国王的位置始终在队伍的最前面。 输入格式第一行包含一个整数 $n$ ，表示大臣的人数。 第二行包含两个整数 $a$ 和 $b$ ，之间用一个空格隔开，分别表示国王左手和右手上的整数。 接下来 $n$ 行，每行包含两个整数 $a$ 和 $b$ ，之间用一个空格隔开，分别表示每个大臣左手和右手上的整数。 输出格式一个整数，表示重新排列后的队伍中获奖赏最多的大臣所获得的金币数。 数据范围对于 $20\%$ 的数据，有 $1\le n\le 10,0&lt;a,b&lt;8$； 对于 $40\%$ 的数据，有 $1\le n\le 20,0&lt;a,b&lt;8$； 对于 $60\%$ 的数据，有 $1\le n\le 100$； 对于 $60\%$ 的数据，保证答案不超过 $10^9$； 对于 $100\%$ 的数据，有 $1\le n\le 1000,0&lt;a,b&lt;10000$ 。 使用邻项交换排序解决问题选取相邻的两个大臣 $i$ 和 $j$ （$j$ 此时在 $i$ 后一个），分别用 $a_i,b_i,a_j,b_j$ 表示这两位大臣左手上和右手上的数字，设这两位大臣前面的所有大臣左手上的数乘积为 $k$ 。 此时，若调整这两名大臣的顺序，对前面和后面的大臣都不会造成影响，因此我们只要使得这两位大臣中获得较多奖赏的那位获得的奖赏尽量少即可。 当 $i$ 在前 $j$ 在后时，这个值为 $\max(\frac k{b_i},\frac {k a_i}{b_j})$ 。 当 $j$ 在前 $i$ 在后时，这个值为 $\max(\frac k{b_j},\frac {k a_j}{b_i})$ 。 因此，若 $\max(\frac k{b_i},\frac {k a_i}{b_j})&gt;\max(\frac k{b_j},\frac {k a_j}{b_i})$ ，就需要交换 $i$ 和 $j$ 。 实际上，由于 $\frac {k a_i}{b_j}\ge\frac k{b_j},\frac {k a_j}{b_i}\ge\frac k{b_i}$ ，只需比较 $\frac {k a_i}{b_j}$ 和 $\frac {k a_j}{b_i}$ ，也就只需比较 $\frac {a_i}{b_j}$ 和 $\frac {a_j}{b_i}$ ，即：若 $a_i b_i&gt;a_j b_j$，就要交换 $i$ 和 $j$ 。 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N=1010;struct Node&#123; int a,b; bool operator&lt;(Node&amp; y) &#123; return a*b&lt;y.a*y.b; &#125;&#125; dc[N];long long n,ans,k;int main()&#123; cin&gt;&gt;n; for (int i=0;i&lt;=n;++i) &#123; cin&gt;&gt;dc[i].a&gt;&gt;dc[i].b; &#125; sort(dc+1,dc+n+1); k=dc[0].a; for (int i=1;i&lt;=n;++i) &#123; ans=max(ans,k/dc[i].b); k*=dc[i].a; &#125; cout&lt;&lt;ans; return 0;&#125; 使用以上代码即可得到60分，而AC此题需要使用高精度乘除法，不在本文讨论范围内。 使用邻项交换排序需要注意的问题另一道例题题目来源洛谷P2123 皇后游戏 题目描述皇后有 $n$ 位大臣，每位大臣的左右手上面分别写上了一个正整数。恰逢国庆节来临，皇后决定为 $n$ 位大臣颁发奖金，其中第 $i$ 位大臣所获得的奖金数目为第 $i－1$ 位大臣所获得奖金数目与前 $i$ 位大臣左手上的数的和的较大值再加上第 $i$ 位大臣右手上的数。 形式化地讲：我们设第 $i$ 位大臣左手上的正整数为 $a_i$ ，右手上的正整数为 $b_i$ ， 则第 $i$ 位大臣获得的奖金数目为 $c_i$ 可以表达为： $$c_i=\begin{cases}a_1+b_1 &amp; i=1\\\max(c_{i-1},\sum\limits_{j=1}^ia_j)+b_i &amp; 2\le i\le n\end{cases}$$ 当然，吝啬的皇后并不希望太多的奖金被发给大臣，所以她想请你来重新安排一下队伍的顺序，使得获得奖金最多的大臣，所获奖金数目尽可能的少。 注意：重新安排队伍并不意味着一定要打乱顺序，我们允许不改变任何一位大臣的位置。 输入格式第一行包含一个正整数 $T$ ，表示测试数据的组数。 接下来 $T$ 个部分，每个部分的第一行包含一个正整数 $n$ ，表示大臣的数目。 每个部分接下来 $n$ 行中，每行两个正整数，分别为 $a_i$ 和 $b_i$ ，含义如上文所述。 输出格式共 $T$ 行，每行包含一个整数，表示获得奖金最多的大臣所获得的奖金数目。 数据范围对于全部测试数据满足：$T\le10,1\le n\le20000,1\le a_i,b_i\le10^9$ 。 尝试用邻项交换排序解决问题还是选取相邻的两个大臣 $i$ 和 $j$ （$j$ 此时在 $i$ 后一个），交换 $i$ 和 $j$ 对前面的大臣无影响，对后面的大臣的影响在于排在后面的那个大臣获得的奖金，需要使之尽量小。 设这两个大臣前面的所有大臣左手上的数之和为 $\rm sum$ ，这两个大臣的再往前一个大臣得到的奖金是 $\rm pre$ 。 当 $i$ 在前 $j$ 在后时，这个值为 $\max(\max(\mathrm{pre},\mathrm{sum}+a_i)+b_i,\mathrm{sum}+a_i+a_j)+b_j$ 。 当 $j$ 在前 $i$ 在后时，这个值为 $\max(\max(\mathrm{pre},\mathrm{sum}+a_j)+b_j,\mathrm{sum}+a_j+a_i)+b_i$ 。 由于 $\max(x,y)+z=\max(x+z,y+z)$ ，需要比较的就是 $\max(\mathrm{pre}+b_i+b_j,\mathrm{sum}+a_i+b_i+b_j,\mathrm{sum}+a_i+a_j+b_j)$ 和 $\max(\mathrm{pre}+b_j+b_i,\mathrm{sum}+a_j+b_j+b_i,\mathrm{sum}+a_j+a_i+b_i)$ ，其中 $\mathrm{pre}+b_i+b_j=\mathrm{pre}+b_j+b_i$ ，需要比较的就是 $\max(\mathrm{sum}+a_i+b_i+b_j,\mathrm{sum}+a_i+a_j+b_j)$ 和 $\max(\mathrm{sum}+a_j+b_j+b_i,\mathrm{sum}+a_j+a_i+b_i)$ ，再用 $\mathrm{sum}+a_i+b_i+a_j+b_j$ 减去两边并变号，即：当 $\min(a_i,b_j)&gt;\min(a_j,b_i)$ 时，需要交换 $i$ 和 $j$。 于是，可以写出以下代码，并在洛谷上AC此题： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N=20010;struct Node&#123; int a,b; bool operator&lt;(Node&amp; y) &#123; return min(a,y.b)&lt;min(b,y.a); &#125;&#125; dc[N];long long ans,sum,t,n;int main()&#123; cin&gt;&gt;t; while (t--) &#123; cin&gt;&gt;n; for (int i=1;i&lt;=n;++i) &#123; cin&gt;&gt;dc[i].a&gt;&gt;dc[i].b; &#125; sort(dc+1,dc+n+1); ans=sum=0; for (int i=1;i&lt;=n;++i) &#123; sum+=dc[i].a; ans=max(ans,sum)+dc[i].b; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; hack数据事实上，上面的做法是错误的，无法通过下面这组数据： 1234567891011241 11 13 52 741 13 51 12 7 这两组数据只有大臣给出的顺序不同，但上面的代码输出为： 121617 输出中间结果，可以发现，排列后的最终结果分别为： 12341 11 12 73 5 和 12341 13 51 12 7 这两种排列方式都满足 $\forall i\in [1,n),\min(a_i,b_{i+1})\le\min(a_{i+1},b_i)$，但第二种方式并不是最优解。具体原因将在下文分析。 严格弱序严格弱序简介要知道为什么这种做法是错误的，首先需要了解严格弱序（strict weak ordering）。 对于一个比较运算符（用“$&lt;$”表示此运算符，用“$\not&lt;$”表示不满足此运算符），若满足以下四个条件，则称其是满足严格弱序的： $x\not&lt;x$ （非自反性） 若 $x&lt;y$，则 $y\not&lt;x$ （非对称性） 若 $x&lt;y,y&lt;z$，则 $x&lt;z$ （传递性） 若 $x\not&lt;y,y\not&lt;x,y\not&lt;z,z\not&lt;y$，则 $x\not&lt;z,z\not&lt;x$ （不可比性的传递性） 而 C++ 标准库要求用于排序的运算符必须满足严格弱序： It has to be antisymmetric. This means that for operator $&lt;$: If $x &lt; y$ is true, then $y &lt; x$ is false. This means that for a predicate op(): If op(x,y) is true, then op(y,x) is false. It has to be transitive. This means that for operator $&lt;$: If $x &lt; y$ is true and $y &lt; z$ is true, then $x &lt; z$ is true. This means that for a predicate op(): If op(x,y) is true and op(y,z) is true, then op(x,z) is true. It has to be irreflexive. This means that for operator $&lt;$: $x &lt; x$ is always false. This means that for a predicate op(): op(x,x) is always false. It has to have transitivity of equivalence, which means roughly: If a is equivalent to b and b is equivalent to c, then a is equivalent to c. This means that for operator $&lt;$: If $!(a&lt;b) \&amp;\&amp; !(b&lt;a)$ is true and $!(b&lt;c) \&amp;\&amp; !(c&lt;b)$ is true then $!(a&lt;c) \&amp;\&amp; !(c&lt;a)$ is true. This means that for a predicate op(): If op(a,b), op(b,a), op(b,c), and op(c,b) all yield false, then op(a,c) and op(c,a) yield false. 上述做法的判断条件满足传递性，但不满足不可比性的传递性。 满足传递性的证明命题：$\forall \begin{cases}\min(a_i,b_j)&lt;\min(a_j,b_i)\\\min(a_j,b_k)&lt;\min(a_k,b_j)\end{cases}$，有 $\min(a_i,b_k)&lt;\min(a_k,b_i)$。 将上式拆解成逻辑式，即证： $\forall \begin{cases}\,(a_i&lt;a_j\lor b_j&lt;a_j)\land(a_i&lt;b_i\lor b_j&lt;b_i) \\\,(a_j&lt;a_k\lor b_k&lt;a_k)\land(a_j&lt;b_j\lor b_k&lt;b_j)\end{cases}$，有 $(a_i&lt;a_k\lor b_k&lt;a_k)\land(a_i&lt;b_i\lor b_k&lt;b_i)$。 假设原命题不成立，即 $\exists\begin{cases}\,(a_i&lt;a_j\lor b_j&lt;a_j)\land(a_i&lt;b_i\lor b_j&lt;b_i)&amp;(1) \\\,(a_j&lt;a_k\lor b_k&lt;a_k)\land(a_j&lt;b_j\lor b_k&lt;b_j)&amp;(2) \\\,(a_i\ge a_k\land b_k\ge a_k)\lor(a_i\ge b_i\land b_k\ge b_i)&amp;(3)\end{cases}$ 分别讨论 $(3)$ 式成立的两种情况： 若 $a_i\ge a_k\land b_k\ge a_k$，由 $(2)$ 式得 $a_j&lt;a_k$，进而推出 $a_j&lt;a_i$，再由 $(1)$ 式得 $b_j&lt;a_j$，再由 $(2)$ 式得到 $b_k&lt;b_j$，所以 $b_k&lt;b_j&lt;a_j&lt;a_k$，与 $b_k\ge a_k$ 矛盾，不成立。 若 $a_i\ge b_i\land b_k\ge b_i$，与上面类似，由 $(1)$ 式得 $b_j&lt;b_i$，进而推出 $b_j&lt;b_k$，再由 $(2)$ 式得到 $a_j&lt;b_j$，再由 $(1)$ 式得到 $a_i&lt;a_j$，所以 $a_i&lt;a_j&lt;b_j&lt;b_i$，与 $a_i\ge b_i$ 矛盾，不成立。 综上所述，假设不成立。 所以，$P_{i,j}=\min(a_i,b_j)&lt;\min(a_j,b_i)$ 具有传递性。 不具有不可比性的传递性的证明命题：$\forall \begin{cases}\min(a_i,b_j)=\min(a_j,b_i)\\\min(a_j,b_k)=\min(a_k,b_j)\end{cases}$，有 $\min(a_i,b_k)=\min(a_k,b_i)$。 很明显，当 $a_j=b_j$ 且都很小时存在反例，如： $$\begin{array}{c|c|c}&amp;a&amp;b\\i&amp;3&amp;5\\j&amp;1&amp;1\\k&amp;2&amp;7\end{array}$$ $\begin{cases}\min(3,1)=\min(1,5)\\\min(1,7)=\min(2,1)\end{cases}$，但 $\min(3,7)\ne \min(2,5)$。 这样的反例还有很多，所以，$P_{i,j}=\min(a_i,b_j)&lt;\min(a_j,b_i)$ 不具有不可比性的传递性。 为何会错简单地说，$P_{i,j}=\min(a_i,b_j)&lt;\min(a_j,b_i)$ 不满足严格弱序，不能作为 std::sort 的比较函数。 究其原因，“不具有不可比性的传递性”意味着：将序列中若干个不可比的相邻元素对（在这种比较方式下即 $\min(a_i,b_{i+1})=\min(a_{i+1},b_i)$ 的 $i$ 和 $i+1$）互换后，可能会出现前面的元素“大于”后面的元素（在这种比较方式下即出现 $\min(a_i,b_{i+1})&gt;\min(a_{i+1},b_i)$），从而使得原先的排列方式不是最优的。 正确解法更加完善的贪心解法比较相邻两项时，若 $\min(a_i,b_j)=\min(a_j,b_i)$ ，从全局来看，由于 $a$ 的前缀和对答案有一定的影响，把 $a$ 更小的放前面是更优的。从而可以得到这样一个解法： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N=20010;struct Node&#123; int a,b; bool operator&lt;(Node&amp; y) &#123; return min(a,y.b)==min(b,y.a)?a&lt;y.a:min(a,y.b)&lt;min(b,y.a); &#125;&#125; dc[N];long long ans,sum,t,n;int main()&#123; cin&gt;&gt;t; while (t--) &#123; cin&gt;&gt;n; for (int i=1;i&lt;=n;++i) &#123; cin&gt;&gt;dc[i].a&gt;&gt;dc[i].b; &#125; sort(dc+1,dc+n+1); ans=sum=0; for (int i=1;i&lt;=n;++i) &#123; sum+=dc[i].a; ans=max(ans,sum)+dc[i].b; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; 这个解法的正确性将在下文证明。 一个解法是否正确的判断方式由上文的讨论可以得知，一个排序方式 $P_{i,j}$ 要是正解，需要满足两个条件： 满足严格弱序。 $\forall P_{i,j}=true$，$\min(a_i,b_j)&lt;\min(a_j,b_i)$ 。 即，可以作为比较函数，且排序完成后任意交换相邻元素均不会使答案更优。 从而可以写出下面的正解判断器：（为了减少一行显示不下的情况已删去所有缩进） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;bool cmp(int i,int j);int a[10],b[10];int main()&#123;for (a[0]=1;a[0]&lt;=6;++a[0])&#123;for (b[0]=1;b[0]&lt;=6;++b[0])&#123;if (cmp(0,0))&#123;printf("No irreflexivity:%d %d\n",a[0],b[0]);&#125;for (a[1]=1;a[1]&lt;=6;++a[1])&#123;for (b[1]=1;b[1]&lt;=6;++b[1])&#123;if (cmp(0,1)&amp;&amp;min(a[0],b[1])&gt;min(a[1],b[0]))&#123;printf("Not the best:%d %d %d %d\n",a[0],b[0],a[1],b[1]);&#125;for (a[2]=1;a[2]&lt;=6;++a[2])&#123;for (b[2]=1;b[2]&lt;=6;++b[2])&#123;if (cmp(0,1)&amp;&amp;cmp(1,2)&amp;&amp;!cmp(0,2))&#123;printf("No transitivity:%d %d %d %d %d %d\n",a[0],b[0],a[1],b[1],a[2],b[2]);&#125;if (!cmp(0,1)&amp;&amp;!cmp(1,0)&amp;&amp;!cmp(1,2)&amp;&amp;!cmp(2,1)&amp;&amp;(cmp(0,2)||cmp(2,0)))&#123;printf("No transitivity of incomparability:%d %d %d %d %d %d\n",a[0],b[0],a[1],b[1],a[2],b[2]);&#125;&#125;&#125;&#125;&#125;&#125;&#125;return 0;&#125;bool cmp(int i,int j)&#123;return min(a[i],b[j])==min(a[j],b[i])?a[i]&lt;a[j]:min(a[i],b[j])&lt;min(a[j],b[i]);&#125; 运行程序，没有任何输出，说明上文所述的排序方式是一个正解。 用其它排序方式替换 cmp，若没有任何输出即可作为本题的正确排序方式。 下面是几种排序方式的例子： 1234bool cmp(int i,int j)&#123; return min(a[i],b[j])==min(a[j],b[i])?b[i]&gt;b[j]:min(a[i],b[j])&lt;min(a[j],b[i]);&#125; 输出为空，是正解。 1234bool cmp(int i,int j)&#123; return min(a[i],b[j])&lt;min(a[j],b[i]);&#125; 共输出1694行，前10行如下： 12345678910No transitivity of incomparability:1 2 1 1 2 1No transitivity of incomparability:1 2 1 1 2 2No transitivity of incomparability:1 2 1 1 2 3No transitivity of incomparability:1 2 1 1 2 4No transitivity of incomparability:1 2 1 1 2 5No transitivity of incomparability:1 2 1 1 2 6No transitivity of incomparability:1 2 1 1 3 1No transitivity of incomparability:1 2 1 1 3 2No transitivity of incomparability:1 2 1 1 3 3No transitivity of incomparability:1 2 1 1 3 4 1234bool cmp(int i,int j)&#123; return min(a[i],b[j])==min(a[j],b[i])?a[i]&gt;a[j]:min(a[i],b[j])&lt;min(a[j],b[i]);&#125; 共输出280行，前10行如下： 12345678910No transitivity:1 2 2 1 1 1No transitivity:1 2 2 2 1 1No transitivity:1 2 2 3 1 1No transitivity:1 2 2 4 1 1No transitivity:1 2 2 5 1 1No transitivity:1 2 2 6 1 1No transitivity:1 2 3 1 1 1No transitivity:1 2 3 2 1 1No transitivity:1 2 3 3 1 1No transitivity:1 2 3 4 1 1 1234bool cmp(int i,int j)&#123; return min(a[i],b[j])&lt;=min(a[j],b[i]);&#125; 共输出883行，前10行如下： 12345678910No irreflexivity:1 1No irreflexivity:1 2No irreflexivity:1 3No irreflexivity:1 4No irreflexivity:1 5No irreflexivity:1 6No irreflexivity:2 1No transitivity:2 1 1 1 1 2No transitivity:2 1 1 1 1 3No transitivity:2 1 1 1 1 4 总结在可以通过比较相邻两项得出交换或不交换一定不会更差时，可以通过邻项交换排序的方式来得到最优解。 邻项交换排序的比较函数需要满足严格弱序，并且排序完成后任意交换相邻元素都不会更优。 使用这种算法时，一定要注意以上两点，才能得到真正正确的算法。]]></content>
      <tags>
        <tag>算法</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIp2018提高组游记]]></title>
    <url>%2FNOIp2018%E6%8F%90%E9%AB%98%E7%BB%84%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Day1T1 积木大赛NOIp2013D2T1…..看到的时候我还以为我记错了，以为原题是一次可以随便加，这题只能加一，出考场后查了下发现一模一样。 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int N=100010;int n,d[N],ans;int main()&#123; int i; scanf("%d",&amp;n); for (i=1;i&lt;=n;++i) &#123; scanf("%d",d+i); if (d[i]&gt;d[i-1]) &#123; ans+=d[i]-d[i-1]; &#125; &#125; cout&lt;&lt;ans; return 0;&#125; T2 货币系统去掉可以由其它货币拼成的货币，这个结论倒是很快猜到了。但由于xkdyh留下的阴影，一开始我还写了个exgcd…幸好大样例比较良心，有一组数据是三种货币拼成另一种。然后再仔细一看，发现是个完全背包… 简单证明一下： 结论：对于一个没有任何一种货币可以由系统内其它货币拼成的货币系统 $(n,A)$，与其等价的货币系统 $(m,B)$ 只能是 $(n,A)$ 自身或者加上一些能由 $(n,A)$ 表示的数。 若 $A\not\subseteq B$，任取 $t\in (A-B)$，那么在 $B$ 中必然有一些元素能够拼成 $t$，而这些元素在 $A$ 中必然有不能表示的（否则与 $A$ 中没有任何一种货币可以由系统内其它货币拼成矛盾），而存在 $(m,B)$ 能表示而 $(n,A)$ 不能表示的数与 $(n,A),(m,B)$ 等价矛盾，不成立。 若 $B$ 中有 $(n,A)$ 所不能表示的元素，依然与 $(n,A),(m,B)$ 等价矛盾，不成立。 所以命题得证。 排个序然后完全背包去掉能被系统内其它货币表示的货币即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int t,n,a[110],maxx;bool f[25010];int main()&#123; int i,j,ans; scanf("%d",&amp;t); while (t--) &#123; scanf("%d",&amp;n); ans=n; maxx=0; for (i=1;i&lt;=n;++i) &#123; scanf("%d",a+i); maxx=max(maxx,a[i]); &#125; sort(a+1,a+n+1); memset(f,false,sizeof(f)); f[0]=true; for (i=1;i&lt;=n;++i) &#123; if (f[a[i]]) &#123; --ans; continue; &#125; for (j=0;j+a[i]&lt;=maxx;++j) &#123; if (f[j]) &#123; f[j+a[i]]=true; &#125; &#125; &#125; printf("%d\n",ans); &#125; return 0;&#125; T3 赛道修建看到这题就想起了ylh当时跟我一个房间的时候切掉的 CF div.2 E，但赛后发现不一样… 出考场得知dew、ylh都切掉了这题，然而我只写了直径、链和菊花图的 $55$ 分…凉凉凉 Day2T1 旅行一开始看错题了，以为是最小字典序生成树，还在想为什么 $m$ 这么小..然后仔细一看题，发现一条边只能回溯时重复经过，也就是最后得到的序列只能是个dfs序…数据范围很小，所以就枚举断边写了个 $O(n^2)$ 的，预处理边排序。然后出考场听一堆dalao在那说各种 $O(nlogn)$，$O(n)$ 做法…都不会QAQ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;const int N=5010;void dfs(int u);int n,m,cut,a[N][N],tot,e[N][2];bool vis[N],used[N]; //used用于对m个字典序取min，若used[i]=true说明断开第 i 条边时一定不是答案vector&lt;int&gt; g[N];int main()&#123; int i,j,u,v,minn; scanf("%d%d",&amp;n,&amp;m); for (i=0;i&lt;m;++i) &#123; scanf("%d%d",&amp;u,&amp;v); e[i][0]=u; e[i][1]=v; g[u].push_back(v); g[v].push_back(u); &#125; for (i=1;i&lt;=n;++i) &#123; sort(g[i].begin(),g[i].end()); &#125; if (n==m) &#123; for (cut=0;cut&lt;m;++cut) &#123; memset(vis,false,sizeof(vis)); tot=0; dfs(1); if (tot&lt;n) &#123; used[cut]=true; &#125; &#125; for (i=1;i&lt;=n;++i) &#123; minn=n; for (j=0;j&lt;m;++j) &#123; if (!used[j]&amp;&amp;a[j][i]&lt;minn) &#123; minn=a[j][i]; &#125; &#125; for (j=0;j&lt;m;++j) &#123; if (a[j][i]&gt;minn) &#123; used[j]=true; &#125; &#125; printf("%d",minn); if (i&lt;n) &#123; putchar(' '); &#125; &#125; &#125; else &#123; cut=m; dfs(1); for (i=1;i&lt;=n;++i) &#123; printf("%d",a[m][i]); if (i&lt;n) &#123; putchar(' '); &#125; &#125; &#125; return 0;&#125;void dfs(int u)&#123; if (vis[u]) &#123; return; &#125; vis[u]=true; a[cut][++tot]=u; int v,i; for (i=0;i&lt;g[u].size();++i) &#123; v=g[u][i]; if ((u!=e[cut][0]||v!=e[cut][1])&amp;&amp;(u!=e[cut][1]||v!=e[cut][0])) &#123; dfs(v); &#125; &#125;&#125; T2 填数游戏要是数据范围给到 $10^9$ 我就不会在考场上推半天了…一开始想了好久怎么 $O(nm)$ dp，虽然没想出来怎么做，但发现了暴力怎么写：一种方案合法等价于：对于每个点，它右边的点先往下再往右的路径小于它下面的点先往右再往下的路径。因为这两条路径分别是一个点向右走后最大的路径和向下走后最小的路径。然后打了个表，发现 $(n,m)=(n,n+1)\times 3^{m-n-1} (n\ge 2,m\ge n+1)$。于是开始跑 $(8,9)$ ，跑到11:50 还没跑出来…幸好发现了 $(n,n)$ 和 $(n,n+1)$ 之间也有一定的规律，把 $(8,9)$ 算出来了… 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const long long Ans[9][10]=&#123;&#123;0,0,0,0,0,0,0,0,0,0&#125;, &#123;0,0,0,0,0,0,0,0,0,0&#125;, &#123;0,4,12,36,0,0,0,0,0,0&#125;, &#123;0,8,36,112,336,0,0,0,0,0&#125;, &#123;0,16,108,336,912,2688,0,0,0,0&#125;, &#123;0,32,324,1008,2688,7136,21312,0,0,0&#125;, &#123;0,64,972,3024,8064,21312,56768,170112,0,0&#125;, &#123;0,128,2916,9072,24192,63936,170112,453504,1360128,0&#125;, &#123;0,256,8748,27216,72576,191808,510336,1360128,3626752,10879488&#125;&#125;; //其实有一部分表是不必要（没有意义）的... const long long M=1000000007;long long n,m,ans=1;int main()&#123; int i; cin&gt;&gt;n&gt;&gt;m; if (n&gt;m) &#123; swap(n,m); &#125; if (n==1) &#123; for (i=30;i&gt;=0;--i) &#123; ans=ans*ans%M; if (m&amp;(1&lt;&lt;i)) &#123; ans=ans*2%M; &#125; &#125; cout&lt;&lt;ans; &#125; else &#123; if (m&lt;=n+1) &#123; cout&lt;&lt;Ans[n][m]; return 0; &#125; else &#123; for (i=30;i&gt;=0;--i) &#123; ans=ans*ans%M; if ((m-n-1)&amp;(1&lt;&lt;i)) &#123; ans=ans*3%M; &#125; &#125; cout&lt;&lt;ans*Ans[n][n+1]%M; &#125; &#125; return 0;&#125; T3 保卫王国据说是ddp…考场上先10min写了44分（一开始还以为是55分Orz），然后看了下，觉得B1挺可写的，更新向上的链貌似就可以了，但最后没调出来.. Day7上（tui）了一个星期的whk..个鬼啊，三天在考期中，就上了两天whk。感觉从零开始的whk没有想象中那么恐怖… 一周不让去机房，一到家就在洛谷上测了一下公布的代码.其它题都和预估的一样，D2T1可能会被卡常，洛谷上开了O2最慢点 $0.9s$ ，而且不用vector好像也过不了，不知道是不是洛谷上内存开小了的原因… D1T3大众AC题我爆菊（花图）了… 幸好菊花图的数据分治放在了最后面，还有 $40$ 分。发现自己傻了，不知道为什么会认为只有最短的两条边可以拼在一起，其它边都只能自成一条道……. 听说D2T3不用ddp，还是我太菜了… 估分：$100+100+40+88/100+100+44=472/484$ Day10GGF咕咕咕，然而我把两个T3写了一下.. D1T3真的好简单…二分答案，check的时候dfs处理每棵子树并返回块数最多时最大剩余，具体就是把子树返回值排个序，双指针配对得到最多块数，然后从最后一个配对的左指针开始往前这么多个依次配对，最后看剩下的没配对的里面最大的是多少。（第二天换成CCF数据发现做法挂了）处理子树的时候二分返回值不影响复杂度但能保证正确性。 D2T3做法挺有趣的..倍增题做少了，估计做多了就比较套路了…预处理出 $f[u][1],f[u][0],g[u][1],g[u][0]$，分别代表选/不选 $u$ 时 子树 $u$ 答案，选/不选 $u$ 时 $u$ 往上（整颗树减去子树 $u$）的答案。倍增处理出祖先 $fa[u][i]$ 表示 $u$ 的 $2^i$ 祖先，用 $bz[u][i][0/1][0/1]$ 表示子树 $fa[u][i]$ 除去子树 $u$ ，其中 $u$ 选/不选，$fa[u][i]$ 选/不选的答案，可以在dfs预处理 f 和 g 的同时算出 $bz[u][0][0/1][0/1]$ ，然后 $bz[u][i][a][b]=\min(bz[u][i-1][a][0]+bz[fa[u][i-1]][i-1][0][b],bz[u][i-1][a][1]+bz[fa[u][i-1]][i-1][1][b])$ 。计算答案的时候如果是祖先关系直接倍增计算链上答案，再加上子树的 f 和 祖先上方的 g；否则倍增到 $lca$ 计算路径上的答案，两棵子树以及 $lca$ 上方的答案就是对应的 $f$ 和 $g$ 。然后写到 $22:15$，交上去 $68$ 分，回寝室…ab相邻的 $16$ 分真的好简单，不用倍增，考场上应该写出来的… Day11刚到学校听说自己 $480$ ，还在想8700k这么强，能把我的 travel 卡成 $96$ … 中午一看是 $489$，数据真有趣…D1T3 隔壁原 $95$ 变成 $80$，我昨天A的变成 $90$ 了，考场写的还骗到了 $5$ 分（$45$）…8700k天下第一！ Day25咕咕咕咕咕，$\mathrm{CN} 329$。]]></content>
      <tags>
        <tag>游记</tag>
        <tag>CCF系列赛事</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二维莫队解题报告]]></title>
    <url>%2F%E4%BA%8C%E7%BB%B4%E8%8E%AB%E9%98%9F%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[我写的莫队教程 其实这是一道bzoj上的题（bzoj2639，貌似是权限题，反正我看不了），在YALI做模拟赛的时候遇到了. 然后在网上查到了几篇关于这道题的博客，都和我的做法略有不同… 题目大意给你一个 $r*c$ 的矩阵，每个点有一个颜色， $m$ 个询问，每次询问一个子矩阵内，每种颜色出现次数的平方和。 $r,c\le 200,m\le 100000$ 做法简述首先我们要明白，莫队究竟在干什么。 莫队其实就是几个指针在那跳来跳去，每跳一步都需要一定的时间，通过对询问排序使得指针跳的总次数尽量小。 所以，这题中询问为 $(x_1,y_1,x_2,y_2)$ ，也就是四个指针在那跳，分别分块再排序就可以了，即： 123456789//为避免和cmath库中的y0y1重名，下文中代码内的x1,y1,x2,y2都用x,y,xx,yy代替struct Query&#123; int x,y,xx,yy,id; bool operator&lt;(Query&amp; b) &#123; return x/B==b.x/B?(y/B==b.y/B?(xx/B==b.xx/B?yy&lt;b.yy:xx&lt;b.xx):y&lt;b.y):x&lt;b.x; //B为分块大小 &#125;&#125; q[M]; 答案更新一般的莫队都是 $O(1)$ 更新答案的，然而这题是 $O(n)$ （用 $n$ 代表 $r,c$ ） 更新。 移动指针的时候，把一排一起修改。 需要注意的是，8个while的顺序如果排列不当在某些情况下会导致答案出错，所以最好是将所有add都放在del前面（实际上有多种排列顺序都可以在不进行“反操作”的情况下保证答案正确，所有add放在del前面只是其中一种），或者是对“反区间”进行“反操作”。 所谓“反区间”，如：修改 $x_1$ 指针时，本应进行add操作，而此时$y_1&gt;y_2+1$，那么就要将 $(y_2,y_1)$ 这个开区间内的所有点进行del。 while的排列顺序得当可以使“反区间”不可能出现。 “反操作”参考代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697while (x&lt;q[i].x)&#123; for (j=y;j&lt;=yy;++j) &#123; del(a[x][j]); &#125; for (j=yy+1;j&lt;y;++j) &#123; add(a[x][j]); &#125; ++x;&#125;while (y&lt;q[i].y)&#123; for (j=x;j&lt;=xx;++j) &#123; del(a[j][y]); &#125; for (j=xx+1;j&lt;x;++j) &#123; add(a[j][y]); &#125; ++y;&#125;while (xx&gt;q[i].xx)&#123; for (j=y;j&lt;=yy;++j) &#123; del(a[xx][j]); &#125; for (j=yy+1;j&lt;y;++j) &#123; add(a[xx][j]); &#125; --xx;&#125;while (yy&gt;q[i].yy)&#123; for (j=x;j&lt;=xx;++j) &#123; del(a[j][yy]); &#125; for (j=xx+1;j&lt;x;++j) &#123; add(a[j][yy]); &#125; --yy;&#125;while (x&gt;q[i].x)&#123; --x; for (j=y;j&lt;=yy;++j) &#123; add(a[x][j]); &#125; for (j=yy+1;j&lt;y;++j) &#123; del(a[x][j]); &#125;&#125;while (y&gt;q[i].y)&#123; --y; for (j=x;j&lt;=xx;++j) &#123; add(a[j][y]); &#125; for (j=xx+1;j&lt;x;++j) &#123; del(a[j][y]); &#125;&#125;while (xx&lt;q[i].xx)&#123; ++xx; for (j=y;j&lt;=yy;++j) &#123; add(a[xx][j]); &#125; for (j=yy+1;j&lt;y;++j) &#123; del(a[xx][j]); &#125;&#125;while (yy&lt;q[i].yy)&#123; ++yy; for (j=x;j&lt;=xx;++j) &#123; add(a[j][yy]); &#125; for (j=xx+1;j&lt;x;++j) &#123; del(a[j][yy]); &#125;&#125;out[q[i].id]=ans; 分块大小具体计算清楚非常复杂，这里只是估算一下. $x_1$ 指针的移动次数为 $O(mB)$，$y_2$ 指针的移动次数渐进复杂度中含有 $O\left(\frac{n^4}{B^3}\right)$，取 $mB=\frac{n^4}{B^3}$，得到 $B=nm^{-\frac{1}{4}}$ 总时间复杂度为 $O(mlogm+n^2m^{\frac{3}{4}})$ 反正这样的分块大小实测比 $\sqrt{n}$ 优秀…有兴趣的话可以严谨地算一算（如果发现我这个估算有问题可以直接在这篇博客下评论） 初始子矩阵任意一个空矩阵就可以了，如 $x_1=y_1=1,x_2=y_2=0$ 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N=210;const int M=100010;void add(int x);void del(int x);int r,c,m,B,a[N][N],lsh[N*N],tot,cnt[N*N],ans,out[M];struct Query&#123; int x,y,xx,yy,id; bool operator&lt;(Query&amp; b) &#123; return x/B==b.x/B?(y/B==b.y/B?(xx/B==b.xx/B?yy&lt;b.yy:xx&lt;b.xx):y&lt;b.y):x&lt;b.x; &#125;&#125; q[M];int main()&#123; int i,j,x=1,y=1,xx=0,yy=0; cin&gt;&gt;r&gt;&gt;c&gt;&gt;m; B=pow(r*c,0.5)/pow(m,0.25)+1.0; for (i=1;i&lt;=r;++i) &#123; for (j=1;j&lt;=c;++j) &#123; cin&gt;&gt;a[i][j]; lsh[tot++]=a[i][j]; //这题要离散化 &#125; &#125; sort(lsh,lsh+tot); tot=unique(lsh,lsh+tot)-lsh; for (i=1;i&lt;=r;++i) &#123; for (j=1;j&lt;=c;++j) &#123; a[i][j]=lower_bound(lsh,lsh+tot,a[i][j])-lsh; &#125; &#125; for (i=0;i&lt;m;++i) &#123; cin&gt;&gt;q[i].x&gt;&gt;q[i].y&gt;&gt;q[i].xx&gt;&gt;q[i].yy; q[i].id=i; &#125; sort(q,q+m); for (i=0;i&lt;m;++i) &#123; while (x&gt;q[i].x) &#123; --x; for (j=y;j&lt;=yy;++j) &#123; add(a[x][j]); &#125; &#125; while (xx&lt;q[i].xx) &#123; ++xx; for (j=y;j&lt;=yy;++j) &#123; add(a[xx][j]); &#125; &#125; while (y&gt;q[i].y) &#123; --y; for (j=x;j&lt;=xx;++j) &#123; add(a[j][y]); &#125; &#125; while (yy&lt;q[i].yy) &#123; ++yy; for (j=x;j&lt;=xx;++j) &#123; add(a[j][yy]); &#125; &#125; while (x&lt;q[i].x) &#123; for (j=y;j&lt;=yy;++j) &#123; del(a[x][j]); &#125; ++x; &#125; while (xx&gt;q[i].xx) &#123; for (j=y;j&lt;=yy;++j) &#123; del(a[xx][j]); &#125; --xx; &#125; while (y&lt;q[i].y) &#123; for (j=x;j&lt;=xx;++j) &#123; del(a[j][y]); &#125; ++y; &#125; while (yy&gt;q[i].yy) &#123; for (j=x;j&lt;=xx;++j) &#123; del(a[j][yy]); &#125; --yy; &#125; out[q[i].id]=ans; &#125; for (i=0;i&lt;m;++i) &#123; cout&lt;&lt;out[i]&lt;&lt;endl; &#125; return 0;&#125;void add(int x)&#123; ans=ans+2*cnt[x]+1; ++cnt[x];&#125;void del(int x)&#123; ans=ans-2*cnt[x]+1; --cnt[x];&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018国庆YALI集训游记]]></title>
    <url>%2F2018%E5%9B%BD%E5%BA%86YALI%E9%9B%86%E8%AE%AD%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[想了想，像之前那样简略地叙述题意和做法，根本没讲清楚，没有任何意义，还不如写写自己的感受。 感觉YALI真的是一所挺不错的学校吧。总是能有一机房的julao轮番吊打你，总是能有集训队的奆佬来给你出dltm、给你讲题。每天放学回酒店的路上还能看到操场上一群目测是田径队之类的同学在努力地训练着。到处都洋溢着「青春」的氛围，反倒是老师见得很少（或许是国庆的缘故吧..）。YALI在我心中已经不止是那个在OIerDb的“全国信息学竞赛学校排名2018”上排名第一的学校了。 这几天去掉失误基本上都能排在前 $20$，但其他julao也会失误，所以是不存在“如果没有失误”的… 既然生在了弱省，就更要把眼光放在省外。OIerDb学校排行榜$rank1\sqrt{}$，OIerDb学校排行榜$rank5\sqrt{}​$。 虽然写的很短，还是比之前几乎什么都没写好吧. ———————————————以上于7号上午——————————————— 到了YALI的学生们返校的下午，YALI变得和外高没什么两样了…或许是那些国庆还在学校的人们让我看到了YALI不同的一面吧.]]></content>
      <tags>
        <tag>游记</tag>
        <tag>集训</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[莫队、带修莫队、树上莫队详解]]></title>
    <url>%2F%E8%8E%AB%E9%98%9F%E3%80%81%E5%B8%A6%E4%BF%AE%E8%8E%AB%E9%98%9F%E3%80%81%E6%A0%91%E4%B8%8A%E8%8E%AB%E9%98%9F%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[这几天学习了莫队算法，试着写一篇比较详细的莫队教程吧… 普通莫队简介莫队是一种基于分块思想的离线算法，用于解决区间问题，适用范围如下： 只有询问没有修改。 允许离线。 在已知询问 $[l,r]$ 答案的情况下可以 $O(1)$ 得到 $[l,r-1],[l,r+1],[l-1,r],[l+1,r]$ 的答案。 满足以上三个条件就可以在 $O(n\sqrt{m}+mlogm)$ 的时间复杂度下得到每个询问的解。 算法思想莫队的精髓就在于通过对询问进行排序，并把询问的结果作为下一个询问求解的基础，使得暴力求解的复杂度得到保证。 上文中“适用范围”的第三点“在已知询问 $[l,r]$ 答案的情况下可以 $O(1)$ 得到 $[l,r-1],[l,r+1],[l-1,r],[l+1,r]$ 的答案”即是“把询问的结果作为下一个询问求解的基础”的方法。 例：[国家集训队]小Z的袜子 在这题中，用 $cnt_i$ 表示当前处理的区间内颜色为i的袜子出现的次数，用 $\mathrm{len}$ 表示当前处理的区间的长度，用 $x$ 表示新增的那只袜子的颜色。 以已知区间 $[l,r]$ 的答案求解区间 $[l,r+1]$ 为例。分别处理分子和分母： 分母为任选两只袜子的组合总数，原先是 $\frac{\mathrm{len}(\mathrm{len}-1)}{2}$，现在是 $\frac{\mathrm{len}(\mathrm{len}+1)}{2}$，增加了 $\mathrm{len}$ 。 分子为两只袜子颜色相同的组合总数，比原来增加了 $cnt_x$，即新增的这只袜子和原本就在当前区间内的相同颜色的袜子的组合。 因此，将一只颜色为x的袜子计入答案的函数就可以写出来了： 12345678//fz代表分子，fm代表分母void add(int x)&#123; fz+=cnt[x]; ++cnt[x]; fm+=len; ++len;&#125; 同理可以写出将一只颜色为x的袜子移出答案的函数： 1234567void del(int x)&#123; --cnt[x]; fz-=cnt[x]; --len; fm-=len;&#125; 于是，我们就可以得到一个暴力的算法：用 $l$ 和 $r$ 分别记录当前区间的两个端点，然后用下面这段代码来更新答案（q[i].l,q[i].r代表正在处理的询问的两个端点，col[p]代表第 $p$ 只袜子的颜色）： 12345678910111213141516while (l&gt;q[i].l)&#123; add(col[--l]);&#125;while (r&lt;q[i].r)&#123; add(col[++r]);&#125;while (l&lt;q[i].l) &#123; del(col[l++]);&#125;while (r&gt;q[i].r)&#123; del(col[r--]);&#125; 然而，这个算法的时间复杂度是 $O(nm)$ 的（因为最坏情况下每次 $l$ 和 $r$ 两个指针都要走 $O(n)$ 的距离，而一共有 $m$ 次询问），和暴力完全一样甚至跑的更慢。 别忘了，之前我说过，莫队的精髓就在于通过对询问进行排序，使得暴力求解的复杂度得到保证。 我们的目的是使 $l$ 和 $r$ 两个指针走过的总距离尽量的小，这时候就要用到分块的思想了。 把整个区间 $[1,n]$ 分成若干块，以询问的左端点所在块为第一关键字，以询问的右端点大小为第二关键字，对询问进行排序，那么： 对于同一块的询问，$l$ 指针每次最多移动块的大小，$r$ 指针的移动则是单调的，总共移动最多 $n$ 。 对于不同块的询问，$l$ 每次换块时最多移动两倍块的大小， $r$ 每次换块时最多移动 $n$ 。 总结：（用 $B$ 表示块的大小）$l$ 指针每次移动 $O(B)$，$r$ 指针每块移动 $O(n)$ 。 所以： $l$ 的移动次数最多为询问数×块的大小，即 $O(mB)$ 。 $r$ 的移动次数最多为块的个数×总区间大小，即 $O(n^2/B)$ 。 因此，总移动次数为 $O(mB+n^2/B)$ 。 没错，这就是个双勾函数，所以当 $B=\sqrt{\frac{n^2}{m}}$ 即 $\frac{n}{\sqrt{m}}$ 时复杂度最小，为 $O(n\sqrt{m})$ 。 剩下的最后一个问题：初始的当前区间是什么？ 只要任意指定一个空区间就好了，如 $l=1,r=0$ 。 所以，整个莫队算法就可以概括为： 将询问记录下来。 以 $\frac{n}{\sqrt{m}}$ 为块的大小，以询问的左端点所在块为第一关键字，以询问的右端点大小为第二关键字，对询问进行排序。 暴力处理每个询问。 输出答案。 总的复杂度为 $O(n\sqrt{m}+mlogm)$ 。 P.S. 网上很多教程说分块大小取 $\sqrt{n}$ 最优，复杂度为 $O(n\sqrt{n})$，这是不严谨的，当n、m差别较大时使用 $\sqrt{n}$ 作为分块大小效率会明显偏低。 例题代码[国家集训队]小Z的袜子 AC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N=50010;void add(int x);void del(int x);int gcd(int a,int b);int n,m,B,fz,fm,len,col[N],cnt[N],ans[N][2];struct Query&#123; int l,r,id; bool operator&lt;(Query&amp; b) &#123; return l/B==b.l/B?r&lt;b.r:l&lt;b.l; &#125;&#125; q[N];int main()&#123; int i,l=1,r=0,g; cin&gt;&gt;n&gt;&gt;m; B=n/sqrt(m); for (i=1;i&lt;=n;++i) &#123; cin&gt;&gt;col[i]; &#125; for (i=0;i&lt;m;++i) &#123; cin&gt;&gt;q[i].l&gt;&gt;q[i].r; q[i].id=i; &#125; sort(q,q+m); for (i=0;i&lt;m;++i) &#123; if (q[i].l==q[i].r) &#123; ans[q[i].id][0]=0; ans[q[i].id][1]=1; continue; &#125; while (l&gt;q[i].l) &#123; add(col[--l]); &#125; while (r&lt;q[i].r) &#123; add(col[++r]); &#125; while (l&lt;q[i].l) &#123; del(col[l++]); &#125; while (r&gt;q[i].r) &#123; del(col[r--]); &#125; g=gcd(fz,fm); ans[q[i].id][0]=fz/g; ans[q[i].id][1]=fm/g; &#125; for (i=0;i&lt;m;++i) &#123; printf("%d/%d\n",ans[i][0],ans[i][1]); &#125; return 0;&#125;void add(int x)&#123; fz+=cnt[x]; ++cnt[x]; fm+=len; ++len;&#125;void del(int x)&#123; --cnt[x]; fz-=cnt[x]; --len; fm-=len;&#125;int gcd(int a,int b)&#123; return b==0?a:gcd(b,a%b);&#125; 其它例题小B的询问 带修莫队前面说过，普通的莫队只能解决没有修改的问题，那么带修改的问题怎么解决呢？带修莫队就是一种支持单点修改的莫队算法。 算法简介还是对询问进行排序，每个询问除了左端点和右端点还要记录这次询问是在第几次修改之后（时间），以左端点所在块为第一关键字，以右端点所在块为第二关键字，以时间为第三关键字进行排序。 暴力查询时，如果当前修改数比询问的修改数少就把没修改的进行修改，反之回退。 需要注意的是，修改分为两部分： 若修改的位置在当前区间内，需要更新答案（del原颜色，add修改后的颜色）。 无论修改的位置是否在当前区间内，都要进行修改（以供add和del函数在以后更新答案）。 ##分块大小的选择以及复杂度证明 （用 $B$ 表示分块大小，$c$ 表示修改个数，$q$ 表示询问个数，l块表示以 $l/B$ 分的块，r块表示以 $r/B$ 分的块，每个l块包含 $n/B$ 个r块） 对于时间指针 $now$：对于每个r块，最坏情况下会移动 $c$，共有 $\left(\frac{n}{B}\right)^2$ 个r块，所以总移动次数为 $\frac{cn^2}{B^2}$ 。 对于左端点指针 $l$ ：l块内移动每次最多 $B$，换l块每次最多 $2B$，所以总移动次数为 $O(qB)$ 。 对于右端点指针 $r$：r块内移动每次最多 $B$，换r块每次最多 $2B$，所有l块内移动次数之和为 $O(qB)$；换l块时最多移动 $n$，总的换l块时移动次数为 $O\left(\frac{n^2}{B}\right)$；所以总的移动次数为 $O\left(qB+\frac{n^2}{B}\right)$ 。 所以：总移动次数为 $O\left(\frac{cn^2}{B^2}+qB+\frac{n^2}{B}\right)$ 。 由于一般的题目都不会告诉你修改和询问分别的个数，所以统一用 $m$ 表示，即 $O\left(\frac{mn^2}{B^2}+mB+\frac{n^2}{B}\right)$ 。 那么 $B$ 取多少呢…Mathematica告诉我大约是这个： 所以还是不要纠结带修莫队的最佳分块大小好了…视作 $n=m​$ 的话，就可以得到总移动次数为 $O\left(\frac{n^3}{B^2}+nB+\frac{n^2}{B}\right)​$，那么 $B=n^{\frac{2}{3}}​$ 时取最小值 $O\left(n^{\frac{5}{3}}\right)​$ 。 所以：带修莫队的渐进时间复杂度为 $O\left(nlogn+n^{\frac{5}{3}}\right)$ （视作 $n=m$）。 例题代码这次就不详细分析例题了，直接上代码。 [国家集训队]数颜色 AC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;void add(int x);void del(int x);void modify(int x,int ti); //这个函数会执行或回退修改ti（执行还是回退取决于是否执行过，具体通过swap实现），x表明当前的询问是x，即若修改了区间[q[x].l,q[x].r]便要更新答案int n,m,B,cnt[1000010],a[50010],ans,ccnt,qcnt,now,out[50010];struct Change&#123; int p,col;&#125; c[50010];struct Query&#123; int l,r,t,id; bool operator&lt;(Query&amp; b) &#123; return l/B==b.l/B?(r/B==b.r/B?t&lt;b.t:r&lt;b.r):l&lt;b.l; &#125;&#125; q[50010];int main()&#123; int i,l=2,r=1; char type[10]; cin&gt;&gt;n&gt;&gt;m; B=pow(n,0.66666); for (i=1;i&lt;=n;++i) &#123; cin&gt;&gt;a[i]; &#125; for (i=1;i&lt;=m;++i) &#123; scanf("%s",type); if (type[0]=='Q') &#123; ++qcnt; cin&gt;&gt;q[qcnt].l&gt;&gt;q[qcnt].r; q[qcnt].t=ccnt; q[qcnt].id=qcnt; &#125; else &#123; ++ccnt; cin&gt;&gt;c[ccnt].p&gt;&gt;c[ccnt].col; &#125; &#125; sort(q+1,q+qcnt+1); for (i=1;i&lt;=qcnt;++i) &#123; while (l&gt;q[i].l) &#123; add(a[--l]); &#125; while (r&lt;q[i].r) &#123; add(a[++r]); &#125; while (l&lt;q[i].l) &#123; del(a[l++]); &#125; while (r&gt;q[i].r) &#123; del(a[r--]); &#125; while (now&lt;q[i].t) &#123; modify(i,++now); &#125; while (now&gt;q[i].t) &#123; modify(i,now--); &#125; out[q[i].id]=ans; &#125; for (i=1;i&lt;=qcnt;++i) &#123; cout&lt;&lt;out[i]&lt;&lt;endl; &#125; return 0;&#125;void add(int x)&#123; if (cnt[x]++==0) &#123; ++ans; &#125;&#125;void del(int x)&#123; if (--cnt[x]==0) &#123; --ans; &#125;&#125;void modify(int x,int ti)&#123; if (c[ti].p&gt;=q[x].l&amp;&amp;c[ti].p&lt;=q[x].r) &#123; del(a[c[ti].p]); add(c[ti].col); &#125; swap(a[c[ti].p],c[ti].col); //下次执行时必定是回退这次操作，直接互换就可以了 &#125; 其它例题CF940F Machine Learning 树上莫队其实，莫队算法除了序列还可以用于树。复杂度同序列上的莫队（不带修 $O(n\sqrt{m}+mlogm)$，带修 $O\left(nlogn+n^{\frac{5}{3}}\right)$）。 例题：[WC2013]糖果公园 分块方式这里需要看一道专门为树上莫队设计的题目 [SCOI2005]王室联邦。 用这道题所要求的方式进行分块，并用后文的方式更新答案，就能保证复杂度（复杂度分析见后文）。 那么如何满足每块大小在 $[B,3B]$，块内每个点到核心点路径上的所有点都在块内呢？ 这里先提供一种构造方式，再予以证明： dfs，并创建一个栈，dfs一个点时先记录初始栈顶高度，每dfs完当前节点的一棵子树就判断栈内（相对于刚开始dfs时）新增节点的数量是否&gt;=B，是则将栈内所有新增点分为同一块，核心点为当前dfs的点，当前节点结束dfs时将当前节点入栈，整个dfs结束后将栈内所有剩余节点归入已经分好的最后一个块。 参考代码： 12345678910111213141516171819202122232425262728void dfs(int u,int fa)&#123; int t=top; for (int i=head[u];i;i=nxt[i]) &#123; int v=to[i]; if (v!=fa) &#123; dfs(v,u); if (top-t&gt;=B) &#123; ++tot; while (top&gt;t) &#123; bl[sta[top--]]=tot; &#125; &#125; &#125; &#125; sta[++top]=u;&#125;dfs(1,0);while (top)&#123; bl[sta[top--]]=tot;&#125; 如果你看懂了这个方法的话，每块大小&gt;=B是显然的，下面证明为何每块大小&lt;=3B： 对于当前节点的每一棵子树： 若未被分块的节点数&gt;B，那么在dfs这棵子树的根节点时就一定会把这棵子树的一部分分为一块直至这棵子树的剩余节点数&lt;=B，所以这种情况不存在。 若未被分块的节点数=B，这些节点一定会和栈中所有节点分为一块，栈中之前还剩 $[0,B-1]$ 个节点，那么这一块的大小为 $[B,2B-1]$ 。 若未被分块的节点数&lt;B，当未被分块的节点数+栈中剩余节点数&gt;=B时，这一块的大小为 $[B,2B-1)$，否则继续进行下一棵子树。 对于dfs结束后栈内剩余节点，数量一定在 $[1,B]$ 内，而已经分好的每一块的大小为 $[B,2B-1]$，所以每块的大小都在 $[B,3B)$ 内（我看有的博客写的剩余节点数量在 $[1,B+1]$ 内，所以最后一块可能达到 $3B$…然而我觉得最多 $3B-1$啊QAQ）。 修改方式所谓“修改”，就是由询问 $(cu,cv)$ 更新至询问 $(tu,tv)$ 。 如果把两条路径上的点全部修改..显然是和暴力一样的嘛！ 这里直接给出结论好了… （下文中 $T(u,v)$ 表示 $u$ 到 $v$ 的路径上除 $lca(u,v)$ 外的所有点构成的集合，$S(u,v)$ 代表u到v的路径，$xor$ 表示集合对称差（就跟异或差不多）） 两个指针 $cu,cv$ （相当于序列莫队的 $l,r$ 两个指针）， $ans$记录$T(cu,cv)$ 的答案，$vis$ 数组记录每个节点是否在 $T(cu,cv)$ 内； 由 $T(cu,cv)$ 更新至 $T(tu,tv)$ 时，将 $T(cu,tu)$ 和 $T(cv,tv)$ 的 $vis$ 分别取反，并相应地更新答案； 将答案记录到 $out$ 数组（离线后用于输出那个）时对 $lca(cu,cv)$ （此时的 $cu,cv$ 已更新为上一步中的 $tu,tv$） 的 $vis$ 取反并更新答案，记录完再改回来（因为lca比较烦，所以就这样做了QAQ）。 第二步证明如下： $\quad\,T(cu,cv) xor T(tu,tv)$ $=[S(cu,root) xor S(cv,root)] xor [S(tu,root) xor S(tv,root)]$ （lca及以上相消） $=[S(cu,root) xor S(tu,root)] xor [S(cv,root) xor S(tv,root)]$ （交换律、结合律） $=T(cu,tu) xor T(cv,tv)$ 之所以要把 $T(cu,cv) xor T(tu,tv)$ 转化成 $T(cu,tu) xor T(cv,tv)$，是因为这样的话就能通过对询问排序来保证复杂度。 关于单点修改树上莫队的单点修改和序列莫队类似，唯一不同就是，修改后是否更新答案通过vis数组判断。 复杂度分析每块大小在 $[B,3B)$，所以两点间路径长度也在 $[B,3B)$，块内移动就是 $O(B)$ 的；编号相邻的块位置必然是相邻的，所以两块间路径长度也是 $O(B)$；然后就和序列莫队的复杂度分析类似了… 例题代码[WC2013]糖果公园 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N=100010;void pathmodify(int u,int v); //将T(u,v)取反并更新答案void opp(int x); //将节点x取反并更新答案void modify(int ti); //进行或回退修改tiint lca(int u,int v);void dfs(int u); //进行分块并记录dep数组、f数组（用于求lca、两点间路径）void add(int u,int v);int head[N],nxt[N&lt;&lt;1],to[N&lt;&lt;1],cnt;int n,m,Q,B,bl[N],tot,V[N],W[N],a[N],sta[N],top,qcnt,ccnt,dep[N],f[20][N],num[N],now;long long ans,out[N];bool vis[N];struct Query&#123; int u,v,t,id; bool operator&lt;(Query&amp; y) &#123; return bl[u]==bl[y.u]?(bl[v]==bl[y.v]?t&lt;y.t:bl[v]&lt;bl[y.v]):bl[u]&lt;bl[y.u]; &#125;&#125; q[N];struct Change&#123; int p,x;&#125; c[N];int main()&#123; int i,j,u,v,lc,type; cin&gt;&gt;n&gt;&gt;m&gt;&gt;Q; B=pow(n,0.666); for (i=1;i&lt;=m;++i) &#123; cin&gt;&gt;V[i]; &#125; for (i=1;i&lt;=n;++i) &#123; cin&gt;&gt;W[i]; &#125; for (i=1;i&lt;n;++i) &#123; cin&gt;&gt;u&gt;&gt;v; add(u,v); add(v,u); &#125; dfs(1); for (i=1;i&lt;=16;++i) &#123; for (j=1;j&lt;=n;++j) &#123; f[i][j]=f[i-1][f[i-1][j]]; &#125; &#125; while (top) &#123; bl[sta[top--]]=tot; &#125; for (i=1;i&lt;=n;++i) &#123; cin&gt;&gt;a[i]; &#125; for (i=0;i&lt;Q;++i) &#123; cin&gt;&gt;type; if (type==0) &#123; ++ccnt; cin&gt;&gt;c[ccnt].p&gt;&gt;c[ccnt].x; &#125; else &#123; cin&gt;&gt;q[qcnt].u&gt;&gt;q[qcnt].v; q[qcnt].t=ccnt; q[qcnt].id=qcnt; ++qcnt; &#125; &#125; sort(q,q+qcnt); u=v=1; for (i=0;i&lt;qcnt;++i) &#123; pathmodify(u,q[i].u); pathmodify(v,q[i].v); u=q[i].u; v=q[i].v; while (now&lt;q[i].t) &#123; modify(++now); &#125; while (now&gt;q[i].t) &#123; modify(now--); &#125; lc=lca(u,v); opp(lc); out[q[i].id]=ans; opp(lc); &#125; for (i=0;i&lt;qcnt;++i) &#123; cout&lt;&lt;out[i]&lt;&lt;endl; &#125; return 0;&#125;void pathmodify(int u,int v)&#123; if (dep[u]&lt;dep[v]) &#123; swap(u,v); &#125; while (dep[u]&gt;dep[v]) &#123; opp(u); u=f[0][u]; &#125; while (u!=v) &#123; opp(u); opp(v); u=f[0][u]; v=f[0][v]; &#125;&#125;void opp(int x)&#123; if (vis[x]) &#123; ans-=1ll*V[a[x]]*W[num[a[x]]--]; &#125; else &#123; ans+=1ll*V[a[x]]*W[++num[a[x]]]; &#125; vis[x]^=1;&#125;void modify(int ti)&#123; if (vis[c[ti].p]) &#123; opp(c[ti].p); swap(a[c[ti].p],c[ti].x); opp(c[ti].p); &#125; else &#123; swap(a[c[ti].p],c[ti].x); &#125;&#125;int lca(int u,int v)&#123; if (dep[u]&lt;dep[v]) &#123; swap(u,v); &#125; int i; for (i=0;i&lt;=16;++i) &#123; if ((dep[u]-dep[v])&amp;(1&lt;&lt;i)) &#123; u=f[i][u]; &#125; &#125; if (u==v) &#123; return u; &#125; for (i=16;i&gt;=0;--i) &#123; if (f[i][u]!=f[i][v]) &#123; u=f[i][u]; v=f[i][v]; &#125; &#125; return f[0][u];&#125;void dfs(int u)&#123; int t=top; for (int i=head[u];i;i=nxt[i]) &#123; int v=to[i]; if (v!=f[0][u]) &#123; f[0][v]=u; dep[v]=dep[u]+1; dfs(v); if (top-t&gt;=B) &#123; ++tot; while (top&gt;t) &#123; bl[sta[top--]]=tot; &#125; &#125; &#125; &#125; sta[++top]=u;&#125;void add(int u,int v)&#123; nxt[++cnt]=head[u]; head[u]=cnt; to[cnt]=v;&#125; 莫队的扩展其实莫队可以扩展到高维，参见二维莫队解题报告。 更一般地，若 $Q(x_1,x_2,\cdots,x_k)$ 为一个询问，$\forall i\in[1,k]$，$x_i$ 的规模都为 $n$，可以在时间 $\mathrm{T}$ 内求解 $Q(x_1,x_2,\cdots,x_i\pm 1,\cdots,x_n)$，共有 $m$ 个询问，那么就可以在 $O\left(kmlogm+nTm^\frac{k-1}{k}\right)$ 的时间复杂度下离线求解。 （蒟蒻的大胆猜想而已..并没有严格证明） To be finished:回滚莫队（只增莫队）..（有时间再填坑吧Orz）]]></content>
      <tags>
        <tag>莫队</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[好用的网站]]></title>
    <url>%2F%E5%A5%BD%E7%94%A8%E7%9A%84%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[一些好用的网站。 $\text{图床}$ $\text{几何}$ $\text{图论}$ $\text{函数}$ $\text{找规律}$ $\text{矩阵运算}$ $\text{在线汇编编译器}$ $\mathrm{C++}$ $\LaTeX\text{公式大全}​$ $\LaTeX\text{公式奆全}$ $\text{.tex}$教程 $\text{OI Wiki}$ $\text{Wolfram Alpha}$ $\text{oier数据库}$]]></content>
      <tags>
        <tag>收藏</tag>
      </tags>
  </entry>
</search>
