<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[树分块学习笔记]]></title>
    <url>%2F%E6%A0%91%E5%88%86%E5%9D%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[最近发现 OI Wiki 的“树分块”是空的，本来想凭着之前写的莫队教程水一水，结果被告知已经有人写过树上莫队了..于是就得详细介绍一下树分块除了树上莫队以外的应用..然而我除了糖果公园只做过一道树分块..（结果最后并没有找到这道题以外的其它题..） 树分块的方式可以参考 OI Wiki/莫队算法/真-树上莫队。 也可以参考 ouuan的博客/莫队、带修莫队、树上莫队详解/树上莫队。 树上莫队同样可以参考以上两篇文章。 树分块的应用树分块除了应用于莫队，还可以灵活地运用到某些树上问题中。但可以用树分块解决的题目往往都有更优秀的做法，所以相关的题目较少。 顺带提一句，“gty的妹子树”的树分块做法可以被菊花图卡掉。 BZOJ4763 雪辉先进行树分块，然后对每个块的关键点，预处理出它到祖先中每个关键点的路径上颜色的 bitset，以及每个关键点的最近关键点祖先，复杂度是 $\mathcal O(n\sqrt n+\frac{nc}{32})​$，其中 $n\sqrt n​$ 是暴力从每个关键点向上跳的复杂度，$\frac{nc}{32}​$ 是把 $\mathcal O(n)​$ 个 bitset 存下来的复杂度。 回答询问的时候，先从路径的端点暴力跳到所在块的关键点，再从所在块的关键点一块一块地向上跳，直到 $lca$ 所在块，然后再暴力跳到 $lca$。关键点之间的 bitset 已经预处理了，剩下的在暴力跳的过程中计算。单次询问复杂度是 $\mathcal O(\sqrt n+\frac c{32})$，其中 $\sqrt n$ 是块内暴力跳以及块直接向上跳的复杂度，$\mathcal O(\frac c{32})$ 是将预处理的结果与暴力跳的结果合并的复杂度。数颜色个数可以用 bitset 的 count()，求 $\operatorname{mex}$ 可以用 bitset 的 _Find_first()。 所以，总复杂度为 $\mathcal O((n+m)(\sqrt n+\frac c{32}))​$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;bitset&gt;#include &lt;algorithm&gt;using namespace std;int read()&#123; int out=0; char c; while (!isdigit(c=getchar())); for (;isdigit(c);c=getchar()) out=out*10+c-'0'; return out;&#125;const int N=100010;const int B=666;const int C=30000;void add(int u,int v);void dfs(int u);int head[N],nxt[N&lt;&lt;1],to[N&lt;&lt;1],cnt;int n,m,type,c[N],fa[N],dep[N],sta[N],top,tot,bl[N],key[N/B+5],p[N],keyid[N];bool vis[N];bitset&lt;C&gt; bs[N/B+5][N/B+5],temp;int main()&#123; int i,u,v,x,y,k,lastans=0; n=read(); m=read(); type=read(); for (i=1;i&lt;=n;++i) c[i]=read(); for (i=1;i&lt;n;++i) &#123; u=read(); v=read(); add(u,v); add(v,u); &#125; dfs(1); if (!tot) ++tot; if (keyid[key[tot]]==tot) keyid[key[tot]]=0; key[tot]=1; keyid[1]=tot; while (top) bl[sta[top--]]=tot; for (i=1;i&lt;=tot;++i) //预处理 &#123; if (vis[key[i]]) continue; vis[key[i]]=true; temp.reset(); for (u=key[i];u;u=fa[u]) &#123; temp[c[u]]=1; if (keyid[u]) &#123; if (!p[key[i]]&amp;&amp;u!=key[i]) p[key[i]]=u; bs[keyid[key[i]]][keyid[u]]=temp; &#125; &#125; &#125; while (m--) &#123; k=read(); temp.reset(); while (k--) &#123; u=x=read()^lastans; v=y=read()^lastans; while (key[bl[x]]!=key[bl[y]]) &#123; if (dep[key[bl[x]]]&gt;dep[key[bl[y]]]) &#123; if (x==u) //若是第一次跳先暴力跳到关键点 &#123; while (x!=key[bl[u]]) &#123; temp[c[x]]=1; x=fa[x]; &#125; &#125; else x=p[x]; //否则跳一整块 &#125; else &#123; if (y==v) &#123; while (y!=key[bl[v]]) &#123; temp[c[y]]=1; y=fa[y]; &#125; &#125; else y=p[y]; &#125; &#125; if (keyid[x]) temp|=bs[keyid[key[bl[u]]]][keyid[x]]; if (keyid[y]) temp|=bs[keyid[key[bl[v]]]][keyid[y]]; while (x!=y) &#123; if (dep[x]&gt;dep[y]) &#123; temp[c[x]]=1; x=fa[x]; &#125; else &#123; temp[c[y]]=1; y=fa[y]; &#125; &#125; temp[c[x]]=true; &#125; int ans1=temp.count(),ans2=(~temp)._Find_first(); printf("%d %d\n",ans1,ans2); lastans=(ans1+ans2)*type; &#125; return 0;&#125;void dfs(int u)&#123; int i,v,t=top; for (i=head[u];i;i=nxt[i]) &#123; v=to[i]; if (v==fa[u]) continue; fa[v]=u; dep[v]=dep[u]+1; dfs(v); if (top-t&gt;=B) &#123; key[++tot]=u; if (!keyid[u]) keyid[u]=tot; while (top&gt;t) bl[sta[top--]]=tot; &#125; &#125; sta[++top]=u;&#125;void add(int u,int v)&#123; nxt[++cnt]=head[u]; head[u]=cnt; to[cnt]=v;&#125; BZOJ4812 由乃打扑克这题和上一题基本一样，唯一的区别是得到 bitset 后如何计算答案。 由于BZOJ是计算所有测试点总时限，不好卡，所以可以用 _Find_next() 水过去。 正解是每 $16$ 位一起算，先预处理出 $2^{16}$ 种可能的情况高位连续 $1$ 的个数、低位连续 $1$ 的个数以及中间的贡献。只不过这样要手写 bitset，因为标准库的 bitset 不能取某 $16$ 位.. 代码可以参考这篇博客。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>分块</tag>
        <tag>树分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019省选复习周做题计划]]></title>
    <url>%2F2019%E7%9C%81%E9%80%89%E5%A4%8D%E4%B9%A0%E5%91%A8%E5%81%9A%E9%A2%98%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[随便找了点省选前需要复习的知识点相关的题目.. 题目LCT/树剖共价大爷游长沙 小清新数据结构题 最小差值生成树 QTREE4 淀粉质树上游戏 字符串[APIO2014]回文串 [HEOI2016/TJOI2016]字符串 Trie最大异或和 最长异或路径 整体二分/树套树[ZJOI2013]K大数查询 cdq分治[Violet]天使玩偶/SJY摆棋子 [NOI2007]货币兑换 莫比乌斯反演[SDOI2014]数表 最小公倍数之和 Lucas的数论 组合数学、容斥原理、斯特林数重返现世 [HEOI2016/TJOI2016]求和 [国家集训队] Crash 的文明世界 多项式、生成函数食物 [CodeChef] COUNTARI 万径人踪灭 The Child and Binary Tree 城市规划 付公主的背包 玩游戏 记录共价大爷游长沙：如果要获取一个点的子树信息，要么 access 父亲 Splay 自己然后看实+虚+自己，要么 access 自己然后看虚+自己。 最大异或和：一开始尝试用线段树合并做，复杂度是 $\mathcal O(n(\log(n+m)+\log w)+m\log(n+m)\log w)$，卡常卡不过去，尝试用 bitset 优化，后来发现除以 $32$ 被 $\log$ 掉了，加上带来的一些常数后根本没有优化.. 只不过后来发现可持久化 Trie 真的挺好写的，（只要会主席树不需要学也能 yy 出来的感觉）。]]></content>
      <categories>
        <category>计划</category>
      </categories>
      <tags>
        <tag>省选</tag>
        <tag>题表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树状数组——从背模板到树套树]]></title>
    <url>%2F%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E2%80%94%E2%80%94%E4%BB%8E%E8%83%8C%E6%A8%A1%E6%9D%BF%E5%88%B0%E6%A0%91%E5%A5%97%E6%A0%91%2F</url>
    <content type="text"><![CDATA[这是一篇披着PJ组数据结构外衣的树套树教程。 大约会（尝试着）较为本质地简介一下树状数组？ 基础树状数组树状数组，英文名 BIT(Binary Indexed Tree)（不是TreeArray）。 原理的话..看图大约是一目了然的： 其中，黑色的矩形（包括红色的正方形）代表这一部分的和，而红色的正方形代表这部分和在树状数组中的下标。如果把这些区间连边，就像是一棵二叉树，所以叫树状数组。 举几个栗子，$BIT[3]$ 表示 $A[3]$，$BIT[6]$ 表示 $A[5]+A[6]$，$BIT[12]$ 表示 $A[9]+A[10]+A[11]+A[12]$。 我们把每个下标用二进制表示，可以发现，二进制表示的末尾有 $k​$ 个 $0​$，在树状数组里它就代表一段长为 $2^k​$ 的区间的和。由于树状数组和下标的二进制联系紧密，所以英文叫 Binary Indexed Tree。 可以定义 $lowbit(x)$ 为 $x$ 的二进制表示中最低位的 $1$ 表示的数。如 $lowbit(101_{(2)})=1$，$lowbit(110100_{(2)}=4)$，这样的话，树状数组中下标为 $x$ 的元素就表示了一段长为 $lowbit(x)$ 的区间的和。 由于计算机中存储带符号整数的方式，$lowbit(x)=$x&amp;-x，具体原因可以自行搜索“补码”。 考虑如何更新树状数组：如果我们要更新第 $p$ 位，先更新 $BIT[p]$，再更新 $BIT[p+lowbit(p)]$，再更新 $BIT[p+lowbit(p)+lowbit(p+lowbit(p))]$……一直更新到原数列的长度。 考虑如何查询某个前缀和：如果我们要查询前 $p$ 位的前缀和，结果就是 $BIT[p]+BIT[p-lowbit(p)]+BIT[p-lowbit(p)-lowbit(p-lowbit(p))]$……一直查询到 $lowbit$ 为 $1$ 的节点。 把树状数组看成二叉树，深度不超过 $\log(n)$，所以单次操作复杂度是 $\mathcal O(\log n)$。 大概就是这样，代码比较简短： 1234567891011void add(int p,int x)&#123; for (;p&lt;=n;p+=(p&amp;-p)) BIT[p]+=x;&#125;int query(int p)&#123; int out=0; for (;p;p-=(p&amp;-p)) out+=BIT[p]; return out;&#125; 稍进阶一点点的树状数组由于本篇教程是“从背模板到树套树”而不是“摆脱线段树与平衡树”，所以不会提及那方面的高级用法。 维护前缀积把+改成*。 维护前缀异或和把+改成^。 维护前缀矩阵积把+改成矩阵乘法。 诶，等等，怎么全WA了？ 因为矩阵乘法不具有交换律.. 比如说，两个矩阵 $A$ 和 $B$，树状数组里存的是 $A$ 和 $A\times B$，把 $A$ 乘上 $C$ 后树状数组里第二项我们期望它是 $A\times C\times B$，而实际上它是 $A\times B\times C$.. 所以树状数组到底在维护什么？ 警告：本人其实没怎么学过群论..下文群论相关可能有口胡成分。 在维护一个阿贝尔群.. 等等，群是什么？群号多少？ ..就是一堆元素，定义了一种运算，它满足结合律、交换律，有单位元（谁和它运算都得到本身）、逆元（每个元素都存在一个元素运算后得到单位元）。如果只是前缀信息按理来说是不需要逆元的..然而一般都是要维护区间信息，而不只是前缀信息，所以需要逆元.. 树状数组套动态开点线段树简介终于到正题了。 我们来定义一个阿贝尔群： 它的元素是一些同构的动态开点线段树，运算是把对应节点的信息相加，要求节点维护的信息是阿贝尔群。 一般来说，主席树可以解决的静态问题带修就要用树套树了.. 修改就是把树状数组里的+换成动态开点线段树的修改操作，询问就是把+换成merge。直接 merge 复杂度好像不太对..（其实我不太会证线段树合并复杂度..）所以可以开个数组，把需要询问的节点存下来，然后在询问函数里合并信息。如果是询问区间，就把两个端点在树状数组里对应的节点存下来。 例题P2617 Dynamic Rankings代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;using namespace std;int read()&#123; int out=0; char c; while (!isdigit(c=getchar())); for (;isdigit(c);c=getchar()) out=out*10+c-'0'; return out;&#125;const int N=100001;struct Node&#123; int val,ls,rs;&#125; t[N&lt;&lt;9];int modify(int x,int l,int r,int p,int type);int merge(int x,int y);int query(int l,int r,int k);void change(int p,int x,int y);int n,m,tot,a[N],BIT[N],lsh[N&lt;&lt;1],cnt,tp[N],l[N],r[N],xx[N],totx,toty,x[N],y[N];char op[10];int main()&#123; int i,j; n=read(); m=read(); for (i=1;i&lt;=n;++i) lsh[++cnt]=a[i]=read(); for (i=1;i&lt;=m;++i) &#123; scanf("%s",op); if (op[0]=='Q') &#123; tp[i]=0; l[i]=read(); r[i]=read(); xx[i]=read(); &#125; else &#123; tp[i]=1; l[i]=read(); lsh[++cnt]=xx[i]=read(); &#125; &#125; sort(lsh+1,lsh+cnt+1); cnt=unique(lsh+1,lsh+cnt+1)-lsh; for (i=1;i&lt;=n;++i) &#123; a[i]=lower_bound(lsh+1,lsh+cnt,a[i])-lsh; change(i,a[i],1); &#125; for (i=1;i&lt;=m;++i) &#123; if (tp[i]) &#123; change(l[i],a[l[i]],-1); change(l[i],a[l[i]]=xx[i]=lower_bound(lsh+1,lsh+cnt,xx[i])-lsh,1); &#125; else &#123; totx=toty=0; for (j=l[i]-1;j;j-=(j&amp;-j)) x[++totx]=BIT[j]; for (j=r[i];j;j-=(j&amp;-j)) y[++toty]=BIT[j]; printf("%d\n",query(1,cnt,xx[i])); &#125; &#125; return 0;&#125;void change(int p,int x,int y)&#123; for (;p&lt;=n;p+=(p&amp;-p)) BIT[p]=modify(BIT[p],1,cnt,x,y);&#125;int modify(int x,int l,int r,int p,int type)&#123; int u=++tot; t[u]=t[x]; t[u].val+=type; if (l==r-1) return u; int mid=l+r&gt;&gt;1; if (p&lt;mid) t[u].ls=modify(t[u].ls,l,mid,p,type); else t[u].rs=modify(t[u].rs,mid,r,p,type); return u;&#125;int query(int l,int r,int k)&#123; if (l==r-1) return lsh[l]; int i,sum=0; for (i=1;i&lt;=totx;++i) sum-=t[t[x[i]].ls].val; for (i=1;i&lt;=toty;++i) sum+=t[t[y[i]].ls].val; if (sum&gt;=k) &#123; for (i=1;i&lt;=totx;++i) x[i]=t[x[i]].ls; for (i=1;i&lt;=toty;++i) y[i]=t[y[i]].ls; return query(l,l+r&gt;&gt;1,k); &#125; else &#123; for (i=1;i&lt;=totx;++i) x[i]=t[x[i]].rs; for (i=1;i&lt;=toty;++i) y[i]=t[y[i]].rs; return query(l+r&gt;&gt;1,r,k-sum); &#125;&#125; P3380 【模板】二逼平衡树（树套树）代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;using namespace std;const int N=50010;const int INF=0x7fffffff;int read()&#123; int out=0; char c; while (!isdigit(c=getchar())); for (;isdigit(c);c=getchar()) out=out*10+c-'0'; return out;&#125;struct Node&#123; int val,ls,rs;&#125; t[N&lt;&lt;8];int insert(int x,int l,int r,int p,int type);int qsum(int l,int r,int L,int R,int d);int kth(int l,int r,int k);void modify(int p,int x,int y);int n,m,tot,a[N],BIT[N],lsh[N&lt;&lt;1],cnt,op[N],l[N],r[N],k[N],totx,toty,X[20][N],Y[20][N];int main()&#123; int i,p; n=read(); m=read(); for (i=1;i&lt;=n;++i) a[i]=lsh[++cnt]=read(); for (i=1;i&lt;=m;++i) &#123; op[i]=read(); if (op[i]==3) &#123; l[i]=read(); k[i]=lsh[++cnt]=read(); &#125; else &#123; l[i]=read(); r[i]=read(); k[i]=read(); if (op[i]!=2) lsh[++cnt]=k[i]; &#125; &#125; sort(lsh+1,lsh+cnt+1); cnt=unique(lsh+1,lsh+cnt+1)-lsh; for (i=1;i&lt;=n;++i) &#123; a[i]=lower_bound(lsh+1,lsh+cnt,a[i])-lsh; modify(i,a[i],1); &#125; for (i=1;i&lt;=m;++i) &#123; if (op[i]==3) &#123; k[i]=lower_bound(lsh+1,lsh+cnt,k[i])-lsh; modify(l[i],a[l[i]],-1); modify(l[i],a[l[i]]=k[i],1); &#125; else &#123; totx=toty=0; for (p=l[i]-1;p;p-=(p&amp;-p)) X[0][++totx]=BIT[p]; for (p=r[i];p;p-=(p&amp;-p)) Y[0][++toty]=BIT[p]; if (op[i]==2) printf("%d\n",kth(1,cnt,k[i])); else &#123; k[i]=lower_bound(lsh+1,lsh+cnt,k[i])-lsh; if (op[i]==1) printf("%d\n",qsum(1,cnt,1,k[i],0)+1); else if (op[i]==4) &#123; int rk=qsum(1,cnt,1,k[i],0); if (rk) printf("%d\n",kth(1,cnt,rk)); else printf("%d\n",-INF); &#125; else &#123; int rk=qsum(1,cnt,1,k[i]+1,0); if (rk&lt;=r[i]-l[i]) printf("%d\n",kth(1,cnt,rk+1)); else printf("%d\n",INF); &#125; &#125; &#125; &#125; return 0;&#125;void modify(int p,int x,int y)&#123; for (;p&lt;=n;p+=(p&amp;-p)) BIT[p]=insert(BIT[p],1,cnt,x,y);&#125;int insert(int x,int l,int r,int p,int type)&#123; int u=++tot; t[u]=t[x]; t[u].val+=type; if (l==r-1) return u; int mid=l+r&gt;&gt;1; if (p&lt;mid) t[u].ls=insert(t[u].ls,l,mid,p,type); else t[u].rs=insert(t[u].rs,mid,r,p,type); return u;&#125;int qsum(int l,int r,int L,int R,int d)&#123; if (l&gt;=R||r&lt;=L) return 0; int i,sum=0; if (L&lt;=l&amp;&amp;R&gt;=r) &#123; for (i=1;i&lt;=totx;++i) sum-=t[X[d][i]].val; for (i=1;i&lt;=toty;++i) sum+=t[Y[d][i]].val; return sum; &#125; for (i=1;i&lt;=totx;++i) X[d+1][i]=t[X[d][i]].ls; for (i=1;i&lt;=toty;++i) Y[d+1][i]=t[Y[d][i]].ls; sum=qsum(l,l+r&gt;&gt;1,L,R,d+1); for (i=1;i&lt;=totx;++i) X[d+1][i]=t[X[d][i]].rs; for (i=1;i&lt;=toty;++i) Y[d+1][i]=t[Y[d][i]].rs; return sum+qsum(l+r&gt;&gt;1,r,L,R,d+1);&#125;int kth(int l,int r,int k)&#123; if (l==r-1) return lsh[l]; int i,sum=0; for (i=1;i&lt;=totx;++i) sum-=t[t[X[0][i]].ls].val; for (i=1;i&lt;=toty;++i) sum+=t[t[Y[0][i]].ls].val; if (sum&gt;=k) &#123; for (i=1;i&lt;=totx;++i) X[0][i]=t[X[0][i]].ls; for (i=1;i&lt;=toty;++i) Y[0][i]=t[Y[0][i]].ls; return kth(l,l+r&gt;&gt;1,k); &#125; for (i=1;i&lt;=totx;++i) X[0][i]=t[X[0][i]].rs; for (i=1;i&lt;=toty;++i) Y[0][i]=t[Y[0][i]].rs; return kth(l+r&gt;&gt;1,r,k-sum);&#125; [CQOI2011]动态逆序对这题用树套树做有点卡空间..需要把带返回值的动态开点改成直接修改。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt; using namespace std;int read()&#123; int out=0; char c; while (!isdigit(c=getchar())); for (;isdigit(c);c=getchar()) out=out*10+c-'0'; return out;&#125;const int N=100010;struct Node&#123; int val,ls,rs;&#125; t[N*90];void change(int&amp; u,int l,int r,int p);int query(int l,int r,int L,int R,int d);int n,m,a[N],p[N],del[N],BIT[N],x[20][20],y[20][20],xtot,ytot,tot;bool deleted[N];long long ans,out[N];int main()&#123; int i,j; n=read(); m=read(); for (i=1;i&lt;=n;++i) &#123; a[i]=read(); p[a[i]]=i; &#125; for (i=1;i&lt;=m;++i) &#123; del[i]=p[read()]; deleted[del[i]]=true; &#125; for (i=n;i&gt;=1;--i) &#123; if (!deleted[i]) &#123; for (j=a[i];j;j-=(j&amp;-j)) ans+=BIT[j]; for (j=a[i];j&lt;=n;j+=(j&amp;-j)) ++BIT[j]; &#125; &#125; memset(BIT,0,sizeof(BIT)); for (i=1;i&lt;=n;++i) &#123; if (!deleted[i]) &#123; for (j=i;j&lt;=n;j+=(j&amp;-j)) &#123; change(BIT[j],1,n+1,a[i]); &#125; &#125; &#125; for (i=m;i&gt;=1;--i) &#123; xtot=ytot=0; for (j=del[i];j;j-=(j&amp;-j)) y[0][++ytot]=BIT[j]; ans+=query(1,n+1,a[del[i]]+1,n+1,0); xtot=ytot=0; for (j=del[i];j;j-=(j&amp;-j)) x[0][++xtot]=BIT[j]; for (j=n;j;j-=(j&amp;-j)) y[0][++ytot]=BIT[j]; ans+=query(1,n+1,1,a[del[i]],0); for (j=del[i];j&lt;=n;j+=(j&amp;-j)) change(BIT[j],1,n+1,a[del[i]]); out[i]=ans; &#125; for (i=1;i&lt;=m;++i) printf("%lld\n",out[i]); return 0;&#125;void change(int&amp; u,int l,int r,int p)&#123; if (!u) u=++tot; ++t[u].val; if (l==r-1) return; int mid=l+r&gt;&gt;1; if (p&lt;mid) change(t[u].ls,l,mid,p); else change(t[u].rs,mid,r,p);&#125;int query(int l,int r,int L,int R,int d)&#123; if (l&gt;=R||r&lt;=L) return 0; int i,ret=0,mid=l+r&gt;&gt;1; if (L&lt;=l&amp;&amp;R&gt;=r) &#123; for (i=1;i&lt;=xtot;++i) ret-=t[x[d][i]].val; for (i=1;i&lt;=ytot;++i) ret+=t[y[d][i]].val; return ret; &#125; for (i=1;i&lt;=xtot;++i) x[d+1][i]=t[x[d][i]].ls; for (i=1;i&lt;=ytot;++i) y[d+1][i]=t[y[d][i]].ls; ret+=query(l,mid,L,R,d+1); for (i=1;i&lt;=xtot;++i) x[d+1][i]=t[x[d][i]].rs; for (i=1;i&lt;=ytot;++i) y[d+1][i]=t[y[d][i]].rs; ret+=query(mid,r,L,R,d+1); return ret;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树状数组</tag>
        <tag>树套树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cdq分治学习笔记]]></title>
    <url>%2Fcdq%E5%88%86%E6%B2%BB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[cdq分治也是咕了好久了..最近总算把它学了。 cdq分治是一种离线算法，可以代替一些复杂的数据结构，降低代码难度，减小常数。废话大家都知道。 本文未完待续（cdq分治的其它应用，如维护凸壳，待填坑）。 简介感觉cdq分治不如叫“ex归并排序”，就是以操作的时间作为初始顺序，在递归处理的过程中按位置归并排序。 更一般地说，对于一个二维偏序 $P(i,j)=P_1(a_i,a_j)\land P_2(b_i,b_j)​$，位置 $i​$ 的修改对位置 $j​$ 的询问（询问为类前缀和形式，区间询问需拆成两个前缀询问）有影响当且仅当 $P(i,j)=true​$，cdq分治就是以其中一维为初始顺序，对另一维进行归并排序的过程中计算左区间里修改的总和，将左区间修改的影响应用到右区间。 学会了之后就会发现，cdq分治的确就是这样，已经描述的很清楚了，然而在没学会的时候估计是看不懂上面这段话的..所以结合具体题目来看一看吧。 例题P3374 【模板】树状数组 1树状数组裸题！冷静，我们来用ex归并排序做..（嗯，我决定就这么叫它了） 按照我们上面说的，我们把操作存下来，询问拆成两个前缀和相减，初始值视作修改，需要存的信息有操作的种类（修改、询问的左端点减一、询问的右端点），操作的位置（$p$、$l-1$、$r$）以及修改加上的值/询问的编号。如果写法正常的话你已经以操作的时间作为初始顺序了.. 然后，写个归并排序，按操作的位置排序，同一个位置的修改要放在询问的前面。然后，在归并排序的过程中，遇到左区间里的修改就更新左区间修改的总和，遇到右区间里的询问就用记录的“左区间修改的总和”更新这个询问的答案。 具体见代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;typedef long long ll;const int N=500010;struct Node&#123; int type,p,val; //type为2表示修改，type为-1表示左端点减一，type为1表示右端点 bool operator&lt;(const Node&amp; b) const &#123; return p==b.p?type&gt;b.type:p&lt;b.p; &#125;&#125; q[N&lt;&lt;2],tmp[N&lt;&lt;2];void solve(int l,int r);int n,m,tot,qtot;ll ans[N];int main()&#123; int i,op,x,y; scanf("%d%d",&amp;n,&amp;m); for (i=1;i&lt;=n;++i) //初始值视作修改 &#123; scanf("%d",&amp;x); q[++tot].type=2; q[tot].p=i; q[tot].val=x; &#125; for (i=1;i&lt;=m;++i) &#123; scanf("%d%d%d",&amp;op,&amp;x,&amp;y); if (op==1) &#123; q[++tot].type=2; q[tot].p=x; q[tot].val=y; &#125; else //询问拆成两个前缀和相减 &#123; q[++tot].type=-1; q[tot].p=x-1; q[tot].val=++qtot; q[++tot].type=1; q[tot].p=y; q[tot].val=qtot; &#125; &#125; solve(1,tot+1); for (i=1;i&lt;=qtot;++i) printf("%lld\n",ans[i]); return 0;&#125;void solve(int l,int r)&#123; if (l==r-1) return; int i,j,k,mid; ll sum=0; i=k=l; j=mid=(l+r)&gt;&gt;1; solve(l,mid); solve(mid,r); while (i&lt;mid&amp;&amp;j&lt;r) &#123; if (q[i]&lt;q[j]) &#123; if (q[i].type==2) sum+=q[i].val; //记录左区间里的修改之和 tmp[k++]=q[i++]; &#125; else &#123; if (q[j].type!=2) ans[q[j].val]+=q[j].type*sum; //将左区间里的修改应用到右区间里的询问 tmp[k++]=q[j++]; &#125; &#125; while (i&lt;mid) tmp[k++]=q[i++]; while (j&lt;r) &#123; if (q[j].type!=2) ans[q[j].val]+=q[j].type*sum; tmp[k++]=q[j++]; &#125; for (i=l;i&lt;r;++i) q[i]=tmp[i];&#125; 之前说过ex归并排序本质上是一个二维偏序限制了修改对询问的影响，所以也可以先按位置排序再按时间排序。只不过..这样写很奇怪，很麻烦，常数又大。然而为了理解ex归并排序的本质，我还是写了份这个做法.. 一种奇怪的写法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int N=500010;struct Node&#123; int type,tim,p,val; Node(int _type=0,int _tim=0,int _p=0,int _val=0):type(_type),tim(_tim),p(_p),val(_val)&#123;&#125;&#125; q[N&lt;&lt;2],tmp[N&lt;&lt;2];void solve(int l,int r);int n,m,tot,qtot;ll ans[N];int main()&#123; int i,j,op,x,y; scanf("%d%d",&amp;n,&amp;m); for (i=1;i&lt;=n;++i) &#123; scanf("%d",&amp;x); q[++tot]=Node(2,0,i,x); &#125; for (i=1;i&lt;=m;++i) &#123; scanf("%d%d%d",&amp;op,&amp;x,&amp;y); if (op==1) q[++tot]=Node(2,i,x,y); else &#123; q[++tot]=Node(-1,i,x-1,++qtot); q[++tot]=Node(1,i,y,qtot); &#125; &#125; sort(q+1,q+tot+1,[](const Node&amp; x,const Node&amp; y)&#123;return x.p==y.p?x.type&gt;y.type:x.p&lt;y.p;&#125;); solve(1,tot+1); for (i=1;i&lt;=qtot;++i) printf("%lld\n",ans[i]); return 0;&#125;void solve(int l,int r)&#123; if (l==r-1) return; int i,j,k,mid; ll sum=0; i=k=l; j=mid=(l+r)&gt;&gt;1; solve(l,mid); solve(mid,r); while (i&lt;mid&amp;&amp;j&lt;r) &#123; if (q[i].tim&lt;q[j].tim) &#123; if (q[i].type==2) sum+=q[i].val; tmp[k++]=q[i++]; &#125; else &#123; if (q[j].type!=2) ans[q[j].val]+=q[j].type*sum; tmp[k++]=q[j++]; &#125; &#125; while (i&lt;mid) tmp[k++]=q[i++]; while (j&lt;r) &#123; if (q[j].type!=2) ans[q[j].val]+=q[j].type*sum; tmp[k++]=q[j++]; &#125; for (i=l;i&lt;r;++i) q[i]=tmp[i];&#125; P3810 【模板】三维偏序（陌上花开）有两种做法，一种是cdq分治套树状数组，需要注意的有两点，一是清空树状数组可以用时间戳，二是 $a,\,b,\,c$ 都相等的元素要合并。 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int N=100010;const int K=200010;struct Node&#123; int a,b,c,w,f;&#125; a[N],b[N];void solve(int l,int r);void add(int p,int x);int query(int p);int n,k,d[N],BIT[K],vis[K],tim,tot;int main()&#123; int i; scanf("%d%d",&amp;n,&amp;k); for (i=1;i&lt;=n;++i) &#123; scanf("%d%d%d",&amp;b[i].a,&amp;b[i].b,&amp;b[i].c); b[i].w=1; &#125; sort(b+1,b+n+1,[](const Node&amp; x,const Node&amp; y)&#123;return x.a==y.a?(x.b==y.b?x.c&lt;y.c:x.b&lt;y.b):x.a&lt;y.a;&#125;); for (i=1;i&lt;=n;++i) &#123; if (b[i].a!=b[i+1].a||b[i].b!=b[i+1].b||b[i].c!=b[i+1].c) a[++tot]=b[i]; else b[i+1].w+=b[i].w; &#125; solve(1,tot+1); for (i=1;i&lt;=tot;++i) d[a[i].f+a[i].w]+=a[i].w; for (i=1;i&lt;=n;++i) printf("%d\n",d[i]); return 0;&#125;void solve(int l,int r)&#123; if (l==r-1) return; int i,j,k,mid; i=k=l; j=mid=(l+r)&gt;&gt;1; solve(l,mid); solve(mid,r); ++tim; while (i&lt;mid&amp;&amp;j&lt;r) &#123; if (a[i].b&lt;=a[j].b) &#123; add(a[i].c,a[i].w); b[k++]=a[i++]; &#125; else &#123; a[j].f+=query(a[j].c); b[k++]=a[j++]; &#125; &#125; while (i&lt;mid) b[k++]=a[i++]; while (j&lt;r) &#123; a[j].f+=query(a[j].c); b[k++]=a[j++]; &#125; for (i=l;i&lt;r;++i) a[i]=b[i];&#125;void add(int p,int x)&#123; for (;p&lt;=k;p+=(p&amp;-p)) &#123; if (vis[p]!=tim) &#123; BIT[p]=0; vis[p]=tim; &#125; BIT[p]+=x; &#125;&#125;int query(int p)&#123; int out=0; for (;p;p-=(p&amp;-p)) if (vis[p]==tim) out+=BIT[p]; return out;&#125; 还有一种做法是cdq分治套cdq分治： 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int N=100010;struct Node&#123; int a,b,c,d,w,id;&#125; a[N],b[N],c[N];void solve(int l,int r);void solve2(int l,int r);int n,k,d[N],tot,ans[N];int main()&#123; int i; scanf("%d%d",&amp;n,&amp;k); for (i=1;i&lt;=n;++i) &#123; scanf("%d%d%d",&amp;b[i].a,&amp;b[i].b,&amp;b[i].c); b[i].w=1; b[i].id=i; &#125; sort(b+1,b+n+1,[](const Node&amp; x,const Node&amp; y)&#123;return x.a==y.a?(x.b==y.b?x.c&lt;y.c:x.b&lt;y.b):x.a&lt;y.a;&#125;); for (i=1;i&lt;=n;++i) &#123; if (b[i].a!=b[i+1].a||b[i].b!=b[i+1].b||b[i].c!=b[i+1].c) a[++tot]=b[i]; else b[i+1].w+=b[i].w; &#125; solve(1,tot+1); for (i=1;i&lt;=tot;++i) d[ans[a[i].id]+a[i].w]+=a[i].w; for (i=1;i&lt;=n;++i) printf("%d\n",d[i]); return 0;&#125;void solve(int l,int r)&#123; if (l==r-1) return; int i,j,k,mid; i=k=l; j=mid=(l+r)&gt;&gt;1; solve(l,mid); solve(mid,r); while (i&lt;mid&amp;&amp;j&lt;r) &#123; if (a[i].b&lt;=a[j].b) &#123; a[i].d=a[i].w; b[k++]=a[i++]; &#125; else &#123; a[j].d=0; b[k++]=a[j++]; &#125; &#125; while (i&lt;mid) &#123; a[i].d=a[i].w; b[k++]=a[i++]; &#125; while (j&lt;r) &#123; a[j].d=0; b[k++]=a[j++]; &#125; for (i=l;i&lt;r;++i) a[i]=b[i]; solve2(l,r);&#125;void solve2(int l,int r)&#123; if (l==r-1) return; int i,j,k,mid,sum=0; i=k=l; j=mid=(l+r)&gt;&gt;1; solve2(l,mid); solve2(mid,r); while (i&lt;mid&amp;&amp;j&lt;r) &#123; if (b[i].c&lt;=b[j].c) &#123; sum+=b[i].d; c[k++]=b[i++]; &#125; else &#123; if (!b[j].d) ans[b[j].id]+=sum; c[k++]=b[j++]; &#125; &#125; while (i&lt;mid) c[k++]=b[i++]; while (j&lt;r) &#123; if (!b[j].d) ans[b[j].id]+=sum; c[k++]=b[j++]; &#125; for (i=l;i&lt;r;++i) b[i]=c[i];&#125; cdq分治求偏序对的本质（下文中“偏序问题”即求满足偏序关系的数对个数。而”高维偏序“实际上是多个严格弱序的并。非严格偏序与之类似，主要是在代码上有些细节改变。） 大家知道，二维偏序可以先按一维排序后用普通的归并排序解决，那为什么“三维偏序”不可以呢？ 首先，按其中一维排序相当于降了一维，问题就变成了“为什么一维偏序可以用普通的归并排序解决，而二维偏序不可以”。 原因就在于，两个偏序关系的并，不一定具有不可比性的传递性。（Strict Weak Ordering 相关内容参见我的另一篇博客） 可以证明，两个严格弱序的并一定是一个严格偏序，但不一定是一个严格弱序。而 cdq 分治可以将多个严格弱序的并进行降维，每一次 cdq 分治都标记出哪些位置会对其它位置有贡献，并按某一维排序。 上面说的有点乱..简单概括一下。排序可以降维，只有严格弱序能排序，高维偏序不一定是严格弱序，cdq 分治在排序的过程中标记了元素之间如何贡献答案。所以 cdq 分治就可以解决高维偏序问题了.. 所以，我们可以写出一份 cdq 分治求 $k$ 维偏序对的代码： 题意简述：第一行 $n,\,k$，后 $n$ 行每行 $k$ 个数 $a_{i,1..k}$，对每个 $i$ 求 $\forall d\in[1,k],\,a_{i,d}&lt;a_{j,d}$ 的 $j$ 个数。 当然，$n$ 要足够大，否则会被暴力艹。只不过理论上来说，如果维数是常数，复杂度就比暴力更优… 随便造的一个模板题 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;const int N=10005;const int K=15;void solve(int l,int r,int d);int n,k,ans[N];struct Node&#123; int w[K],type,id; bool operator&lt;(const Node&amp; y) const &#123; if (w[0]!=y.w[0]) return w[0]&lt;y.w[0]; for (int i=1;i&lt;k;++i) if (w[i]!=y.w[i]) return w[i]&gt;y.w[i]; //如果是非严格偏序都应该顺着排，严格偏序除了第一维都应该倒着排。这是由于相等元素可以/不可以转移。 return false; &#125;&#125; a[K][N],tmp[N];int main()&#123; int i,j; scanf("%d%d",&amp;n,&amp;k); for (i=1;i&lt;=n;++i) &#123; a[0][i].id=i; for (j=0;j&lt;k;++j) scanf("%d",a[0][i].w+j); &#125; sort(a[0]+1,a[0]+n+1); solve(1,n+1,1); for (i=1;i&lt;=n;++i) printf("%d\n",ans[i]); return 0;&#125;void solve(int l,int r,int d)&#123; if (l==r-1) return; int i,j,p,mid,sum=0; i=p=l; j=mid=(l+r)&gt;&gt;1; solve(l,mid,d); solve(mid,r,d); while (i&lt;mid&amp;&amp;j&lt;r) &#123; if (a[d-1][i].w[d]&lt;a[d-1][j].w[d]) &#123; a[d][p]=tmp[p]=a[d-1][i++]; if (d&gt;1&amp;&amp;a[d][p].type!=1) a[d][p].type=0; else &#123; a[d][p].type=1; if (d==k-1) ++sum; &#125; ++p; &#125; else &#123; a[d][p]=tmp[p]=a[d-1][j++]; if (d&gt;1&amp;&amp;a[d][p].type!=2) a[d][p].type=0; else &#123; a[d][p].type=2; if (d==k-1) ans[a[d][p].id]+=sum; &#125; ++p; &#125; &#125; while (i&lt;mid) &#123; a[d][p]=tmp[p]=a[d-1][i++]; if (d&gt;1&amp;&amp;a[d][p].type!=1) a[d][p].type=0; else a[d][p].type=1; ++p; &#125; while (j&lt;r) &#123; a[d][p]=tmp[p]=a[d-1][j++]; if (d&gt;1&amp;&amp;a[d][p].type!=2) a[d][p].type=0; else &#123; a[d][p].type=2; if (d==k-1) ans[a[d][p].id]+=sum; &#125; ++p; &#125; for (i=l;i&lt;r;++i) a[d-1][i]=tmp[i]; if (d&lt;k-1) solve(l,r,d+1);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>离线算法</tag>
        <tag>cdq分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ4259 残缺的字符串（FFT）]]></title>
    <url>%2FBZOJ4259-%E6%AE%8B%E7%BC%BA%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88FFT%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目链接洛谷 darkbzoj 题意简述带通配符的单模式串、单文本串匹配。 字符串长度 $3\times10^5$。 简要做法这题是利用字符串的距离函数来匹配字符串，使用 FFT 优化距离函数的计算。 将通配符的值设为零，定义 $dis(s,t)=\sum(s[i]-t[i])^2s[i]t[i]​$，那么两个等长的字符串匹配当且仅当它们的距离为零。 为了方便卷积，将题目中的 $A$ 串翻转​得到串 $A’​$。 推一波式子： $\begin{aligned}dis(A,B[i..i+m-1])&amp;=\sum\limits_{j=0}^{m-1}(A’[m-j-1]-B[i+j])^2A’[m-j-1]B[i+j]\\&amp;=\left(\sum\limits_{j=0}^{m-1}A’[m-j-1]B^3[i+j]\right)-2\left(\sum\limits_{j=0}^{m-1}(A’)^2[m-j-1]B^2[i+j]\right)+\left(\sum\limits_{j=0}^{m-1}(A’)^3[m-j-1]B[i+j]\right)\end{aligned}$ 设 $f(i)=\sum\limits_{j=0}^{i}A’[i-j]B^3[j]​$（即它们的卷积），将 $A’[m..n-1]​$ 设为 $0​$，那么 $\sum\limits_{j=0}^{m-1}A’[m-j-1]B^3[i+j]=f(i+m-1)​$。 可以类似地计算另外两项，就可以求出所有 $dis(A,B[i..i+m-1])​$，看看哪些等于零就好了。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N=1&lt;&lt;19;const double PI=acos(-1);struct cp&#123; double re,im; cp(double _re=0.0,double _im=0.0) &#123; re=_re; im=_im; &#125; cp operator+(const cp&amp; b) const &#123; return cp(re+b.re,im+b.im); &#125; cp operator-(const cp&amp; b) const &#123; return cp(re-b.re,im-b.im); &#125; cp operator*(const cp&amp; b) const &#123; return cp(re*b.re-im*b.im,re*b.im+im*b.re); &#125;&#125; a[N],a2[N],a3[N],b[N],b2[N],b3[N],c1[N],c2[N],c3[N];void fft(cp* A,int type);int n,m,lim,L,r[N];char s[N],t[N];vector&lt;int&gt; ans;int main()&#123; int i; scanf("%d%d%s%s",&amp;m,&amp;n,s,t); for (i=0;i&lt;n;++i) &#123; if (m-i&gt;0&amp;&amp;s[m-i-1]!='*') &#123; a[i].re=s[m-i-1]-'a'+1; a2[i].re=a[i].re*a[i].re; a3[i].re=a[i].re*a2[i].re; &#125; if (t[i]!='*') &#123; b[i].re=t[i]-'a'+1; b2[i].re=b[i].re*b[i].re; b3[i].re=b[i].re*b2[i].re; &#125; &#125; for (lim=0,L=1;L&lt;=n;++lim,L&lt;&lt;=1); for (i=1;i&lt;L;++i) r[i]=(r[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(lim-1)); fft(a,1); fft(a2,1); fft(a3,1); fft(b,1); fft(b2,1); fft(b3,1); for (i=0;i&lt;L;++i) &#123; c1[i]=a[i]*b3[i]; c2[i]=a2[i]*b2[i]; c3[i]=a3[i]*b[i]; &#125; fft(c1,-1); fft(c2,-1); fft(c3,-1); for (i=m-1;i&lt;n;++i) &#123; if (c1[i].re-2*c2[i].re+c3[i].re&lt;0.5) &#123; ans.push_back(i-m+2); &#125; &#125; printf("%d\n",int(ans.size())); for (i=0;i&lt;ans.size();++i) printf("%d ",ans[i]); return 0;&#125;void fft(cp* A,int type)&#123; int i,j,k; for (i=1;i&lt;L;++i) if (i&lt;r[i]) swap(A[i],A[r[i]]); for (i=1;i&lt;L;i&lt;&lt;=1) &#123; cp w1(cos(PI/i),type*sin(PI/i)); for (j=0;j&lt;L;j+=2*i) &#123; cp w(1,0); for (k=j;k&lt;i+j;++k,w=w*w1) &#123; cp t=A[k+i]*w; A[k+i]=A[k]-t; A[k]=A[k]+t; &#125; &#125; &#125; if (type==-1) for (i=0;i&lt;L;++i) A[i].re=A[i].re/L;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019YALI省选集训垫底记]]></title>
    <url>%2F2019YALI%E7%9C%81%E9%80%89%E9%9B%86%E8%AE%AD%E5%9E%AB%E5%BA%95%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[时隔半年又来到了YALI。 Day 0中午放学，下午就坐火车走了。 晚上被骗去吃火宫殿.. 然后做了一个 slide. Day 1T1是个字符串，一开始以为可以 $50$，先把 $30$ 写了然后去看后两题，回来发现那 $20$ 没法写..最后因为数组名 $end$ CE了.. T2还是个字符串，只不过是在图上，是道大象题，求期望，要高斯消元，利用非 $0​$ 项很少来降低复杂度。一开始先把不用求期望（每个点出度为 $1​$）的 $20​$ 分写了，然后就去看 $T3​$。后来回头发现 $T1​$ 的 $20​$ 写不出来，就来写这题的 $10​$ 分暴力高斯消元，然后调了 $1h​$，一开始先是概率各种算错，后来其它的都写对了，结果我脑抽写成了字符串失配跳到 $0​$ … T3是zzq最爱的提答，又是给一种计算机。随便玩了 $47​$ 分。下午讲题的时候有几位神仙在那快乐地碾了碾标算.. 做题的时候先是看到 ctr zzq，然后往右一看，发现 zzq 就在黑板前的电脑前坐着..之前就听说 _rqy 也要来，做题做到一半的时候看到 _rqy 去找 zzq 报告了两个 bug.. 之前就有猜测过： 然后..下午果然是神仙聊天场，_rqy 现场推多项式三角函数.. 晚上没去机房..游记就是晚上写的qaq Day 2今天有三种类型的题目，性价比高。 T1 是道图论交互，只会暴力 $20$.. T2 是道图论传统题，一开始以为直接欧拉回路就是正解，然后随便一拍就挂了..后来得知欧拉回路是正解的一部分。 T3 是道扫雷提答，暴力跑了 $4​$ 个点，构造了两个点，下午的时候手玩了一个点..是除了周围雷数还有行/列之和，行/列连续段个数之类的那种。 下午讲题的时候竟然有人讲美樱的颜料..个人认为那题出的不是很好..尤其是Sooke为卡loglogn设的空间限制.. Day 3今天是讲题..感觉全场可能就我不会生成函数，只不过感觉好像大概弄明白了。 晚上把讲题咕咕了，结果不小心错过了 _rqy 的难题选讲.. Day 4T1 是个数据结构，看了看觉得有 $41$ 分非常可做，先写了个暴力去肝后面两题，最后回来写这题，很快写完了 $30$ 分，然后把 $30$ 分备份了一下去写剩下的 $11$ 分，写的过程中发现 $30$ 分有个地方挂了，就在 $41$ 分代码里面改过来了，后来剩下 $11$ 分没写完，就把备份（没修改那个地方）的代码交上去了..最后连询问数为 $0$ 的 subtask 都挂了，只有 $22$ 分。 T2 是道小清新0.5KB找规律题。成功找到规律然后 A 掉了.. T3 是俄罗斯方块提答..搞了三个点，剩下的随机..获得了 $16$ 分的好成绩。之后 _rqy 说自己写了个模拟器手玩，于是我下午就自己写了个模拟器手玩..草，真的又好写又好玩，$1h$ 十几分绝对没问题.. Day 5今天大众分 $200$..窝愉快垫底了。 T1 是个数据结构，定义数列中每个数的后继为它后面比它大的第一个数，区间询问跳到后继最多能跳多少步。暴力 $30$ 分滚粗。 T2 是个树交互，还比较简单吧..然而 std 做法看起来就很麻烦，所以没仔细听具体是怎么做的。 T3 是道 MO 题，全场只有暴力 $15$ 和爆零..然后我考场上愉快地调了 $2h​$ 暴力，RETLEWA……最后还是没调出来。 Day 6今天又是讲题..晚上轮到我难题讨论，讲了下早就被我讲烂了的皇后游戏&amp;由乃大母神原型与偶像崇拜。 Day 7T1 是一个树上的神仙题..把暴力 $68$ 分打满了（$n^2$&amp;链&amp;菊花）。考场上写完菊花之后去看 T2，T3，然后放在那对拍，错了五六次才调对.. T2 是个神仙博弈论，只写了暴力 $17$ 分.. T3 是个神仙交互，用随机化搞到了 $66$ 分（期望得分 $67$，脸黑被卡到了 $66.99$），然而没有发现把 subtask3 的代码复制到 subtask4 后面就可以轻松获得 $60\%$ subtask5 的分数.. 这场虽然没 A 题，然而好像是我得分最高的一场？ Day 8T1指令集RE了..只不过写了数据分治还有暴力分。本地比正解跑的还快qaq..ylh用 $\mathcal O(n\sqrt n\log n)$ 艹过去了 Orz. T2暴力。 T3暴力被卡常了。 垫底..分最低的一次。 Day 9讲课，颓。 Day 10T1暴力，ylh的暴力偏序被卡了。 T2会求答案不会求方案，结果下午才知道大家都会求答案.. T3暴力，不会类欧自闭了。 Day 11和第二天互换了，讲课，继续春眠zzz.. Day 12今天 T1 是五子棋互打，想着今天是最后一天，于是就真的写了整场（$3.5h$）的 T1。一开始写了个爆搜，后来发现很蠢，于是就算了个估价函数，然后感觉很对。然而 ctr 乱测..之后我把 ctr 测出来的前 $21$ 名测了一下，和 ctr 测出来的差别还挺大的..只不过我好像在执黑/执白的情况下都打过了其它人写的AI..然而被 ylh（人）击败了.. T2 题面掉了个关键条件，于是不会做..花 $20min$ 写了 $35$ 分。 T3 觉得部分分写起来很麻烦，于是最后半个多小时就一直在看自己的 AI 和自己的 AI 下棋.. 总结要是省选没有非传统题就要凉凉的感觉…]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>集训</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3622 已经没有什么好害怕的了（二项式反演，组合数学）]]></title>
    <url>%2FBZOJ3622-%E5%B7%B2%E7%BB%8F%E6%B2%A1%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%AE%B3%E6%80%95%E7%9A%84%E4%BA%86%EF%BC%88%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%8F%8D%E6%BC%94%EF%BC%8C%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目链接洛谷 darkbzoj 题意简述给你两个长为 $n$ 、无重复元素的数列 $a,b$，求将 $b$ 重排后 $\left(\sum\limits_{i=1}^n[a_i&gt;b_i]\right)-\left(\sum\limits_{i=1}^n[a_i&lt;b_i]\right)=k$（$k$ 给定）的方案数。 $n\le2000$。 简要做法首先，$a$ 大于 $b$ 比 $b$ 大于 $a$ 多 $k$ 对可以转化为 $a$ 大于 $b$ 有 $\frac{n+k}2$ 对。 考虑 $dp​$，设 $f(i,j)​$ 为 $a_{1..i}​$ 中选 $j​$ 个数，给这 $j​$ 个数每个数匹配一个小于它的 $b​$ 的方案数。为方便转移，一开始要先对 $a,b​$ 分别从小到大排序，这样的话若 $a_i&gt;b_j​$，必然有 $a_{i+1}&gt;b_j​$。 设比 $a_i$ 大的 $b$ 有 $cnt_i$ 个，转移方程就是 $f(i,j)=f(i-1,j)+(cnt_i-j+1)\times f(i-1,j-1)$。$cnt_i$ 可以二分查找/双指针计算。 考虑这样一个式子：$f(n,i)\times(n-i)!$，它的意义是，先从 $a$ 中选 $i$ 个数，给它们分别匹配一个小于它们的 $b$，再把剩下的 $n-i$ 个数随意匹配。这个式子并不是某种“方案数”，因为它可能会将相同的匹配方案算重。事实上，对于每种恰有 $j$ 对 $a&gt;b$ 的匹配方案，它在 $f(n,i)\times(n-i)!$ 中被计算了 $\binom{j}{i}$ 次。令 $ans_i$ 表示恰好有 $i$ 对 $a$ 大于 $b$ 的方案数，就有 $ans_i=f(n,i)\times(n-i)!-\sum\limits_{j=i+1}^n\binom{j}{i}ans_j$。这样的话，就可以递推地计算答案。 这题还有另一种做法，叫二项式反演。我自己没有太理解清楚这种方法，所以不详细阐述。这种做法可以 $O(n)​$ 地计算某个 $ans_i​$，但不影响总复杂度（$dp​$ 还是 $O(n^2)​$ 的）： $$ans_i=\sum\limits_{j=i}^n(-1)^{j-i}\binom j i f(n,j)\times(n-j)​$$ 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int N=2010;const int mod=1e9+9;int qpow(int x,int y);int n,k,a[N],b[N],f[N][N],ans[N],c[N][N],fac[N];int main()&#123; int i,j,cnt=0; cin&gt;&gt;n&gt;&gt;k; if ((n&amp;1)!=(k&amp;1)) &#123; cout&lt;&lt;0; return 0; &#125; k=(n+k)/2; for (i=1;i&lt;=n;++i) scanf("%d",a+i); for (i=1;i&lt;=n;++i) scanf("%d",b+i); sort(a+1,a+n+1); sort(b+1,b+n+1); fac[0]=1; for (i=1;i&lt;=n;++i) fac[i]=(ll)fac[i-1]*i%mod; c[0][0]=1; for (i=1;i&lt;=n;++i) &#123; c[i][0]=1; for (j=1;j&lt;=i;++j) c[i][j]=(c[i-1][j-1]+c[i-1][j])%mod; &#125; f[0][0]=1; for (i=1;i&lt;=n;++i) &#123; f[i][0]=1; while (cnt&lt;n&amp;&amp;b[cnt+1]&lt;a[i]) ++cnt; for (j=1;j&lt;=cnt;++j) &#123; f[i][j]=(f[i-1][j]+(ll)f[i-1][j-1]*(cnt-j+1))%mod; &#125; &#125; for (i=n;i&gt;=k;--i) &#123; ans[i]=(ll)f[n][i]*fac[n-i]%mod; for (j=n;j&gt;i;--j) ans[i]=(ans[i]+mod-(ll)ans[j]*c[j][i]%mod)%mod; &#125; cout&lt;&lt;ans[k]; return 0;&#125;int qpow(int x,int y)&#123; int out=1; while (y) &#123; if (y&amp;1) out=(ll)out*x%mod; x=(ll)x*x%mod; y&gt;&gt;=1; &#125; return out;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>二项式反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ4665 小w的喜糖（容斥原理，组合数学）]]></title>
    <url>%2FBZOJ4665-%E5%B0%8Fw%E7%9A%84%E5%96%9C%E7%B3%96%EF%BC%88%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86%EF%BC%8C%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目链接darkbzoj 题意简述给你一个数列，求重排后每个位置都变了的方案数。 数列长度和值域都是 $2000$。 简要做法考虑容斥，计 $g(S)​$ 为 $S​$ 这个集合内的所有位置都不变的方案数，$U​$ 为位置的全集（即 $1​$ ~ $n​$），$i​$ 这个数出现了 $cnt[i]​$ 次，答案即为 $\frac{n!}{\prod\limits_{i=1}^ncnt[i]!}+\sum\limits_{S\subseteq U,S\ne\varnothing}(-1)^{|S|}g(S)​$。 计 $P_i$ 为 $i$ 这个数出现的位置集合，那么 $g(S)=\frac{(n-|S|)!\prod\limits_{i=1}^n\frac{cnt[i]!}{(cnt[i]-|P_i\bigcap S|)!}}{\prod\limits_{i=1}^ncnt[i]!}​$。 暴力枚举子集肯定是过不了的，考虑如何优化。 容斥原理的优化一般是将答案相同/结构相似的部分合在一起算，这题中，可以尝试将 $|S|$ 相同的集合合在一起算，问题就在于如何快速计算 $|S|$ 相同的所有 $\prod\limits_{i=1}^n\frac{cnt[i]!}{(cnt[i]-|P_i\bigcap S|)!}$ 之和。 这个东西可以用 $dp$ 解决：设 $f(i,j)$ 为从值为 $1$ ~ $i$ 的所有数中选 $j$ 个数的所有不同方案的贡献之和，其中，一种选法的贡献就是将选的数作为 $S$ 的 $\prod\limits_{i=1}^n\frac{cnt[i]!}{(cnt[i]-|P_i\bigcap S|)!}$。转移时枚举值为 $i$ 的数选了 $k$ 个，那么 $f(i,j)=\sum\limits_{k=0}^{\min(j,cnt[i])}\frac{cnt[i]!}{(cnt[i]-k)!}\binom{cnt[i]}kf(i-1,j-k)$. 由于 $cnt[i]$ 之和为 $n$，$dp$ 复杂度是 $O(n^2)$。 这样的话，最终的答案就是 $\frac{n!+\sum\limits_{i=1}^n(-1)^i(n-i)!f(n,i)}{\prod\limits_{i=1}^ncnt[i]!}$，实际上 $f(n,0)=1$，所以也可以化简为 $\frac{\sum\limits_{i=0}^n(-1)^i(n-i)!f(n,i)}{\prod\limits_{i=1}^ncnt[i]!}$. 参考代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;typedef long long ll;const int N=2010;const int mod=1e9+9;int qpow(int x,int y);int n,cnt[N],fac[N],inv[N],f[N][N],c[N][N],ans;int main()&#123; int i,j,k,x; cin&gt;&gt;n; fac[0]=inv[0]=1; for (i=1;i&lt;=n;++i) &#123; cin&gt;&gt;x; ++cnt[x]; fac[i]=(ll)fac[i-1]*i%mod; inv[i]=qpow(fac[i],mod-2); &#125; c[0][0]=1; for (i=1;i&lt;=n;++i) &#123; c[i][0]=1; for (j=1;j&lt;=i;++j) c[i][j]=(c[i-1][j-1]+c[i-1][j])%mod; &#125; f[0][0]=1; for (i=1;i&lt;=n;++i) &#123; for (j=0;j&lt;=n;++j) &#123; for (k=0;k&lt;=cnt[i]&amp;&amp;k&lt;=j;++k) &#123; f[i][j]=(f[i][j]+(ll)fac[cnt[i]]*inv[cnt[i]-k]%mod*f[i-1][j-k]%mod*c[cnt[i]][k])%mod; &#125; &#125; &#125; for (i=0;i&lt;=n;++i) ans=(ans+(ll)(i&amp;1?-1:1)*fac[n-i]*f[n][i]+mod)%mod; for (i=1;i&lt;=n;++i) ans=(ll)ans*inv[cnt[i]]%mod; cout&lt;&lt;ans; return 0;&#125;int qpow(int x,int y)&#123; int out=1; while (y) &#123; if (y&amp;1) out=(ll)out*x%mod; x=(ll)x*x%mod; y&gt;&gt;=1; &#125; return out;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ4003 [JLOI2015]城池攻占（左偏树）]]></title>
    <url>%2FBZOJ4003-JLOI2015-%E5%9F%8E%E6%B1%A0%E6%94%BB%E5%8D%A0%EF%BC%88%E5%B7%A6%E5%81%8F%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目链接洛谷 darkbzoj 题意简述给你一棵树，每个节点有 $h$ 值，一个勇士来到一个节点时如果他的战斗力大于等于 $h$ 就能占领城池并前往这个节点的父亲（除非已经到了根节点），否则阵亡；攻占一个节点后，勇士的战斗力会加/减/乘一个正整数（根据节点而定）；每个勇士有初始战斗力和想占领的第一个节点。问，每个节点各有多少个勇士阵亡，每个勇士各占领了几个节点。 简要做法每个节点搞个小根可并堆维护该节点所有勇士（包括一开始就在这的和爬上来的），当堆顶小于 $h$ 时弹出并更新答案，直到堆为空或者堆顶大于等于 $h$，然后再加/减/乘，合并到父亲。 加/减/乘：更新堆顶并打标记，在所有需要访问儿子的地方（弹出堆顶时/合并时）下传标记。 合并复杂度：每个勇士初始位置需要合并一次，每个节点合并到父亲要一次，$O((n+m)\log m)$；弹出复杂度：每个勇士最多被弹出一次，$O(m\log m)$；修改复杂度：除了下传标记外每次修改都是 $O(1)$ 的，所以是 $O(n)$；总复杂度：$O((n+m)\log m)$。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;ll read()&#123; ll out=0; int f=1; char c; for (c=getchar();!isdigit(c)&amp;&amp;c!='-';c=getchar()); if (c=='-') f=-1,c=getchar(); for (;isdigit(c);c=getchar()) out=out*10+c-'0'; return out*f;&#125;const int N=300010;struct Node&#123; int ls,rs,d; ll val,add,mul; Node()&#123;ls=rs=add=0;d=mul=1;&#125;&#125; t[N];int merge(int x,int y);int pop(int x);void madd(int u,ll x);void mmul(int u,ll x);void pushdown(int x);void add(int u,int v);void dfs(int u);int head[N],nxt[N],to[N],cnt;int n,m,p[N],f[N],a[N],dep[N],c[N],ans1[N],ans2[N];ll h[N],b[N];int main()&#123; int i; n=read(); m=read(); for (i=1;i&lt;=n;++i) h[i]=read(); for (i=2;i&lt;=n;++i) &#123; f[i]=read(); add(f[i],i); a[i]=read(); b[i]=read(); &#125; for (i=1;i&lt;=m;++i) &#123; t[i].val=read(); c[i]=read(); p[c[i]]=merge(i,p[c[i]]); &#125; dfs(1); for (i=1;i&lt;=n;++i) printf("%d\n",ans1[i]); for (i=1;i&lt;=m;++i) printf("%d\n",ans2[i]); return 0;&#125;void dfs(int u)&#123; int i,v; for (i=head[u];i;i=nxt[i]) &#123; v=to[i]; dep[v]=dep[u]+1; dfs(v); &#125; while (p[u]&amp;&amp;t[p[u]].val&lt;h[u]) &#123; ++ans1[u]; ans2[p[u]]=dep[c[p[u]]]-dep[u]; p[u]=pop(p[u]); &#125; if (a[u]) mmul(p[u],b[u]); else madd(p[u],b[u]); if (u&gt;1) p[f[u]]=merge(p[u],p[f[u]]); else while (p[u]) &#123; ans2[p[u]]=dep[c[p[u]]]+1; p[u]=pop(p[u]); &#125;&#125;void add(int u,int v)&#123; nxt[++cnt]=head[u]; head[u]=cnt; to[cnt]=v;&#125;int merge(int x,int y)&#123; if (!x||!y) return x|y; if (t[x].val&gt;t[y].val) swap(x,y); pushdown(x); t[x].rs=merge(t[x].rs,y); if (t[t[x].rs].d&gt;t[t[x].ls].d) swap(t[x].ls,t[x].rs); t[x].d=t[t[x].rs].d+1; return x;&#125;int pop(int x)&#123; pushdown(x); return merge(t[x].ls,t[x].rs);&#125;void madd(int u,ll x)&#123; t[u].val+=x; t[u].add+=x;&#125;void mmul(int u,ll x)&#123; t[u].val*=x; t[u].add*=x; t[u].mul*=x;&#125;void pushdown(int x)&#123; mmul(t[x].ls,t[x].mul); madd(t[x].ls,t[x].add); mmul(t[x].rs,t[x].mul); madd(t[x].rs,t[x].add); t[x].add=0; t[x].mul=1;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>左偏树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF235C Cyclical Quest（SAM）]]></title>
    <url>%2FCF235C-Cyclical-Quest%EF%BC%88SAM%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目链接洛谷 CF problemset CF contest 题意简述给你一个字符串 $s$ 和 $n$ 个字符串 $x_{1..n}$，对每个 $x_i$，求有多少个 $s$ 的子串可以由 $x_i$ 旋转得到。 旋转一个字符串就是把它的一个前缀移到后面，如 abcd 可以旋转得到的字符串有 abcd，bcda，cdab，dabc。 简要做法对 $s$ 建 SAM，把 $x_i$ 旋转得到的每个字符串用 SAM 读入，就可以求答案了。（SAM 求子串出现次数是经典问题，可以参考我的博客） 分开读入每个 $x_i$ 旋转得到的字符串显然会超时，然而，SAM 读入字符串是支持删除首字符的：记录当前读入的长度 $l$ 以及所处状态 $u$，删除字符就把 $l$ 减一，若减一后 $l=len(parent(u))$，则转移到 $parent(u)$（把 $u$ 赋值为 $parent(t)$）。需要注意的是，如果读入一个字符的时候当前状态没有这个字符的出边，就需要在 $parent$ 树上向上跳，直到有这个字符的出边，同时更新 $l$ 。这样的话，删除字符前就要先判断 $l$ 与需要保留的字符串的长度的关系。具体细节可以参考代码及注释。 所以，先读入 $x_i$ 统计答案，再删去首字符读入 $x_i[0]$ 统计答案，删去首字符读入 $x_i[1]$ 统计答案……就只用读入 $O(len(x_i))​$ 个字符。 还有一个问题，就是去重。$s$ 的一个子串可能可以和 $x_i$ 不同的旋转匹配。解决这个问题有两个方法，第一个是求出 $x_i​$ 的周期（可以用 kmp 求），第二个方法是在 SAM 上打标记。我用的是打标记的方法，具体细节还是可以参考代码及注释。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;const int N=1000010;struct Node&#123; int len,par,ch[26],vis,cnt;&#125; sam[N&lt;&lt;1];void insert(int x);void read(int x);void del();void calc();void add(int u,int v);void dfs(int u);char s[N];int head[N&lt;&lt;1],nxt[N&lt;&lt;1],to[N&lt;&lt;1],cnt;int p,tot,n,m,l,u,tim,ans;int main()&#123; int i; scanf("%s%d",s,&amp;n); sam[0].par=-1; for (i=0;s[i];++i) insert(s[i]-'a'); for (i=1;i&lt;=tot;++i) add(sam[i].par,i); dfs(0); for (tim=1;tim&lt;=n;++tim) &#123; scanf("%s",s); m=strlen(s); ans=u=l=0; for (i=0;i&lt;m;++i) read(s[i]-'a'); calc(); for (i=0;i&lt;m-1;++i) &#123; read(s[i]-'a'); del(); calc(); &#125; printf("%d\n",ans); &#125; return 0;&#125;void read(int x) //读入一个字符&#123; while (u&amp;&amp;!sam[u].ch[x]) l=sam[u=sam[u].par].len; //向上跳直至有这个字符的出边 if (sam[u].ch[x]) &#123; ++l; u=sam[u].ch[x]; &#125;&#125;void del() //删除首字符&#123; if (l&gt;m&amp;&amp;--l==sam[sam[u].par].len) u=sam[u].par; //m表示当前xi的长度，只有l&gt;m的时候才删除&#125;void calc() //计算当前的答案&#123; if (l==m&amp;&amp;sam[u].vis&lt;tim) //只有当前读入的串长度恰好为m且当前状态没有打上标记时才统计答案 &#123; ans+=sam[u].cnt; sam[u].vis=tim; //打标记 &#125;&#125;void insert(int x) //向SAM中插入字符，有人把这个函数叫做extend&#123; int np=++tot; sam[np].len=sam[p].len+1; sam[np].cnt=1; while (~p&amp;&amp;!sam[p].ch[x]) &#123; sam[p].ch[x]=np; p=sam[p].par; &#125; if (p==-1) sam[np].par=0; else &#123; int q=sam[p].ch[x]; if (sam[q].len==sam[p].len+1) sam[np].par=q; else &#123; int nq=++tot; sam[nq].len=sam[p].len+1; memcpy(sam[nq].ch,sam[q].ch,sizeof(sam[q].ch)); sam[nq].par=sam[q].par; sam[q].par=sam[np].par=nq; while (~p&amp;&amp;sam[p].ch[x]==q) &#123; sam[p].ch[x]=nq; p=sam[p].par; &#125; &#125; &#125; p=np;&#125;void add(int u,int v) //加边，用于遍历parent树&#123; nxt[++cnt]=head[u]; head[u]=cnt; to[cnt]=v;&#125;void dfs(int u) //遍历parent树，计算每个状态的出现次数&#123; int i,v; for (i=head[u];i;i=nxt[i]) &#123; v=to[i]; dfs(v); sam[u].cnt+=sam[v].cnt; &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>SAM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[后缀自动机（SAM）学习笔记]]></title>
    <url>%2F%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA%EF%BC%88SAM%EF%BC%89%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[后缀自动机是一种处理字符串问题的有力工具（废话），它的码量不比后缀数组大（实际代码难度不比后缀数组小，但也不难），处理问题时的思维难度往往比后缀数组小，复杂度更优秀。若字符集大小为 $|\Sigma|$，则：构建时间复杂度 $O(n|\Sigma|)$，转移时间复杂度 $O(1)$，空间复杂度 $O(n|\Sigma|)$ 或 构建时间复杂度 $O(n\log|\Sigma|)$，转移时间复杂度 $O(\log|\Sigma|)$，空间复杂度 $O(n)$。 这篇文章会按我的理解详细地介绍一下 SAM，是否比其它教程更好懂我就不做评论了（毕竟所有人都认为自己的教程最好懂），只不过我会尽量保证教程的严谨性和正确性，同时尽量简洁（简洁地表达所有内容，而不是有选择地删去内容）。这篇写的比较口胡随意..拉低了我写的教程的平均水平..只不过还是比市面上某些博客要强一些的（吧）。 这篇文章最大的特点..大约是讲了一些关于将自动机的状态数压缩至最少的方法。 确定有限状态自动机（DFA）一个确定有限状态自动机（DFA）由以下五部分构成： 字符集（$\Sigma$），该自动机只能输入这些字符。 状态集合（$Q$）。如果把一个DFA看成一张有向无环图（DAG），那么DFA中的状态就相当于图上的顶点。 起始状态（$start$），$start\in Q$，是一个特殊的状态。起始状态一般用 $s$ 表示，为了避免混淆，本文中使用 $start$。 接受状态集合（$F$），$F\subseteq Q$，是一堆特殊的状态。 转移函数（$\delta$），$\delta$ 是一个接受两个参数返回一个值的函数，其中第一个参数和返回值都是一个状态，第二个参数是字符集中的一个字符。如果把一个DFA看成一张有向无环图（DAG），那么DFA中的转移函数就相当于顶点间的边，而每条边上都有一个字符。 DFA的作用就是识别字符串，一个自动机 $A$，若它能识别（接受）字符串 $S$，那么 $A(S)=True$，否则 $A(S)=False$。 当一个DFA读入一个字符串时，从初始状态起按照转移函数一个一个字符地转移。如果读入完一个字符串的所有字符后位于一个接受状态，那么我们称这个DFA接受这个字符串，反之我们称这个DFA不接受这个字符串。 如果一个状态 $v$ 没有字符 $c$ 的转移，那么我们令 $\delta(v,c)=null$，而 $null$ 只能转移到 $null$，且 $null$ 不属于接受状态集合。无法转移到任何一个接受状态的状态都可以视作 $null$，或者说，$null​$ 代指所有无法转移到任何一个接受状态的状态。 我们扩展定义转移函数 $\delta​$，令其第二个参数可以接收一个字符串：$\delta(v,s)=\delta(\delta(v,s[0]),s[1..n-1])​$（$n​$ 表示 $s​$ 的长度），这个扩展后的转移函数就可以表示从一个状态起接收一个字符串后转移到的状态。那么，$A(s)=[\delta(start,s)\in F]​$。 如，一个接受且仅接受字符串 $a,ab,aac$ 的 DFA： 后缀自动机（SAM）定义一个字符串的后缀自动机（SAM）就是一个接受且仅接受这个字符串的所有后缀的DFA。 下文中以 $SAM_s$ 代指字符串 $s$ 的后缀自动机，$\delta_s$ 代指 $SAM_s$ 的转移函数。若不带下标则表示字符串为母串 $s$（需要构建SAM的那个字符串）。 根据定义，一个字符串 $t​$ 是一个字符串 $s​$ 的后缀，当且仅当 $SAM_s(t)=True​$。 性质一个字符串 $t$ 是一个字符串 $s$ 的子串，当且仅当 $\delta_s(start_s,t)\neq null$。 因为，若 $t$ 是 $s$ 的子串，则在 $t$ 之后添加字符可能成为 $s$ 的一个后缀，反之不可能。 一个朴素的SAM若我们将一个字符串的所有后缀插入到一个字典树（trie树）中，并将每次插入的终止节点标记为接受状态，就可以得到一个状态数为 $O(n^2)​$ 的SAM。 如，串 $abaaabaa$ 的一个朴素SAM： 最简SAM上文中的“朴素SAM”状态数是 $O(n^2)$ 的，而最简SAM的状态数和转移数（点数和边数）都是 $O(n)$ 的。 $right$ 集合对于一个字符串 $t$，若它在 $s$ 中出现的位置集合为：$\{[l_1,r_1),[l_2,r_2),\cdots,[l_n,r_n)\}$（下标从 $0$ 开始），那么定义 $right(t)$ 为 $\{r_1,r_2,\cdots,r_n\}$。 如，又是串 $abaaabaa​$，那么 $right(a)=\{1,3,4,5,7,8\}​$，$right(aa)=\{4,5,8\}​$，$right(aab)=\{6\}​$。 在有的教程中，也称其为 $endpos$ 集合。 $right$ 集合等价类$right$ 集合等价类的定义$right$ 集合相等的字符串组成一个 $right$ 集合等价类。 如，双是串 $abaaabaa$，那么 $right$ 集合为 $\{4,8\}$ 的字符串有 $\{abaa,baa\}$，这两个字符串组成一个 $right$ 集合等价类。 $right$ 集合等价类与最简SAM我们定义 $reg(v)$ 表示从状态 $v$ 开始能识别的字符串的集合。即：$t\in reg(v)$ 当且仅当 $\delta(v,t)\in F$（$F$ 为接受状态集合）。 如果在 $t$ 的后面补上一个字符串 $s[r_i..n]$（$r_i\in right(t)$，$n$ 表示 $s$ 的长度），就得到了 $s$ 的一个后缀。所以，若 $right(t_1)=right(t_2)$，那么 $reg(SAM(t_1))=reg(SAM(t_2))=\{s[r_i..n]|r_i\in right(t_1)\}$。 对于每个状态 $v$，我们只关心 $reg(v)$，所以可以用SAM上的每一个状态去表示一个 $right$ 集合等价类，转移函数也相应地更改为对应的等价类（令 $f(v)$ 表示原状态 $v$ 对应的字符串的 $right$ 集合等价类在最简SAM中对应的状态，那么原来的转移函数 $\delta(u,c)=v$ 更改为 $\delta’(f(u),c)=f(v)$。可以证明，若 $right(u_1)=right(u_2)$，那么 $right(\delta(u_1,c))=right(\delta(u_2,c))$，因为 $right(\delta(u,c))=\{r_i|r_i\in right(u),s[r_i]=c\}$）。 这样的SAM是状态数最少的，因为状态的 $reg​$ 两两不同。这样的SAM若要和朴素SAM区分，可以叫做最简SAM。但一般不加说明的SAM都指最简SAM。 这样的SAM，从起始状态到某个状态可能有多条路径，每条路径都对应一个字符串，那么我们称这个状态对应着这些字符串。 如，叒是串 $abaaabaa​$ 的最简SAM： $right$ 集合等价类的性质对于每个状态 $v$，定义 $max(v)$ 和 $min(v)$ 分别表示这个状态对应的 最长 和 最短 的字符串。 那么，$v$ 对应的任意一个字符串都是 $max(v)$ 的后缀，且不是 $min(v)$ 的真后缀。并且，$v​$ 包含了所有这样的字符串。 第一点（$v$ 中的任意一个字符串都是 $max(v)$ 的后缀）可以由 $right$ 集合的定义得到。 第二点（且不是 $min(v)$ 的真后缀）可以由 $min(v)$ 的定义得到。 第三点（$v$ 包含了所有这样的字符串）可以由一个引理证明：对于一个字符串 $t$ ，它的 $right$ 集合是它的任意一个后缀的 $right$ 集合的子集。这个引理很好证明，进而可以证明这条性质。 如，叕是串 $abaaabaa$，$right$ 集合为 $\{6\}$ 的串有 $\{aab,aaab,baaab,abaaab\}$，若这个 $right$ 集合等价类对应状态 $v$，那么 $max(v)=abaaab$，$min(v)=aab$。 这条性质说明 $aaab$ 和 $baaab$ 都属于这个 $right$ 集合等价类，且 $ab$ 和 $b$ 不属于这个 $right$ 集合等价类。 证明第三点所用的引理说明，$right(aaab)\subseteq right(aab)\subseteq right(ab)\subseteq right(b)$，也就是 $\{6\}\subseteq\{6\}\subseteq\{2,6\}\subseteq\{2,6\}$ 。 $parent$$parent$ 的定义$parent​$ 有两种等价的定义（你也可以把其一视作定义，另一个视作性质）： 定义一对于每个状态 $v$（除了起始状态），找到最长的一个字符串 $t$ 所对应的状态，使得 $right(v)\subsetneq right(t)$（注意是真子集；如果不存在这样的字符串就找起始状态），这样的状态就是 $parent(v)​$。 定义二对于每个状态 $v$（除了起始状态），$min(v)[1..n-1]$ 对应的状态（$n$ 表示 $min(v)$ 的长度，假定空串对应起始状态）就是 $parent(v)$。 有的教程中把 $parent$ 叫做后缀连接 $link$。 $parent$ 的性质$len(min(v))=len(max(parent(v)))+1$，这个可以由定义二说明。 $parent$ 树$parent​$ 连接可以构成一棵树。 由定义一，由 $right$ 集合要么包含要么不相交可以说明。$parent$ 树可以看成 $right​$ 集合的包含关系所构成的树。 由定义一或定义二，由除起始状态外的状态都有且仅有一条出边并且 $parent$ 连接无环（$right$ 集合大小递增/对应字符串长度递减）可以说明。 如，醊是串 $abaaabaa$，它的 $parent$ 树：（用 $max(v)$ 代表每个状态） SAM上的接受状态就是包含 $r_i=n$（字符串长度）的一些 $right$ 集合等价类，也就是 $parent$ 树上 $\{n\}$ 对应的状态及其祖先。因此，可以通过 $parent$ 树确定SAM的接受状态集合。 最简SAM状态数为线性的证明其实由后面的线性构造方法可以说明状态数为线性。 只不过由SAM本身的性质也可以说明。 考虑 $parent​$ 树，最多有 $n​$ 个叶子节点，而每个非叶子节点至少有两个儿子，类似线段树/堆的节点数，可以证明总节点数不超过 $2n-1​$。 最简SAM转移数为线性的证明考虑SAM的任意一个生成树，那么SAM上的边就会被分成树边和非树边。 树边最多只有 $2n-2​$ 条。 对于字符串的每个后缀，将其输入到SAM中都会经过一条终点为接受状态的路径，若经过了一条非树边，则称该后缀对应它经过的第一条非树边。 对于每条非树边 $(a,b)​$，一定存在一条从起始状态到 $a​$ 的不经过任何非树边的路径（因为树上两点间必定有路径），也一定存在一条从 $b​$ 到任意一个接受状态的路径（否则 $b=null​$），所以，至少有一个后缀对应着这条非树边。 因此，非树边数量不会超过后缀数量。总的边数就是 $O(n)​$ 的。 最简SAM的线性构造SAM的线性构造可以在均摊 $O(1)$ 的时间复杂度内向SAM增加一个字符（从 $SAM_{s[0..i-1]}$ 变成 $SAM_{s[0..i]}$）。 向SAM增加一个字符，就是在所有接受状态后增加一个字符。所以，我们需要考虑上一次插入时的最后一个状态（$last​$）以及它在 ​$parent​$ 树上的祖先（也就是所有接受状态）。 加入一个字符 $x​$ 时，我们先创建一个新状态 $np​$，这个状态刚插入时代表 $right​$ 集合 $\{i\}​$（$i​$ 表示这是插入的第 $i​$ 个字符）。 一个引理：若一个状态有字符 $c$ 的转移，则它在 $parent$ 树上的祖先都有。 引理的证明：$right(\delta(v,c))=\{r_i|r_i\in right(v),s[r_i]=c\}$，而 $right(v)\subsetneq right(parent(v))$。 因此，找到 $last​$ 最深的有出边 $x​$ 的祖先 $p​$ 后，在其之上的祖先都有出边 $x​$。 对于在其之下的状态，直接向 $np​$ 连边即可。 接下来要分三种情况讨论： 若不存在 $p​$（起始状态都没有出边 $x​$），则将 $parent(np)​$ 设为初始状态。 否则，令 $len(v)$ 表示 $max(v)$ 的长度，$q$ 表示 $\delta(p,x)$。 若 $len(q)=len(p)+1$，将 $parent(np)$ 设为 $q$ 即可。 否则，新建状态 $nq$，$len(nq)$ 设为（实际上不是人为设定，它本来就是）$len(p)+1$，将 $q$ 的转移函数复制到 $nq$，然后将 $parent(nq)$ 设为 $parent(q)$，再将 $parent(q)$ 和 $parent(np)$ 都设为 $nq$，最后把 $p$ 及 $p$ 的祖先中所有出边 $x$ 连到 $q$ 的都改为连到 $nq$。实际上，枚举祖先时只要遇到出边 $x$ 不连到 $q$ 的就可以停止枚举了。 至于为什么这样做..恕我表达能力有限，还请参考陈立杰WC课件第 $35$ 页。 可以看出，当整个字符串的SAM构建好时，插入每个字符时只会进行常数次 $parent$ 修改，剩下的操作都是新建状态/连边，所以总复杂度和状态数、转移数一样，都是 $O(n)$。然而，如果字符集较大，空间开不下，就要用 $map$ 存边（因为要支持快速查询是否存在一条边，无法使用邻接表），复杂度就会带上 $\log|\Sigma|$。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;#include &lt;cstring&gt;const int N=1000010;struct Node&#123; int len,par,ch[26];&#125; sam[N&lt;&lt;1];void insert(int x);char s[N];int p,tot;int main()&#123; int i; scanf("%s",s); sam[0].par=-1; for (i=0;s[i];++i) insert(s[i]-'0'); return 0;&#125;void insert(int x)&#123; int np=++tot; sam[np].len=sam[p].len+1; while (~p&amp;&amp;!sam[p].ch[x]) &#123; sam[p].ch[x]=np; p=sam[p].par; &#125; if (p==-1) sam[np].par=0; else &#123; int q=sam[p].ch[x]; if (sam[q].len==sam[p].len+1) sam[np].par=q; else &#123; int nq=++tot; sam[nq].len=sam[p].len+1; memcpy(sam[nq].ch,sam[q].ch,sizeof(sam[q].ch)); sam[nq].par=sam[q].par; sam[q].par=sam[np].par=nq; while (~p&amp;&amp;sam[p].ch[x]==q) &#123; sam[p].ch[x]=nq; p=sam[p].par; &#125; &#125; &#125; p=np;&#125; SAM的一些应用一些应用我还没有写过..写过之后可能会补（gu）上（gu）来（gu）。可以参考OI wiki。 判断子串/后缀根据SAM的定义和性质，建出文本串的SAM，将模式串分别输入SAM，若转移到 $null$ 则不是子串，否则是；若转移到接受状态则是后缀，否则不是。 读入字符串时删除首字符记录一下已读入的字符串长度，若小于等于当前状态的 $parent.len$，就转移到 $parent$。 例题：CF235C Cyclical Quest 子串出现次数一个子串出现次数就是其对应 $right$ 集合的元素个数。 在创建 $np$ 时，将其 $cnt$ 赋为 $1$，建好SAM后，每个状态的出现次数就是 $parent$ 子树内的 $cnt$ 之和。 例题：【模板】后缀自动机 子串第一次出现位置和子串出现次数差不多，创建 $np​$ 时，将 $firstpos(np)​$ 设为 $len(np)-1​$，复制 $nq​$ 时，将 $firstpos(nq)​$ 设为 $firstpos(q)​$，最后对子树内取 $min​$。 本质不同子串数每个状态表示 $maxlen-minlen+1$ 个字符串，而 $minlen=len(parent)+1$，所以一个状态表示的字符串数量就是 $len-parent.len$。求和即可。 例题：[SDOI2016]生成魔咒 第 $k$ 大子串预处理每个状态可以转移到多少个不同的子串，然后就可以做了。 例题： SP7258 SUBLEX [TJOI2015]弦论 两串的最长公共子串对其中一个串建SAM，从起始状态开始，读入另一个字符串，若有转移则转移，将已匹配长度 $+1$，否则跳到 $parent$（这里和 $kmp$ 有点像），并将已匹配长度修改为 $len(parent)​$。过程中最大的已匹配长度就是答案。 例题：SP1811 LCS 多串的最长公共子串还是对其中一个串建SAM，以同样的方式依次读入每个字符串，只不过对每个状态要保存当前字符串的最大匹配长度，所有字符串在某个状态的最大匹配长度的最小值就是这一堆字符串在这个状态能匹配的最大长度。如果能在一个状态匹配，一定能在 $parent$ 处匹配，所以要对子树取 $max$，但也不要忘了对 $len$ 取 $min$。 例题： SP1812 LCS2 [SDOI2008]Sandy的卡片 任意DFA的压缩这部分估计没人感兴趣..OI里没用，也不是证明SAM最小性必需的（最小性的证明我在前文中已经简略说明了：状态的 $reg$ 两两不同）。只不过或许会对理解SAM本质以及发明它的人怎么想到的有些帮助… 或许这种方式在很多年前就已经被人提出了..总之这部分内容完全是我自己yy的，我也懒得去查有没有人发明过。 这部分内容不保证正确性，如果有误欢迎指正。如果有人愿意提供严谨证明（怎么可能有人啊..只不过我这里都懒得严谨证明了，随便口头地说了一下）一定非常感谢。 “DFA的压缩”的定义一个可用于压缩DFA的映射 $f:Q_A\rightarrow Q_B$ 需要满足以下几个条件： $\forall v\ne start_A,f(v)\ne f(start_A)​$ $\forall u\in F,v\notin F,f(u)\ne f(v)​$ $\forall f(u)=f(v),c\in\Sigma,f(\delta_A(u,c))=f(\delta_A(v,c))$ 如：在SAM中，把所有 $right$ 集合相同的状态映射到同一状态就是一个符合条件的映射。 定义DFA $A$ 在映射 $f$ 下的压缩为 $B$，其中： $\Sigma_B=\Sigma_A$ $Q_B=f(Q_A)$ $start_B=f(start_A)$ $F_B=f(F_A)​$ $\delta_B(f(v),c)=f(\delta_A(v,c))$，这一定义依赖于 $f$ 的性质 $3​$。 如：用 $right$ 集合等价类这个映射可以将朴素SAM压缩成最简SAM。 压缩后的自动机与原自动机等价的证明我们证明一个比 $A(s)=B(s)$ 更强的命题：$[\delta_A(v,s)\in F_A]=[\delta_B(f(v),s)\in F_B]$。 当 $s$ 只有一个字符时，根据 $f$ 满足的性质 $2$ 以及 $B$ 的定义 $4,5$，命题显然成立。 当 $s$ 不止一个字符时，可以归纳地说明命题成立。 DFA的最简压缩方法 这里给出一个将任意DFA压缩至最简的方法： 由于DFA是一个DAG，它的任意生成子图都必定有出度为 $0$ 的点。每次找到这些点，然后从中选取尽量多的点，使其映射到同一个状态后满足 $f$ 需要满足的三条性质（也就是，同一字符转移到的状态映射到的状态相同，且没有一个是接受状态另一个不是的情况），然后将这些点从图中删去，重复直至所有点都有了映射后的状态（所有点都被删去）。这样得到的映射 $f​$ 能够将原DFA压缩至最简。 压缩至最简的证明我们先证明每个状态的 $reg$（定义参见上文，表示从一个状态起能识别的字符串集合）两两不等。我们按照拓扑序归纳地证明。 没有出边的非接受状态可以视作 $null$，而没有出边的接受状态按上文所述方法必定会被映射至同一状态。所以命题对没有出边的状态成立。 假设一个状态所有出边的对应状态都已被证明，那么转移函数不同就等价于 $reg$ 不同，所以命题成立。 接着，我们由 $reg$ 两两不同证明压缩至最简： 若状态数继续减少，那么必然存在原来 $reg$ 不同的两个状态 $B(s_1)$ 和 $B(s_2)$ 被压缩到了一起，任取一个只在 $reg(B(s_1))$ 或只在 $reg(B(s_2))$ 中的字符串 $t$，原来 $B(s_1+t)\ne B(s_2+t)$，压缩后却使得 $B’(s_1+t)=B’(s_2+t)$，不符合要求。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>SAM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P3804 【模板】后缀自动机（SAM/后缀数组）]]></title>
    <url>%2FP3804-%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[题目链接洛谷 题意简述求 出现次数不为 $1$ 的子串的 出现次数 $\times$ 长度 的最大值。 SAM 做法简要做法一个状态的出现次数可以这么计算： 插入一个字符时，$np$ 的 $cnt$ 设为 $1$，一个状态的出现次数就是它在 $parent$ 树上的子树的 $cnt$ 之和。 证明..简要说一下：因为 $np$ 的 $right$ 集合为 $\{L\}$ 。 所以，插入整个字符串后 dfs 一遍 $parent$ 树算一算就好了。 参考代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int N=1000010;const int DELTA=26;struct Node&#123; int len,ch[DELTA],par,cnt; Node()&#123; memset(ch,0,sizeof(ch)); &#125;&#125; sam[N&lt;&lt;1];void insert(int x);void add(int u,int v);void dfs(int u);char s[N];int p,tot,head[N&lt;&lt;1],nxt[N&lt;&lt;1],to[N&lt;&lt;1],cnt;ll ans;int main()&#123; int i; scanf("%s",s); for (i=0;s[i];++i) insert(s[i]-'a'); for (i=1;i&lt;=tot;++i) add(sam[i].par,i); dfs(0); cout&lt;&lt;ans; return 0;&#125;void insert(int x)&#123; int np=++tot; sam[np].len=sam[p].len+1; sam[np].cnt=1; while (p&amp;&amp;!sam[p].ch[x]) &#123; sam[p].ch[x]=np; p=sam[p].par; &#125; if (sam[p].ch[x]) &#123; int q=sam[p].ch[x]; if (sam[q].len==sam[p].len+1) sam[np].par=q; else &#123; int nq=++tot; sam[nq].len=sam[p].len+1; memcpy(sam[nq].ch,sam[q].ch,sizeof(sam[q].ch)); sam[nq].par=sam[q].par; sam[q].par=sam[np].par=nq; while (sam[p].ch[x]==q) &#123; sam[p].ch[x]=nq; p=sam[p].par; &#125; &#125; &#125; else &#123; sam[p].ch[x]=np; sam[np].par=0; &#125; p=np;&#125;void add(int u,int v)&#123; nxt[++cnt]=head[u]; head[u]=cnt; to[cnt]=v;&#125;void dfs(int u)&#123; int i,v; for (i=head[u];i;i=nxt[i]) &#123; v=to[i]; dfs(v); sam[u].cnt+=sam[v].cnt; &#125; if (sam[u].cnt&gt;1) ans=max(ans,(ll)sam[u].cnt*sam[u].len);&#125; 后缀数组做法简要做法一个长度为 $h$ 的子串出现 $k$ 次就是有 $k-1$ 个连续的 $height\ge h$。单调栈维护即可。 然而..卡常卡不过去QAQ 参考代码（最高80分）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N=1000010;char s[N];int n,sa[N],rk[N&lt;&lt;1],id[N&lt;&lt;1],px[N],cnt[N],ht[N],l[N],sta[N],top;long long ans;bool cmp(int x,int y,int w)&#123; return id[x]==id[y]&amp;&amp;id[x+w]==id[y+w]; &#125;int main()&#123; int i,w,p,m=300,k; scanf("%s",s+1); n=strlen(s+1); for (i=1;i&lt;=n;++i) ++cnt[rk[i]=s[i]]; for (i=1;i&lt;=m;++i) cnt[i]+=cnt[i-1]; for (i=n;i&gt;=1;--i) sa[cnt[rk[i]]--]=i; for (w=1;w&lt;n;w&lt;&lt;=1,m=p) &#123; memset(cnt,0,sizeof(cnt)); for (p=0,i=n;i&gt;n-w;--i) id[++p]=i; for (i=1;i&lt;=n;++i) if (sa[i]&gt;w) id[++p]=sa[i]-w; for (i=1;i&lt;=n;++i) ++cnt[px[i]=rk[id[i]]]; for (i=1;i&lt;=m;++i) cnt[i]+=cnt[i-1]; for (i=n;i&gt;=1;--i) sa[cnt[px[i]]--]=id[i]; swap(id,rk); for (p=0,i=1;i&lt;=n;++i) rk[sa[i]]=cmp(sa[i],sa[i-1],w)?p:++p; &#125; for (i=1,k=0;i&lt;=n;++i) &#123; if (k) --k; while (s[i+k]==s[sa[rk[i]-1]+k]) ++k; ht[rk[i]]=k; &#125; for (i=1;i&lt;=n;++i) &#123; while (top&amp;&amp;ht[sta[top]]&gt;=ht[i]) --top; l[i]=sta[top]; sta[++top]=i; &#125; sta[top=1]=n+1; for (i=n;i&gt;=1;--i) &#123; while (top&amp;&amp;ht[sta[top]]&gt;ht[i]) --top; if (sta[top]-l[i]&gt;1) ans=max(ans,(long long)ht[i]*(sta[top]-l[i])); sta[++top]=i; &#125; cout&lt;&lt;ans; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>后缀数组</tag>
        <tag>SAM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ4516 [SDOI2016]生成魔咒（SAM）]]></title>
    <url>%2FBZOJ4516-SDOI2016-%E7%94%9F%E6%88%90%E9%AD%94%E5%92%92%EF%BC%88SAM%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目链接洛谷 dark bzoj 题意简述给你一个字符串（字符集大小 $10^9$，长度 $10^5$），求每个前缀的本质不同子串数。 简要做法如果只求整个串的本质不同子串，由于每个本质不同子串可以与 SAM 上一个状态+串的长度一一对应，所以本质不同子串数就是每个状态的 $maxlen-minlen+1$，也就是 $len-parent.len$。 $parent$ 不改变时，逐个加入字符并计算即可。 考虑 $parent$ 改变的情况，四次 $parent$ 改变分别为 $nq-q.parent$，$-(q-q.parent)$，$q-nq$，$np-nq$。总贡献为 $nq-q.parent-q+q.parent+q-nq+np-nq=np-nq$，也是新加入的点的 $len$ 减去 $parent.len$，是一样的。 由于字符集较大，用 map 存边。 参考代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;map&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;int read()&#123; int out=0; char c; while (!isdigit(c=getchar())); for (;isdigit(c);c=getchar()) out=out*10+c-'0'; return out;&#125;const int N=100010;struct Node&#123; int len,par; map&lt;int,int&gt; ch;&#125; sam[N&lt;&lt;1];void insert(int x);int n,p,tot;ll ans;int main()&#123; int i; n=read(); sam[0].par=-1; for (i=1;i&lt;=n;++i) &#123; insert(read()); printf("%lld\n",ans); &#125; return 0;&#125;void insert(int x)&#123; int np=++tot; sam[np].len=sam[p].len+1; while (~p&amp;&amp;sam[p].ch.find(x)==sam[p].ch.end()) &#123; sam[p].ch[x]=np; p=sam[p].par; &#125; if (p==-1) sam[np].par=0; else &#123; int q=sam[p].ch[x]; if (sam[q].len==sam[p].len+1) sam[np].par=q; else &#123; int nq=++tot; sam[nq].len=sam[p].len+1; sam[nq].ch=sam[q].ch; sam[nq].par=sam[q].par; sam[q].par=sam[np].par=nq; while (~p&amp;&amp;sam[p].ch[x]==q) &#123; sam[p].ch[x]=nq; p=sam[p].par; &#125; &#125; &#125; ans+=sam[np].len-sam[sam[np].par].len; p=np;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>SAM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[后缀数组学习笔记]]></title>
    <url>%2F%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[后缀数组是一种处理字符串问题的有力工具（废话），本文的主要特点是一步步地由最朴素的后缀数组构建方法逐步优化，而非直接给出最终优化后的代码。 希望这篇文章能让更多的人看懂后缀数组的代码，学会后缀数组。 模板题链接洛谷（只用求 $sa$） LOJ（只用求 $sa$） UOJ（求 $sa$ 和 $height$） 评测鸭（求 $sa$ 和 $height$） 两（can）篇（kao）论（zi）文（liao）[1]：[2004]后缀数组 by.徐智磊 [2]：[2009]后缀数组——处理字符串的有力工具 by.罗穗骞 这两篇论文还是写的很好的，大家可以看看。 下文中如果有引用这两篇论文中的内容，将以上标形式标出（$^{[1]}$ $^{[2]}$）。 关于字符串..说到字符串算法，就得先提一些定（fei）义（hua），知道的就可以不看了.. 字符集$^{[1]}$一个字符集 $Σ$ 是一个建立了全序关系的集合，也就是说，$Σ$ 中的任意两个不同的元素 $α$ 和 $β$ 都可以比较大小，要么 $α&lt;β$，要么 $β&lt;α$（也就是$α&gt;β$）。字符集 $Σ$ 中的元素称为字符。 字符串$^{[1]}$一个字符串 $S$ 是将 $n$ 个字符顺次排列形成的数组，$n$ 称为 $S$ 的长度，表示为 $len(S)$。$S$ 的第 $i$ 个字符表示为 $S[i]$。 子串$^{[1]}$字符串 $S$ 的子串 $S[i..j]，i≤j$，表示 S 串中从 $i$ 到 $j$ 这一段，也就是顺次排列 $S[i],S[i+1],…,S[j]$ 形成的字符串。 后缀后缀是指从某个位置 $i$ 开始到整个串末尾结束的一个特殊子串。字符串 $S$ 的从 $i$ 开头的后缀表示为 $Suffix(S,i)$，也就是 $Suffix(S,i)=S[i..len(S)]$。$^{[1]}$ 下文中以 “后缀 $i$” 代指字符串从 $i$ 开头的后缀。$i$ 称作这个后缀的编号。 字典序以第 $i$ 个字符作为第 $i$ 关键字进行大小比较，空字符小于字符集内任何字符（即：$a&lt;aa$）。 后缀数组是什么？后缀数组主要是两个数组：$sa$ 和 $rk$。 其中，$sa[i]$ 表示将所有后缀排序后第 $i$ 小的后缀的编号。$rk[i]$ 表示后缀 $i$ 的排名。 这两个数组满足性质：$sa[rk[i]]=rk[sa[i]]=i$。 后缀数组示例：$^{[2]}$ 后缀数组怎么求？$O(n^2\log n)$ 做法我相信这个做法大家还是能自己想到的..用string+sort就可以了。由于比较两个字符串是 $O(n)$ 的，所以排序是 $O(n^2\log n)$ 的。 $O(n\log^2n)$ 做法这个做法要用到倍增的思想。 先对每个长度为 $1$ 的子串（即每个字符）进行排序。 假设我们已经知道了长度为 $w$ 的子串的排名 $rk_w[1..n]$（即，$rk_w[i]$ 表示 $s[i..\min(i+w-1,n)]$ 在 $\{s[x..\min(x+w-1,n)] | x\in\mathbb{N}\bigcap[1,n]\}$ 中的排名），那么，以 $rk_w[i]$ 为第一关键字， $rk_w[i+w]$ 为第二关键字（若 $i+w&gt;n$ 则令 $rk_w[i+w]$ 为 $-INF$）进行排序，就可以求出 $rk_{2w}[1..n]$。 倍增排序示意图：$^{[2]}$ 如果用 sort 进行排序，复杂度就是 $O(n\log^2n)$ 的。 参考代码 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N=1000010;char s[N];int n,w,sa[N],rk[N&lt;&lt;1],oldrk[N]; //为了防止访问rk[i+w]导致数组越界，开两倍数组。当然也可以在访问前判断是否越界，但直接开两倍数组方便一些。int main()&#123; int i,p; scanf("%s",s+1); n=strlen(s+1); for (i=1;i&lt;=n;++i) rk[i]=s[i]; for (w=1;w&lt;n;++w) &#123; for (i=1;i&lt;=n;++i) sa[i]=i; sort(sa+1,sa+n+1,[](int x,int y)&#123;return rk[x]==rk[y]?rk[x+w]&lt;rk[y+w]:rk[x]&lt;rk[y];&#125;); //这里用到了lambda表达式 memcpy(oldrk,rk,sizeof(oldrk)); //由于计算rk的时候原来的rk会被覆盖，要先复制一份 for (p=0,i=1;i&lt;=n;++i) rk[sa[i]]=oldrk[sa[i]]==oldrk[sa[i-1]]&amp;&amp;oldrk[sa[i]+w]==oldrk[sa[i-1]+w]?p:++p; //若两个子串相同，它们对应的rk也需要相同，所以要去重 &#125; for (i=1;i&lt;=n;++i) printf("%d ",sa[i]); return 0;&#125; $O(n\log n)$ 做法在刚刚的 $O(n\log^2n)$ 做法中，一次排序是 $O(n\log n)$ 的，如果能 $O(n)$ 排序，就能 $O(n\log n)$ 计算后缀数组了。 计数排序计数排序的核心思想还是比较好理解的，可以先看代码： 1234//对a这个数组进行排序，结果存到数组b中（b[i]表示第i名的编号），cnt是一个辅助数组，m是a的值域for (i=1;i&lt;=n;++i) ++cnt[a[i]];for (i=1;i&lt;=m;++i) cnt[i]+=cnt[i-1];for (i=n;i&gt;=1;--i) b[cnt[a[i]]--]=i; 其实就是先数一数小于等于 $a[i]$ 的数有多少个，然后从后往前看每个数的名次。感性理解/手玩一下就能明白这个排序算法了。 这个算法有两个特点： 它是 $O(n+m)$ 的（$m$ 为待排序数据的值域范围）。 它是一个稳定排序，即，相等的数会按原位置（下标）进行排序。 基数排序值得一提的是很多人经常把计数排序和基数排序搞混.. 基数排序是一个基于稳定排序的多关键字排序算法，复杂度为关键字个数乘上稳定排序的复杂度。而这个稳定排序通常用计数排序实现。 它的思想是，如果有 $k$ 个关键字，先以第 $k$ 关键字进行一次稳定排序，然后再以第 $k-1$ 关键字进行一次稳定排序，……，最后以第一关键字进行一次稳定排序。可以看出，这样做就完成了以这 $k$ 个关键字的排序。 具体实现大约是这样的： 12345678910//key[i][j]表示第j个数的第i关键字，b[i]依然表示第i名的编号，m是key的值域，cnt和id都是辅助数组for (i=1;i&lt;=n;++i) id[i]=i;for (i=k;i&gt;=1;--i)&#123; memset(cnt,0,sizeof(cnt)); for (j=1;j&lt;=n;++j) id[j]=b[j]; for (j=1;j&lt;=n;++j) ++cnt[key[i][id[j]]]; for (j=1;j&lt;=m;++j) cnt[j]+=cnt[j-1]; for (j=n;j&gt;=1;--j) b[cnt[key[i][id[j]]]--]=id[j];&#125; 将基数排序运用于求后缀数组如果你学会了基数排序，也会 $O(n\log^2n)$ 求后缀数组，那你应该可以自己写出一个 $O(n\log n)$ 求后缀数组的程序了。 参考代码 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N=1000010;char s[N];int n,sa[N],rk[N&lt;&lt;1],oldrk[N&lt;&lt;1],id[N],cnt[N];int main()&#123; int i,m,p,w; scanf("%s",s+1); n=strlen(s+1); m=max(n,300); for (i=1;i&lt;=n;++i) ++cnt[rk[i]=s[i]]; for (i=1;i&lt;=m;++i) cnt[i]+=cnt[i-1]; for (i=n;i&gt;=1;--i) sa[cnt[rk[i]]--]=i; for (w=1;w&lt;n;w&lt;&lt;=1) &#123; memset(cnt,0,sizeof(cnt)); for (i=1;i&lt;=n;++i) id[i]=sa[i]; for (i=1;i&lt;=n;++i) ++cnt[rk[id[i]+w]]; for (i=1;i&lt;=m;++i) cnt[i]+=cnt[i-1]; for (i=n;i&gt;=1;--i) sa[cnt[rk[id[i]+w]]--]=id[i]; memset(cnt,0,sizeof(cnt)); for (i=1;i&lt;=n;++i) id[i]=sa[i]; for (i=1;i&lt;=n;++i) ++cnt[rk[id[i]]]; for (i=1;i&lt;=m;++i) cnt[i]+=cnt[i-1]; for (i=n;i&gt;=1;--i) sa[cnt[rk[id[i]]]--]=id[i]; memcpy(oldrk,rk,sizeof(oldrk)); for (p=0,i=1;i&lt;=n;++i) rk[sa[i]]=oldrk[sa[i]]==oldrk[sa[i-1]]&amp;&amp;oldrk[sa[i]+w]==oldrk[sa[i-1]+w]?p:++p; &#125; for (i=1;i&lt;=n;++i) printf("%d ",sa[i]); return 0;&#125; 一些常数优化如果你把上面那份代码交到洛谷上.. 怎么会这样呢？是这题卡常吗？ 一翻其他人的代码，最慢点也不过 $1s$.. 这是因为，上面那份代码的常数的确很大.. 第二关键字无需计数排序实际上，像这样就可以了： 12for (p=0,i=n;i&gt;n-w;--i) id[++p]=i;for (i=1;i&lt;=n;++i) if (sa[i]&gt;w) id[++p]=sa[i]-w; 意会一下，先把 $s[i+w..i+2w-1]$ 为空串的位置放前面，再把剩下的按排好的顺序放进去。 优化计数排序的值域每次对 $rk$ 进行去重之后，我们都计算了一个 $p$，这个 $p$ 即是 $k$ 的值域，将值域改成它即可。 无需新开数组oldrk并memcpy注意到计算完 $sa$ 之后 $id$ 数组就没有用了，可以直接 swap(id,rk) 来把 oldrk 的信息存在 id 数组中（$id$ 和 $rk$ 本质上都是指针，所以 swap 是 $O(1)$ 的）。注意两个数组要开一样大才能 swap。 将 $rk[id[i]]$ 存下来，减少不连续内存访问这个优化在数据范围较大时效果非常明显。 用函数cmp来计算是否重复同样是减少不连续内存访问，在数据范围较大时效果比较明显。 把 oldrk[sa[i]]==oldrk[sa[i-1]]&amp;&amp;oldrk[sa[i]+w]==oldrk[sa[i-1]+w] 替换成 cmp(sa[i],sa[i-1],w)，bool cmp(int x,int y,int w){ return id[x]==id[y]&amp;&amp;id[x+w]==id[y+w]; }。 参考代码 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N=1000010;char s[N];int n,sa[N],rk[N&lt;&lt;1],id[N&lt;&lt;1],px[N],cnt[N]; //px[i]=rk[id[i]]（用于排序的数组所以叫px）bool cmp(int x,int y,int w)&#123; return id[x]==id[y]&amp;&amp;id[x+w]==id[y+w]; &#125;int main()&#123; int i,m=300,p,w; scanf("%s",s+1); n=strlen(s+1); for (i=1;i&lt;=n;++i) ++cnt[rk[i]=s[i]]; for (i=1;i&lt;=m;++i) cnt[i]+=cnt[i-1]; for (i=n;i&gt;=1;--i) sa[cnt[rk[i]]--]=i; for (w=1;w&lt;n;w&lt;&lt;=1,m=p) //m=p就是优化计数排序值域 &#123; for (p=0,i=n;i&gt;n-w;--i) id[++p]=i; for (i=1;i&lt;=n;++i) if (sa[i]&gt;w) id[++p]=sa[i]-w; memset(cnt,0,sizeof(cnt)); for (i=1;i&lt;=n;++i) ++cnt[px[i]=rk[id[i]]]; for (i=1;i&lt;=m;++i) cnt[i]+=cnt[i-1]; for (i=n;i&gt;=1;--i) sa[cnt[px[i]]--]=id[i]; swap(rk,id); for (p=0,i=1;i&lt;=n;++i) rk[sa[i]]=cmp(sa[i],sa[i-1],w)?p:++p; //注意这里的id相当于原来的oldrk &#125; for (i=1;i&lt;=n;++i) printf("%d ",sa[i]); return 0;&#125; 这样优化之后应该不开O2都能过。 $O(n)$ 做法名字叫DC3，我不会 可以参考[2009]后缀数组——处理字符串的有力工具 by.罗穗骞，里面有介绍这个算法。 一般情况下用倍增法做足常数优化是不会被卡的.. 后缀数组无需 $height$ 数组的应用如果用不到 $height$ 数组，一般就是利用 $rk$ 数组对字符串进行排序，有时需要对原串进行一定的加工使需要排序的字符串变成后缀，或者是只需对后缀进行排序便能对需要排序的字符串进行排序。 [JSOI2007]字符加密洛谷 dark bzoj [USACO07DEC]Best Cow Line, Gold洛谷 我的题解 $height$ 数组后缀数组的题目往往是要用到 $height$ 数组的。 lcp（最长公共前缀）两个字符串 $S$ 和 $T$ 的 $lcp$ 就是最大的 $x$ 使得 $S_i=T_i (\forall 1\le i\le x)$ 。 下文中以 $lcp(i,j)$ 表示后缀 $i$ 和后缀 $j$ 的最长公共前缀（的长度）。 $height$ 数组的定义$height[i]=lcp(sa[i],sa[i-1])$，即第 $i$ 名的后缀与它前一名的后缀的最长公共前缀。 $O(n)$ 求 $height$ 数组需要的一个引理$height[rk[i]]\ge height[rk[i-1]]-1$ 证明的话..感性理解 当 $height[rk[i-1]]\le1$ 时，上式显然成立（右边小于等于 $0$ ）。 当 $height[rk[i-1]]&gt;1$ 时： 设后缀 $i-1$ 为 $aAD$（$A$ 是一个长度为 $height[rk[i-1]]-1$ 的字符串），那么后缀 $i$ 就是 $AD$。设后缀 $sa[rk[i-1]-1]$ 为 $aAB$ ，那么 $lcp(i-1,sa[rk[i-1]-1])=aA$。由于后缀 $sa[rk[i-1]-1]+1$ 是 $AB$，一定排在后缀 $i$ 的前面，所以后缀 $sa[rk[i]-1]$ 一定含有前缀 $A$，所以 $lcp(i,sa[rk[i]-1])$ 至少是 $height[rk[i-1]]-1$。 简单来说： $i-1$：$aAD$ $i$：$AD$ $sa[rk[i-1]-1]$：$aAB$ $sa[rk[i-1]-1]+1$：$AB$ $sa[rk[i]-1]$：$A[B/C]$ $lcp(i,sa[rk[i]-1])$：$AX$（$X$ 可能为空） $O(n)$ 求 $height$ 数组的代码实现利用上面这个引理暴力求即可： 123456for (i=1,k=0;i&lt;=n;++i)&#123; if (k) --k; while (s[i+k]==s[sa[rk[i]-1]+k]) ++k; ht[rk[i]]=k; //height太长了缩写为ht&#125; 利用摊还分析/势能分析可以发现是O(n)的，$k$ 不会超过 $n$，最多减 $n$ 次，所以最多加 $2n$ 次。 应用 $height$ 数组需要的一个性质$lcp(sa[i],sa[j])=\min\{height[i+1..j]\}$ 感性理解：如果 $height$ 一直大于某个数，前这么多位就一直没变过；反之，由于后缀已经排好序了，不可能变了之后变回来。 严格证明可以参考[2004]后缀数组 by.徐智磊。 $height$ 数组的应用$height$ 数组往往用来解决关于字符串公共部分的题目，通常需要和RMQ/单调栈等算法相结合。 [USACO06DEC]Milk Patterns洛谷 我的题解 [AHOI2013]差异洛谷 dark bzoj [HAOI2016]找相同字符洛谷 dark bzoj 我的题解 [NOI2015]品酒大会洛谷 dark bzoj SP8222 NSUBSTR - Substrings洛谷 SPOJ]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>后缀数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ4566 [HAOI2016]找相同字符（后缀数组）]]></title>
    <url>%2FBZOJ4566-HAOI2016-%E6%89%BE%E7%9B%B8%E5%90%8C%E5%AD%97%E7%AC%A6%EF%BC%88%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目链接洛谷 dark bzoj 题意简述给你两个字符串，从中各取一个子串使这两个子串相同，求方案数。 简要做法以某两个位置开头的相同子串数=这两个位置开头的后缀的 $lcp$ 如果在同一个字符串中，求出 height 数组后使用单调栈求出每个位置作为最小值的贡献即可（单调栈部分与 P2659 美丽的序列，[ZJOI2007]棋盘制作 等题类似，在此就不赘述了；求两两 $lcp​$ 之和这部分与 [AHOI2013]差异 类似，故没有写那题的题解）。 由于有两个字符串不太方便，考虑将它们拼接起来并在中间加上一个不存在的字符（如#）。这样求出拼接后的字符串的答案，减去两个原串的答案，就是最终的答案。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N=400010;typedef long long ll;int sa[N],sa2[N&lt;&lt;1],rk[N&lt;&lt;1],px[N],cnt[N],sta[N],top,f[N],height[N];struct Suffix_Array&#123; char s[N]; ll calc() &#123; ll out=0; int n,i,k,w,p,m=200; n=strlen(s+1); memset(sa2,0,sizeof(sa2)); memset(cnt,0,sizeof(cnt)); for (i=1;i&lt;=n;++i) ++cnt[rk[i]=s[i]]; for (i=1;i&lt;=m;++i) cnt[i]+=cnt[i-1]; for (i=n;i&gt;=1;--i) sa[cnt[rk[i]]--]=i; for (w=1;w&lt;n;w&lt;&lt;=1,m=p) &#123; memset(cnt,0,sizeof(cnt)); for (p=0,i=n;i&gt;n-w;--i) sa2[++p]=i; for (i=1;i&lt;=n;++i) if (sa[i]&gt;w) sa2[++p]=sa[i]-w; for (i=1;i&lt;=n;++i) ++cnt[px[i]=rk[sa2[i]]]; for (i=1;i&lt;=m;++i) cnt[i]+=cnt[i-1]; for (i=n;i&gt;=1;--i) sa[cnt[px[i]]--]=sa2[i]; swap(rk,sa2); for (p=0,i=1;i&lt;=n;++i) rk[sa[i]]=sa2[sa[i]]==sa2[sa[i-1]]&amp;&amp;sa2[sa[i]+w]==sa2[sa[i-1]+w]?p:++p; &#125; for (i=1,k=0;i&lt;=n;++i) &#123; if (k) --k; while (s[i+k]==s[sa[rk[i]-1]+k]) ++k; height[rk[i]]=k; &#125; for (i=1;i&lt;=n;++i) &#123; while (top&amp;&amp;height[sta[top]]&gt;=height[i]) --top; f[i]=i-sta[top]; sta[++top]=i; &#125; top=0; sta[++top]=n+1; height[n+1]=0; for (i=n;i&gt;=1;--i) &#123; while (top&amp;&amp;height[sta[top]]&gt;height[i]) --top; out+=(ll)f[i]*(sta[top]-i)*height[i]; sta[++top]=i; &#125; return out; &#125;&#125; a,b,ab;int main()&#123; int n,m,i; scanf("%s%s",a.s+1,b.s+1); n=strlen(a.s+1); m=strlen(b.s+1); for (i=1;i&lt;=n;++i) ab.s[i]=a.s[i]; ab.s[n+1]='#'; for (i=1;i&lt;=m;++i) ab.s[n+1+i]=b.s[i]; cout&lt;&lt;ab.calc()-a.calc()-b.calc(); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>后缀数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P2852 [USACO06DEC]Milk Patterns（后缀数组）]]></title>
    <url>%2FP2852-USACO06DEC-Milk-Patterns%EF%BC%88%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目链接洛谷 题意简述给你一个字符串，求最长的出现了至少 $k$ 次的子串的长度。 简要做法求出 height 数组，若一个长为 $x$ 的子串在原串中出现了至少 $k$ 次，则 height 数组中一定存在至少 $k-1$ 个 连续的大于等于 $x$ 的值。所以，问题就转化成了：求 height 数组中 每连续 $k-1$ 个数的最小值 的最大值。即：$a_i=\min\{height_{i..i+k-2}\}$，求 $a_i$ 的最大值。可以用RMQ/平衡树/线段树/multiset解决。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;set&gt;using namespace std;const int N=40010;int n,k,a[N],sa[N],rk[N],sa2[N],px[N],cnt[1000010],height[N],ans;multiset&lt;int&gt; t;int main()&#123; int i,j,w,p,m=1000000; scanf("%d%d",&amp;n,&amp;k); --k; for (i=1;i&lt;=n;++i) scanf("%d",a+i); for (i=1;i&lt;=n;++i) ++cnt[rk[i]=a[i]]; for (i=1;i&lt;=m;++i) cnt[i]+=cnt[i-1]; for (i=n;i&gt;=1;--i) sa[cnt[rk[i]]--]=i; for (w=1;w&lt;n;w&lt;&lt;=1,m=p) &#123; memset(cnt,0,sizeof(cnt)); for (p=0,i=n;i&gt;n-w;--i) sa2[++p]=i; for (i=1;i&lt;=n;++i) if (sa[i]&gt;w) sa2[++p]=sa[i]-w; for (i=1;i&lt;=n;++i) ++cnt[px[i]=rk[sa2[i]]]; for (i=1;i&lt;=m;++i) cnt[i]+=cnt[i-1]; for (i=n;i&gt;=1;--i) sa[cnt[px[i]]--]=sa2[i]; swap(rk,sa2); for (p=0,i=1;i&lt;=n;++i) rk[sa[i]]=sa2[sa[i]]==sa2[sa[i-1]]&amp;&amp;sa2[sa[i]+w]==sa2[sa[i-1]+w]?p:++p; &#125; for (i=1,j=0;i&lt;=n;++i) &#123; if (j) --j; while (a[i+j]==a[sa[rk[i]-1]+j]) ++j; height[rk[i]]=j; &#125; for (i=1;i&lt;=n;++i) &#123; t.insert(height[i]); if (i&gt;k) t.erase(t.find(height[i-k])); ans=max(ans,*t.begin()); &#125; cout&lt;&lt;ans; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>后缀数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P2870 [USACO07DEC]Best Cow Line, Gold（后缀数组）]]></title>
    <url>%2FP2870-USACO07DEC-Best-Cow-Line-Gold%EF%BC%88%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目链接洛谷 题意简述给你一个字符串，每次从首或尾取一个字符组成字符串，问所有能够组成的字符串中字典序最小的一个。 简要做法暴力做法就是每次最坏 $O(n)$ 地判断当前应该取首还是尾，只需优化这一判断过程即可。 将原串reverse后拼接在原串后，并在中间加上一个没出现过的字符（如 # ），求SA，即可 $O(1)$ 完成这一判断。 参考代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int N=1000010;char s[N];int n,sa[N],sa2[N&lt;&lt;1],rk[N&lt;&lt;1],px[N],cnt[N];int main()&#123; int i,w,m=200,p,l=1,r,tot=0; cin&gt;&gt;n; r=n; for (i=1;i&lt;=n;++i) while (!isalpha(s[i]=getchar())); for (i=1;i&lt;=n;++i) rk[i]=rk[2*n+2-i]=s[i]; n=2*n+1; for (i=1;i&lt;=n;++i) ++cnt[rk[i]]; for (i=1;i&lt;=m;++i) cnt[i]+=cnt[i-1]; for (i=n;i&gt;=1;--i) sa[cnt[rk[i]]--]=i; for (w=1;w&lt;n;w&lt;&lt;=1,m=p) &#123; memset(cnt,0,sizeof(cnt)); for (p=0,i=n;i&gt;n-w;--i) sa2[++p]=i; for (i=1;i&lt;=n;++i) if (sa[i]&gt;w) sa2[++p]=sa[i]-w; for (i=1;i&lt;=n;++i) ++cnt[px[i]=rk[sa2[i]]]; for (i=1;i&lt;=m;++i) cnt[i]+=cnt[i-1]; for (i=n;i&gt;=1;--i) sa[cnt[px[i]]--]=sa2[i]; swap(sa2,rk); for (p=0,i=1;i&lt;=n;++i) rk[sa[i]]=sa2[sa[i]]==sa2[sa[i-1]]&amp;&amp;sa2[sa[i]+w]==sa2[sa[i-1]+w]?p:++p; &#125; while (l&lt;=r) &#123; printf("%c",rk[l]&lt;rk[n+1-r]?s[l++]:s[r--]); if ((++tot)%80==0) puts(""); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>后缀数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1856 [SCOI2010]生成字符串（组合数学）]]></title>
    <url>%2FBZOJ1856-SCOI2010-%E7%94%9F%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目链接洛谷 darkbzoj 题意简述$n$ 个入栈操作，$m$ 个出栈操作，问合法操作序列数。 简要做法借用一下这篇题解（的图）。 选了 $x$ 个数，$1$ 与 $0$ 个数之差为 $y$，如下图： 不考虑限制条件，方案数为从 $(0,0)$ 到 $(n+m,n-m)$ 的折线数，即从 $n+m$ 次操作中选择 $m$ 次向下： $\binom{n+m}m$。考虑某一种不合法的情况，把这条折线第一次碰到 $y=-1$ 前的部分以 $y=-1$ 为轴翻折，这样就建立了 从 $(0,0)$ 到 $(n+m,n-m)$ 且碰到了 $y=-1$ 的折线 与 从 $(0,-2)$ 到 $(n+m,n-m)$ 的折线 的一一对应，所以不合法的情况个数为 $\binom{n+m}{m-1}$，答案为 $\binom{n+m}m-\binom{n+m}{m-1}$。 （上面看懂了这段可以不看，这段是废话证明）为什么这玩意是双射（一一对应）..其实很简单，每条 从 $(0,0)$ 到 $(n+m,n-m)$ 且碰到了 $y=-1$ 的折线 在第一次碰到 $y=-1$ 前的部分以 $y=-1$ 为轴翻折可以得到唯一一条 从 $(0,-2)$ 到 $(n+m,n-m)$ 的折线，而一条 从 $(0,-2)$ 到 $(n+m,n-m)$ 的折线 必然会碰到 $y=-1$，同样可以把它在第一次碰到 $y=-1$ 前的部分以 $y=-1$ 为轴翻折，就会得到唯一一条 从 $(0,0)$ 到 $(n+m,n-m)$ 且碰到了 $y=-1$ 的折线。 最后吐槽一句。你谷完全不接受做法相同的题解，无法对已有做法进行阐述，所以并没有尝试在你谷发题解。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;typedef long long ll;const int N=1000010;const int mod=20100403;int qpow(int x,int y);int c(int x,int y);int jc[N&lt;&lt;1];int main()&#123; int n,m; cin&gt;&gt;n&gt;&gt;m; jc[0]=1; for (int i=1;i&lt;=n+m;++i) jc[i]=(ll)jc[i-1]*i%mod; cout&lt;&lt;(c(n+m,m)-c(n+m,m-1)+mod)%mod; return 0;&#125;int qpow(int x,int y)&#123; int out=1; while (y) &#123; if (y&amp;1) out=(ll)out*x%mod; x=(ll)x*x%mod; y&gt;&gt;=1; &#125; return out;&#125;int c(int x,int y)&#123; return (ll)jc[x]*qpow(jc[y],mod-2)%mod*qpow(jc[x-y],mod-2)%mod;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[n方过百万 暴力碾标算——指令集优化的基础使用]]></title>
    <url>%2Fn%E6%96%B9%E8%BF%87%E7%99%BE%E4%B8%87-%E6%9A%B4%E5%8A%9B%E7%A2%BE%E6%A0%87%E7%AE%97%E2%80%94%E2%80%94%E6%8C%87%E4%BB%A4%E9%9B%86%E4%BC%98%E5%8C%96%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[感谢 yfz 和 mcfx 在 WC 营员交流上的分享！ 然而只看那个课件来学习指令集好像略有困难..所以我来分享一下我自学一晚上的成果。 希望能帮助大家暴力过题，考场上再也写不出标算。 注：本文省略了无数个 unsigned，请自行把所有 int 视作 unsigned int，把所有 long long 视作 unsigned long long。 适用范围环境不要尝试在正式OI竞赛中使用指令集优化。 只适用于提供资瓷的 OJ，具体列表参照营员交流ppt： sse2，avx 什么的都是指令集的名字。 作用适用于方便对连续内存空间进行批量处理的题目。大约可以视作每 $8$ 个 int 为一个分块，块内进行赋值、修改等操作常数为 $1$，也就实现了常数/=$8$。当然如果是 long long 就只能除以四。 具体使用pragma&amp;include12345#pragma GCC optimize("Ofast,no-stack-protector,unroll-loops,fast-math")#pragma GCC target("sse,sse2,sse3,ssse3,sse4.1,sse4.2,avx,avx2,popcnt,tune=native")#include &lt;immintrin.h&gt;#include &lt;emmintrin.h&gt; 第一行是优化，如果你都用指令集了当然是能优化尽量优化。 第二行是告诉编译器你要使用指令集。 后面两个头文件是 C++ 将指令集封装成了函数，这样就不用在代码中内联汇编了。 变量类型大约有 __m256i __m256 __m256d 三种，分别存储 long long，float 和 double，实际上 __m256i 也可以用来存储 int。 指令使用可以在一个神奇的网站查需要的指令，左边选指令集以及指令类型，右边是指令，点开指令可以查看函数原型以及伪代码。 这里列几条常用指令： __m256i _mm256_set_epi32 (int e7, int e6, int e5, int e4, int e3, int e2, int e1, int e0)：参数是八个数，也就是一个“分块”里的数，注意是逆序的。返回值是一个含这八个数的“分块”。 __m256i _mm256_set_epi64x (__int64 e3, __int64 e2, __int64 e1, __int64 e0)：和上面一样，只不过是 $64$ 位整数，也就是 long long。 __m256i _mm256_set1_epi32 (int a)：相当于 _mm256_set_epi32(a,a,a,a,a,a,a,a)。 __m256i _mm256_add_epi32 (__m256i a, __m256i b)：把两个“分块”的对应位置分别相加，返回结果。 __m256i _mm256_cmpeq_epi32 (__m256i a, __m256i b)：判断两个“分块”的对应位置是否相等，若相等则返回的“分块”对应位置是 0xffffffff，否则是 0。 __m256i _mm256_cmpgt_epi32 (__m256i a, __m256i b)：和上面一样，只不过比较符是大于而不是相等。 __m256i _mm256_and_si256 (__m256i a, __m256i b)：返回两个“分块”的按位与，可以配合上面两条比较指令来使用。 访问数据可以直接通过下标访问： 12345678910111213141516#include &lt;cstdio&gt;#pragma GCC optimize("Ofast,no-stack-protector,unroll-loops,fast-math")#pragma GCC target("sse,sse2,sse3,ssse3,sse4.1,sse4.2,avx,avx2,popcnt,tune=native")#include &lt;immintrin.h&gt;#include &lt;emmintrin.h&gt;__m256i a;int main()&#123; a=_mm256_set_epi32(1,2,3,4,5,6,7,8); printf("%d",a[2]); return 0;&#125; 你们可以猜猜这个的结果是什么。 答案是..4。 为什么呢，首先 _mm256_set_epi32 的参数是逆序的，所以实际上存储的数顺序是 8,7,6,5,4,3,2,1。其次，__m256i 类型是存储 long long 的，所以直接通过下标访问实际上是在访问 long long，如果 cout&lt;&lt;a[2]就会返回 12884901892（$3\times2^{32}+4$）。所以，这句话实际上是在 printf(&quot;%d&quot;,12884901892ll);。 那么如何访问 int（甚至 short，如果题目允许这样就可以常数除以 $16$）呢？ 其实搞个指针就可以了： 123a=_mm256_set_epi32(1,2,3,4,5,6,7,8);int *b=(int *)&amp;a;printf("%d",b[2]); 这样子的输出就是 $6$ 了。 用这种方法就可以方便地处理序列问题了： 123456789101112131415161718192021222324252627#include &lt;cstdio&gt;#pragma GCC optimize("Ofast,no-stack-protector,unroll-loops,fast-math")#pragma GCC target("sse,sse2,sse3,ssse3,sse4.1,sse4.2,avx,avx2,popcnt,tune=native")#include &lt;immintrin.h&gt;#include &lt;emmintrin.h&gt;int* b;__m256i a[10],x;int main()&#123; int i; b=(int *)&amp;a; for (i=0;i&lt;80;++i) scanf("%d",b+i); x=_mm256_set1_epi32(233); for (i=0;i&lt;10;++i) a[i]=_mm256_add_epi32(a[i],x); for (i=0;i&lt;80;++i) printf("%d ",b[i]); return 0;&#125; 上面是一个简单的示例，读入 $80$ 个数，然后输出它们加上 $233$ 的结果。 例题这种东西为什么还会有例题啊。 教主的魔法，这题比较简单（废话暴力当然简单）。 【模板】线段树1，这题其实是最简单的，然而由于 dl 出题人把值域搞到了 long long，常数只能除以四，需要卡卡常，多提交几次才能过。 [Ynoi2018]五彩斑斓的世界，神司怒艹lxl标算的课件例题。 Simple Tree，这个还要树剖，只不过也还好，神司是直接内嵌汇编写的，没有测过用函数能不能过.. 然后以教主的魔法为例讲一下代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;cstdio&gt;#pragma GCC optimize("Ofast,no-stack-protector,unroll-loops,fast-math")#pragma GCC target("sse,sse2,sse3,ssse3,sse4.1,sse4.2,avx,avx2,popcnt,tune=native")#include &lt;immintrin.h&gt;#include &lt;emmintrin.h&gt;const int N=1000010;int n,m,tot,*a;__m256i A[N&gt;&gt;3];char op[10];void modify(int l,int r,int x)&#123; while ((l&amp;7)&amp;&amp;l&lt;r) a[l++]+=x; //处理左边不是整块的部分，和分块的处理方法是一样的 if (l==r) return; while (r&amp;7) a[--r]+=x; //处理右边不是整块的部分 if (l==r) return; __m256i t=_mm256_set1_epi32(x); //剩下的部分整块加上x for (l&gt;&gt;=3,r&gt;&gt;=3;l&lt;r;++l) A[l]=_mm256_add_epi32(A[l],t);&#125;int query(int l,int r,int x)&#123; int out=0; while ((l&amp;7)&amp;&amp;l&lt;r) out+=int(a[l++]&gt;=x); //处理左边不是整块的部分 if (l==r) return out; while (r&amp;7) out+=int(a[--r]&gt;=x); //处理右边不是整块的部分 if (l==r) return out; __m256i t=_mm256_set1_epi32(1); //这个1是每个大于等于x的数的贡献 __m256i ans=_mm256_set1_epi32(0); //这个ans是用来存答案的 __m256i cp=_mm256_set1_epi32(x-1); //这个是用来比较的，题目中是大于等于，所以和x-1比较 for (l&gt;&gt;=3,r&gt;&gt;=3;l&lt;r;++l) ans=_mm256_add_epi32(ans,_mm256_and_si256(t,_mm256_cmpgt_epi32(A[l],cp))); //这个意会一下，作用是数当前块有几个大于x-1的数 for (int i=0;i&lt;4;++i) out+=(ans[i]&amp;0xffffffff)+(ans[i]&gt;&gt;32); //最后统计答案，因为ans[i]是一个long long，所以要前32位和后32位分别统计 return out;&#125;int main()&#123; int i,l,r,x,aa[8]; scanf("%d%d",&amp;n,&amp;m); a=(int*)&amp;A; for (i=0;i&lt;n;++i) scanf("%d",a+i); while (m--) &#123; scanf("%s%d%d%d",op,&amp;l,&amp;r,&amp;x); if (op[0]=='M') modify(l-1,r,x); else printf("%d\n",query(l-1,r,x)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>黑科技</category>
      </categories>
      <tags>
        <tag>常数优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019THUWC/WC冬眠记]]></title>
    <url>%2F2019THUWC-WC%E5%86%AC%E7%9C%A0%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[又到了 Kanon 的季节呢，快乐的冬眠生活开始了_(:з」∠)_ Day 0/-8Day -1 被归到广二避寒记去了.. 上午在水群的时候吐槽 Kanon 结局，然后和 yfz 稍微聊了一下，又看了看萌百，的确あゆ就是和风子、面码差不多的思念体鸭，为什么我会觉得看不懂呢..大约不止是因为あゆ的存在？ 下午只做了一道题…淀粉质竟然能把 solve(rt) 写成 solve(v)…退役吧 然后不知道为什么去试了下自走棋，连续垫底了一下午，算是明示WC垫底了。 RNG居（guo）然连跪两把，继续暗示窝WC的命运。 Day 1/-7上午报到的时候没能和 BlackRedRabbit 面基，只不过试机的时候发现brr就在窝左边的左边的左边，然后就愉快的面基了。 哦对了，晚上跟 jxl 还有 hyf 住。好像是女生宿舍？被子是粉的..然而听说A栋住女生，B栋住男生，感觉不会特意反过来.. 试机题目T1（听别人说）是AC自动机上dp..本来就不会，AC自动机也几年没打过了…T2是THUSC2017提答，于是没做试机题，打了个NTT，还没一遍打对..丢人。 下午果然垫底了..T1一个简单 $12$ 分暴力打了 1h，然后 T2 的第一档 $26$ 分写了 1h 才过大（xiao）样例，交上去没过pt..然后又调了 50min，还是没过..然后花了 0.5h 重构代码，莫名其妙就过了..T3看了看感觉第一档都不会，回去看T2，T2是答对第一问有 $60\%$ 的分那种，发现自己会另一档的 $27\times60\%$，然后又花了 50min 写.. 最后 30min 的时候发现 T2 还有 $43\times 60\%$ 可以用可持久化并查集写，然而时间不够了… T2 第一次写了 6K…（菜死了连 6K 都没写过..）也是第一次用 namespace 写 subtask。 1234if (r&lt;=10&amp;&amp;c&lt;=10)&#123; using namespace subtask1;&#125; 这样写真的爽_(:з」∠)_ T1是道期望，输出格式是最简分数，而且不约分的话数会非常大。当时我就在想为什么不取模..然后出考场听说 T1 的式子有一堆可以约分，剩下的形式特别简单… 我的游记好像经常不写题目就瞎bb..还是简单说一下吧。 T1：给两个数列 $a_{1..n},\,b_{1..n}$，多组询问，每次给 $c,\,d,\,e,\,f$ ，需要从 $a_{c..d}$ 和 $b_{e..f}$ 中各取 $d-c+1$ 个数然后两两配对，问配对的两个数相同的对数的期望，以最简分数形式输出。$n$ 和询问数好像大约是 $10^5$ ，因为只打了第一档暴力不记得了… T2：一个网格图，有两种连边： 一整行/列两两连边。 一些特殊点之间两两连边。 有 $m$ 个被破坏的点，在某个时间点（每个被破坏的点独立）被修好，修好前所在行/列的整行/列连边不会连上。每个特殊点在某个时间点（每个特殊点独立）前不会和其它特殊点连边。多组询问问两个点联通的最早时间点，以及这个时间点的最短路。 网格大小 $10^5$，询问数 $10^6$，被破坏的点数和特殊点数都是 $2\times 10^5$。 T3：求有多少个不同的长度不超过 $m$ 的 区间取min操作序列 使得进行最后一次操作后原序列恰好变成指定序列。值域和序列大小一样都是 $n$。$n$ 好像是一两百的样子，$m$ $10^9$。 数据范围可能记错了，题意可能简述成看不懂了..QAQ就这样吧。 晚上开营仪式，先是清华系主任自吹，然后是广二校长继续吹+拉拢和THU的关系，然后请一个现在在THU的NOI2017Au爷上台念了篇游记…感觉那如果是篇游记还是写的挺好的，然而当众念出来..然后请了广二的一个妹子OIer 讲了一点，就结束了。 Day 2/-6今天是上午考试..T1是给你一棵树，每个点有 $a_i,\,b_i$，每条边有 $c_i,\,d_i$，$u$ 到 $v$ 的费用为 $\sum\limits_{i\text{ on path }(u,v)}\min(a_u+c_i,b_u+d_i)$，求每个点到其它所有点的费用之和。树大小 $5\times 10^5$，值域 $10^5$。开场先打了个暴力，然后感觉可以枚举每条边把树分成两半，然后就可以计算 $\sum\limits_{c-d&lt;b-a} c$ 和 $\sum\limits_{c-d\ge b-a}d$ 来做，然而一开始没想到怎么做。继续去想链的部分分，发现可以主席树，然后花了 $1.5h$ 过 pt。然后发现可以用线段树合并搬到树上，又花了 $1h$ 过掉 pt。在 THUWC 过 pt 还是挺爽的.. T2是道通过询问得到树的形态的交互，没仔细看… T3是给平面上一些点，定义“好的多边形”为取一些点构成的没有三点共线的凸四边形，求所有“好的多边形”的面积的平均值和方差，对 $998244353$ 取模。点数 $400$ ，值域 $10^9$。有个点在坐标轴上的部分分，然而WA了两个小时..至今不知道哪错了.. 中午回寝室发现两边隔壁寝室分别有 nzhtl1984 和 yyb..然而最后和 lk 面基了。 下午推了会儿 Kanon。 去吃晚饭的时候碰见了 pr 和 lk。 晚上是图像处理题： 任务一把 $B\times65536+A$ 看成 $A\times65536+B$，调了 20min… 任务二任务三也写的特别慢，最后任务四没时间了.. 三场加起来没别人一场高，whkwhk 最后离场的时候发现了这个： 那两个红红的桌面壁纸是今天的样例… Day 3/-5今天应该是我来广二之后最有趣的一天了，本来拍了一堆照片，录了一堆视频，还有一堆录音，好多想说的。可是记（gu）忆（gu）是个好东西，它会帮你筛去那些不重要的，留在脑海中的便是那些真正值得写的吧。 讲题Day2+讲题的时候听到最多的一句话就是“然后就可以跳到”….. 讲完之后还讲了一些关于图像的其它内容，比如把图片的某些 bit 异或一下来加密： D1T2的讲题是带动画的，非常有意思，虽然有一些录像，然而还是放几张图片凑合一下吧： 好像 ctr 还觉得 D1T2 可以放 NOIp T2T3 左右… 然后是什么 ”圆梦清华路上有力的援助“什么的… 反正讲题特别有意思。 扯皮下午是扯皮介绍THU的时间。 能发弹幕，所以现场特别欢乐。 先是介绍了算协，然后介绍了科协，然后是一个去年THUWC签约然后进队今年过来当工作人员的介绍自己这一年的经历，然后是一个人介绍了一下科研相关。 反正当时感觉超有意思的..然而不太记得算协具体讲了啥了..科协讲的就记得智能体大赛..那位神仙 lzj 讲的倒记得比较清楚。大约是说他签约后写了个光线追踪的工程，然后写了个“二维屁股守望”还现场演示了，之后还去参加了智能体（注意他现在才高三..）。科研相关的讲的非常科研，可能是比较硬核而且互动/玩梗不够，当时现场也不太活跃，弹幕都没什么人刷… 结营感觉贵系招生主任的演讲水平真的超棒..弹幕都能迅速地扯到相关话题并且立刻扯回原本的主线，衔接自然流畅，感觉可以去当主播。 中途提了个问题，问我们为什么选择OI。 有回答“不想上文化课”“不想高考_(:з」∠)_”的，有回答“因为兴趣（略略略”“好玩”的，有回答“希望在有生之年解决曾经无法解决的问题”的，也有回答“能结识好多厉害的同学！”的。可能大多数人都是如此吧。因为兴趣开始，时而有宏大的理想，时而又为现实所迫，最后才发现不是自己菜，而是结识了越来越多越来越强的同学们。 约咕咕了一个小时才发，窝自然是没有的，pr签了，lk签了，yyb签了，nzhtlshadowice1984签了，joker签了，窝认识的都签了。 一天下来那么多的感想竟然短短几行就写完了呢…遗憾没有拍到的照片也只是和其它拍到了的照片一样没有被放上来。 Day -4今天早上一起来就是愉快的卷铺盖走人，虽然路程比去 THUWC 的时候近（从“苏元”（好像是初中部？）到“二高”），然而要搬被子床单什么的..分了两趟搬QAQ 然后颓推了一天一会儿Kanon，魔芋的翻译真有意思： 报到的时候有个签名墙，中午和晚上各拍了一张，晚上的比较全（废话），然而中午的拍的比较清楚，所以都放上来好了.. 看到窝写的 &lt;font color=&quot;grey&quot;&gt;ouuan&lt;/font&gt; 了吗qwq 晚上是开幕式，掌声最热烈的有两个地方。 第一个是广二的一个妹子OIer的演讲：“OI到底在学什么？班主任眼中最会修电脑的一批人，旁人眼中前途一片平坦通向美好未来的道路，同班同学眼中那个经常消失不知道去哪的神秘人”，“OI 已不只是一个竞赛，也不只是一门学科，而是存在于群聊中一句句 Orz 和三个百分号里，存在于看到十的九次方加七时的熟悉感以及看到 998244353 时的心里默默的波动中，抑或是一步步化难为简，最终得出正解的喜悦，也可能是自闭场后一个人独自惆怅的身影”。 第二个有js风险，所以..： 当NOI科学委员会主席念到“WC性价比高”的时候（copy这行） Day -3~0自闭。 放几张图好了。 把汐里线（推了游戏之后更喜欢这个翻译了..和香里也有姐妹的感觉）推完了。算是理解了为什么汐里的“名言”是“起きないから奇跡って言うんですよ”，这句话有好几层意思，光是看动画不会明白的吧..也稍微明白了“梦境”与“第三个愿望”是怎么回事了。虽然还是不完全懂..（都是不合理的，好像也没什么“完全懂”） 第二场营员交流上 yfz 和 mcfx 讲的指令集真好玩。 Day 1打铁。 开场先写了 $T1$ $34$ 分，一出考场就听说自己挂了 $8$ 分。 然后去想 $T3$ 交互，发现不会做，先把强制数据分治的 $13$ 分写了，调了一会儿，继续想 $O(n^2)$。 感觉不会，这时候已经过去 $3.5h$ 了（鬼知道前面那点分为什么写了这么久..），去玩 $T2$ 提答，前面 $60$ 分还是很好写的，然后作死的想了一会儿第四个点，发现不会，已经只剩 $0.5h$ 了。 问题是我这个时候还在想 $T3​$ 的 $n^2​$ 怎么写…最后 $15min​$ 的时候决定写个随机询问打表对照，直接随便打了个表都没有检查结果是否两两不同，本来还把原来的代码复制了一份，最后 $1min​$ 写好的时候竟然把代码复制回去编译的..随手输了个数据，一测，既不是 correct 也不是 incorrect，然后就考试结束了..估计连那 $13​$ 分一起没了，爆零了。 写了的分：$34+60+44=138$，Cu/Ag。 估分 at 考试结束前 $15min$ ：$34+60+13=107$，Cu。 估分 of 考试结束前 $15min$ ：$26+60+13=99$，Fe/Cu。 考试结束后的估分：$26+60+0=86$，Fe。 保底估分：$18+38+0=56$，Fe。 最高可能得分：$26+60+44=130$，Cu/Ag。 Day 1.5虽然只有下午+晚上，然而发生了好多事鸭。 先是 GGF 把选手复读复测鸽到了讲题开始之后.. 然后窝去看成绩，$T3$ 竟然没挂（$13$），然而 $T2$ 的第二个点莫名挂了..仔细看了半天都是对的，问别人也是对的，群里更有趣了，$O(1)$ 的题目 $O(n)$ 做法有 $0,\,6,\,20$ 分的..然后找到了工作人员，咕了一会儿之后帮我重测过了..然后去申诉，还不知道能不能加回来。讲题没去听..听了也是自闭。 OIer真能搞，说搞就搞出来了一个文艺汇演。 LCA nb！Joker nb！大连24 nb！zzt nb！ 感觉这一晚上更加了解 OI 了。要变得更强，和更强的人在一起，去喜欢正确的事情，再用尽全力去喜欢自己喜欢的事情。 完整版文艺汇演录制今晚压制出来，大约要回武汉之后才能传到b站上。 Day 2上午去科学中心冬眠。在车上用 zar 的热点把文艺汇演传了。 下午听说 $T2$ 重测了，然后窝莫名 Ag 了.. 这场 WC 好像是暴力 Au，只要 $127$ 分，然而窝暴力没打满，又疯狂挂分，只好滚粗了.. 另外好像人人都有一枚铁牌。 睡前看了两集《比宇宙更远的地方》。 Day 3上午看了两集《比宇宙更远的地方》，然后去火车站。发现竟然和 PinkRabbit 一辆（去火车站的）车。 中午吃了干拌面（来火车站之前买的），然后有个卖方便面的小哥让我们帮忙把方便面看着，他去上个厕所。$20min$ 后，他从厕所出来，去问 ylh 在玩什么游戏： 本来想对广二说 さようなら 的，想了想应该是 またね 。 感觉 cl 中渚对朋也说的那句“离开的时候一定要是笑着离开的，不然就再也回不来了”莫名可以用在这里。]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>CCF系列赛事</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UER #8 —— 通信题：打雪仗]]></title>
    <url>%2FUER-8-%E6%B8%B8%E8%AE%B0-%E2%80%94%E2%80%94-%E9%80%9A%E4%BF%A1%E9%A2%98%EF%BC%9A%E6%89%93%E9%9B%AA%E4%BB%97%2F</url>
    <content type="text"><![CDATA[T1题目链接 大意：Alice 有一个长度为 $2n$ 的 $01$ 串 $s_{1..2n}$，Bob 有 $n$ 个下标 $p_{1..n}$，Alice 和 Bob 只能用 $01$ 通信，需要在每人各 $m$ 个 bit 内使 Bob 输出 $s_{p_1..p_n}$ . $n=1000, m=1350$ Part 1 通信题 只是说一下我做了这道题后对通信题的理解，可能有误。 赛时：通信题是啥？？？作为一个从未做过通信题的选手，遇到这题自然是百度了一下“通信题”。如果你尝试一下，会搜到《移动通信试题库》。 尝试搜索 “通信题 OI”——OI是什么意思? - 问通信专家；”通信题 CSDN”——通信原理考试题-CSDN下载。 ok，只能自己看样例程序了。 于是我比赛的第一个小时就在对着样例代码懵逼中度过了….. 然后发现我sb了，忘记了一件事：标准输入是会等待输入的！ 可能是我 OI 题做傻了，以为输入一定要一连串不停地输入…导致我一直没有理解为什么两个程序之间可以来回通信… （上面那段话纯属我sb了，请跳过不看） 通信题是……根据我的理解，通信题就是：两个程序，分别从文件读入数据，从标准输入读入另一个程序的标准输出。最后其中一个程序按要求输出到文件。 （好像跟题面描述的差不多…） 那就说说我sb了而卡住的地方好了..一个程序 getchar() 的时候会暂停执行，直到另一个程序输出，就跟手动输入数据时等待回车一样。 关于调试广二机房是 win7，不太方便复制… 于是只好手动输入了，只不过感觉 copy 两个程序的输出看它们相互配合着工作，还是蛮有趣的。 Part 2 解法其实我 $5min$ 就想到怎么做了..（但好像做法比最短解那些神仙做法麻烦的多？）其实也不是很难写，但由于第一次写通信题不太习惯，各种细节写挂，最后写了一个小时才A… 解决问题可以想到这样一个做法（如果想不到也没关系..看懂就好了）：选择一个区间 $[l,r]$ ，Bob 用一个长度为 $r-l+1$ 的 $01$ 串告诉 Alice 这个区间内每个位置是否是一个下标，对于每个下标 Alice 告诉 Bob 对应的值；对于不在 $[l,r]$ 内的其它部分，Alice 把所有值（不管是不是一个下标）都告诉 Bob . 优化通信数考虑一下，这样做需要的 bit 数是多少： Bob 给 Alice 的：首先 Bob 要告诉 Alice $l$ 和 $r$ , 用二进制表示，需要 $22$ 个 bit；其次，Bob 要询问 $[l,r]$ ，需要 $r-l+1$ 个 bit 。 Alice 给 Bob 的：首先 Alice 要回答 Bob 在 $[l,r]$ 内的询问，需要 “ $[l,r]$ 内下标个数” 个 bit；其次，Alice 要告诉 Bob 除了 $[l,r]$ 其它区域的所有值，需要 $n-(r-l+1)$ 个 bit 。 那么，我们需要最小化：$\max(r-l+23, [l,r]\text{ 内下标个数}+n-r+l-1)$ 。 用 $[l,l+len)$ 来表示会简洁一些，所以下文都使用这种方式，即需要最小化：$\max(len+22, [l,l+len)\text{ 内下标个数}+n-len)$ 。 预处理前缀和即可快速算出 $[l,l+len)$ 内的下标个数，$O(n^2)$ 枚举区间取最小值即可。 参考代码Bob1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;ifstream fin("bob.in");ofstream fout("bob.out");char rd() //读入一个bit&#123; return getchar();&#125;void wt(int x) //输出一个bit&#123; putchar(x+'0'); fflush(stdout);&#125;int n,m,p[1010],rk[4010],pre[4010],minn=0x7fffffff,l,len;char ans[1010];int main()&#123; int i,j,t; fin&gt;&gt;n&gt;&gt;m; for (i=1;i&lt;=n;++i) //读入并记录是第几个下标（便于存答案），并且复制一份拼在后面，这样如果询问的区间跨过首尾可以方便地处理 &#123; fin&gt;&gt;p[i]; rk[p[i]]=rk[p[i]+2*n]=i; &#125; for (i=1;i&lt;=4*n;++i) //预处理前缀和 &#123; pre[i]=pre[i-1]+(rk[i]&gt;0); &#125; for (i=1;i&lt;=2*n;++i) //枚举找最优方案 &#123; for (j=1;j&lt;=2*n;++j) &#123; t=max(pre[i+j-1]-pre[i-1]+2*n-j,j+22); if (t&lt;minn) &#123; minn=t; l=i; len=j; &#125; &#125; &#125; for (i=10;i&gt;=0;--i) //告诉Alice l和len &#123; wt(bool((1&lt;&lt;i)&amp;l)); &#125; for (i=10;i&gt;=0;--i) &#123; wt(bool((1&lt;&lt;i)&amp;len)); &#125; for (i=l;i&lt;l+len;++i) //询问区间 &#123; if (rk[i]) &#123; wt(1); ans[rk[i]-1]=rd(); //存答案 &#125; else &#123; wt(0); &#125; &#125; for (i=l+len;i&lt;l+2*n;++i) //读取剩余部分 &#123; if (rk[i]) &#123; ans[rk[i]-1]=rd(); &#125; else &#123; rd(); &#125; &#125; fout&lt;&lt;ans; return 0;&#125; Alice12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;cstdio&gt;using namespace std;ifstream fin("alice.in");int rd() //为了方便，两个程序中rd()和wt()的char/int是反的&#123; return getchar()-'0';&#125;void wt(char x)&#123; putchar(x); fflush(stdout);&#125;int n,m;char s[4010];int main()&#123; int i,l=0,len=0; fin&gt;&gt;n&gt;&gt;m&gt;&gt;(s+1); for (i=2*n+1;i&lt;=4*n;++i) //复制一遍放在后面 &#123; s[i]=s[i-2*n]; &#125; for (i=0;i&lt;=10;++i) //读入l和len &#123; l=l*2+rd(); &#125; for (i=0;i&lt;=10;++i) &#123; len=len*2+rd(); &#125; for (i=l;i&lt;l+len;++i) //回答询问 &#123; if (rd()) &#123; wt(s[i]); &#125; &#125; for (i=l+len;i&lt;l+2*n;++i) //告诉Bob剩下的部分 &#123; wt(s[i]); &#125; return 0;&#125; Part 3 证明取询问区间为 $[l,l+1318]$ ，这样的话 Bob 发给 Alice 的 bit 数就为 $1319+22=1341$ . 区间 $[l,l+1318]$ 内下标的期望个数为 $\frac{1319}2$ ，所以一定存在某个区间使得下标个数小于等于 $659$ ，再加上剩余部分 $681$ ，Alice 发给 Bob 的 bit 数就为 $1340$ 。 事实上，我提交的评测记录里通信次数最多的就是 $1341+1340$ 。 Part 4 优化只取 $len=1325$ ，少枚举一维，可以优化到时间复杂度 $O(n)$ ；少传 $11$ 个 bit，可以优化到最大通信次数 $1336+1337$ 。证明从略。 提交记录]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>UOJ</tag>
        <tag>通信题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随机生成图片展示]]></title>
    <url>%2F%E9%9A%8F%E6%9C%BA%E7%94%9F%E6%88%90%E5%9B%BE%E7%89%87%E5%B1%95%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[传送门 源码按F12即可查看（当然也可以在 repo 里面看） 看到一个帖子里提到了一个140字符画图比赛，看到了 Martin Büttner’s code ，然后就随便写了一个. JavaScript 都是要用啥现场百度… 已经更新了（存档？）功能，在地址栏后以 ? 开头 &amp; 分隔即可输入参数。例如：https://ouuan.github.io/randpic/generator/?width=512&amp;height=512&amp;blocksize=75&amp;qwq=2&amp;minred=100&amp;maxred=255&amp;mingreen=100&amp;maxgreen=255&amp;minblue=200&amp;maxblue=255&amp;minalpha=0&amp;maxalpha=255 下面是一些图片（附有参数链接）：]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>HTML/JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Avito Cool Challenge 2018 游记]]></title>
    <url>%2FAvito-Cool-Challenge-2018-%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[这两天比赛是真的多..碰上了场 Chinese Legends Round / HackForces 竟然在紫名涨了点分QAQ 看到 A，$gcd(x,x-1)=1$ ，这不是sb题吗？然后愉快地WA了…互质 $\ne$ 不为倍数鸭QAQ还有 $1$ 呢.开场-50分.. B貌似比C难，但A的人比C多..其实当时交的时候还没想清楚 $p$ 个一样的人数是 $p$ 的倍数这个结论，就感觉好像是对的，就交了。 C 很快就想到了结论，排列组合乘一乘随便做，而且数据范围小到可以用杨辉三角算组合数+不用快速幂。 D 感觉要搞个MST，然后就真的先搞了个MST，然后就没有想到简单的解法..正解是MST搞完所有关键点就不搞了。一开始写挂了，然而pt特别水（好像直接输出MST最大边就可以），A完E之后看到jason的D被叉了，就仔细看了下，发现自己写挂了..然后重交，少了 $400$ 多分。 E 贪心搞一搞就行了，据说ylh没有做出来是忘了积一定差越小和越小.. F 看了看感觉不会，于是锁了 D 开始叉人。看到room rank1的正解感觉自己整个人都sb了..在离比赛结束 $5$ 分钟的时候看到一个感觉写挂了的，然而不敢hack，于是一直盯着看，直到离比赛结束还有 $1$ 分钟的时候才hack，然而一不小心把数据打错了..幸好格式错误不扣分，赶紧点回去重新hack，最后在离比赛结束 $4s$ 的时候提交了hack，然后绿了！喜提 $100$ 分、$50​$ 名。 当时比赛一结束我就跟 ylh 说我感觉如果我不 fst能再涨 $100$ 名，然后最后真的又涨了 $100$ 名.. B和D一堆fst的。 F 用奇偶性判断选择的哪边，感觉很妙。 G 没仔细看。 H： and we didn’t except anyone to pass. 不知道会在紫名待多久QAQ]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>CodeForces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF edu 56 & AT Grand 029 游记]]></title>
    <url>%2FCF-edu-56-AT-Grand-029-%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[今天 AT 和 CF 刚好连上了，于是就都打了一下。 关于模板今天心血来潮把用于在线比赛的模板换了一下，加了点东西，然后发现 rep(1,l,r) 写起来非常不顺手..保留了部分比较好用的。 测试的时候忘记开数组了（都是些什么sb错误），然后以为 ll 不能作下标，于是没有 #define long long，然后 CF 挂惨了.. AtCoder上一场打的 Beginner，这场难度正常多了。 A 是个值域为 $2$ 的逆序对.. B 用 multiset 乱搞了一下，对于每个数枚举组成的数，然后从大到小匹配，不知道是不是正解，反正过了，而且是 $log^2$ 的。 C 感觉挺可做的..可能有细节没调出来，赶着回酒店打 CF 就没有继续调了.. D 一开始还在想博弈论完全不会..然后仔细看了一眼，如果 A 不走，B 就会不走，就结束了；所以 A 一定能走则走。然后就随便做了。 只不过 AT 的 rating 真的涨的好快.. CodeforcesABC 三道 spj ？？？ 都是随便构造就能做的.. 然而 C 一开始忘开 ll 了….. D 黑白染色一下，连通块内两种节点分别有 $a$ 个和 $b$ 个答案就是 $2^a+2^b$ ，把每个连通块的答案加起来就好了。 由于 $O(nq)$ memset 会爆掉，不能 memset 整个数组，于是愉快地在开了 ll 的情况下 memset(…sizeof(int)…)；发现了之后不小心把开 int 的另一个数组也改成 memset(…sizeof(long long)..) 了.. 开场 $40$ 分钟的时候这 $3$ 个关于 ll 的罚时让我排名翻了三倍… 于是，A 了 D 之后我就在板子里加上了 #define int long long。 看了会儿 E 不会做，然后一看 standing，惊奇地发现 G 有一堆（$15$ 个，当时 E $7$ F $1$）人 A 了，然后一看，就是POJ 2926+动态RMQ… 感觉自己几年没有写过普通线段树了（最近写的全是平衡树/动态开点线段树），写了半个多小时还写错了..毕竟是 CF，应该去复制个模板才对的…一交，MLE 了，woc我好不容易#define int long long了就是这个结果？？改成 int，跑了 $5.4s$，巨方，于是手动开了 O3，$4.8s$ ，但重交竟然没有罚时。应该去找个 BIT 动态求 RMQ 的模板的… 看到 halyavin 参赛了，感觉自己要 fst ，赶紧把博客写了睡觉去。 UPDhalyavin 竟然没有 hack…然而 D 有一堆 memset 整个数组的，我也去 hack 了一个（edu hack $\sqrt{}$）。 没有 fst，第一次 A $5$ 题，上 $2k$ 了，感觉海星。 UUPD题解 CF1093D 【Beautiful Graph】 题解 CF1093G 【Multidimensional Queries】]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>CodeForces</tag>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html实现随机图片]]></title>
    <url>%2Fhtml%E5%AE%9E%E7%8E%B0%E9%9A%8F%E6%9C%BA%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[注：暂时还不知道如何制作能被引用的随机图片，只能查看图片，而不能通过类似于![](图片地址)的方式查看。 demo 欢迎投稿图片：投稿地址 核心代码12345&lt;script type="text/javascript" src="imagelist.json"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var r=Math.floor(Math.random()*images.length) document.write("&lt;img src="+images[r]+"&gt;")&lt;/script&gt; 图片列表保存在 imagelist.json 内。 参考示例https://ouuan.github.io/randpic/people/index.html： 123456789101112131415161718192021&lt;html&gt; &lt;head&gt; &lt;script type="text/javascript" src="imagelist.json"&gt;&lt;/script&gt; &lt;title&gt;随机图片-人物类&lt;/title&gt; &lt;link rel="icon" type="image/png" sizes="32x32" href="/images/favicon32.png"&gt; &lt;link rel="icon" type="image/png" sizes="16x16" href="/images/favicon16.png"&gt; &lt;style&gt; img &#123; width: 100%; height: auto; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript"&gt; var r=Math.floor(Math.random()*images.length) document.write("&lt;img src="+images[r]+"&gt;") &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; https://ouuan.github.io/randpic/people/imagelist.json： 123456789101112131415161718192021var images=[ "https://z4a.net/images/2018/12/12/70469686_p0.png", "https://z4a.net/images/2018/12/12/69212051_p0.jpg", "https://z4a.net/images/2018/12/12/64660644_p0.jpg", "https://z4a.net/images/2018/12/12/61438972_p0.jpg", "https://z4a.net/images/2018/12/12/60141148_p0.png", "https://z4a.net/images/2018/12/12/1200296-20170715113653118-1762611401.jpg", "https://z4a.net/images/2018/12/12/71631241_p0.jpg", "https://z4a.net/images/2018/12/12/f0Q5-g62pXkZ5lT3cS1hc-rs.jpg", "https://z4a.net/images/2018/12/12/36224612_p0.jpg", "https://z4a.net/images/2018/12/12/64702477_p0.jpg", "https://z4a.net/images/2018/12/12/64670588_p0.jpg", "https://z4a.net/images/2018/12/12/61815260_p0.jpg", "https://i.loli.net/2018/12/12/5c10a02b0831b.jpg", "https://i.loli.net/2018/12/12/5c1119665c83a.jpg", "https://i.loli.net/2018/12/12/5c111a8bed8e8.jpg", "https://i.loli.net/2018/12/12/5c111ab43f7cf.jpg", "https://i.loli.net/2018/12/12/5c111ade38590.jpg", "https://i.loli.net/2018/12/12/5c111b8240591.png"] UPD研究了一下 js 后写了一下图片缩放：（代码很丑，毕竟是靠百度学了一个小时写出来的）（大括号不换行是因为sublime缩进写着写着就炸了，只好在网上格式化了一下） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107&lt;html&gt; &lt;head&gt; &lt;script type="text/javascript" src="imagelist.json"&gt; &lt;/script&gt; &lt;title&gt; 随机图片-人物类 &lt;/title&gt; &lt;link rel="icon" type="image/png" sizes="32x32" href="/images/favicon32.png"&gt; &lt;link rel="icon" type="image/png" sizes="16x16" href="/images/favicon16.png"&gt; &lt;/head&gt; &lt;body style="margin: 0px; background: #0e0e0e;"&gt; &lt;script type="text/javascript"&gt; var cur = 1; var xx = 0; var yy = 0; var rx = 0; var ry = 0; var nw; var nh; var mw; var mh; var w; var h; function setSize() &#123; if (cur == 1) &#123; var p = document.getElementsByTagName("img")[0]; nw = p.naturalWidth; nh = p.naturalHeight; mw = window.innerWidth; mh = window.innerHeight; if (nw &gt; mw || nh &gt; mh) &#123; p.style = "cursor: zoom-in"; &#125; else &#123; p.style = "cursor: auto"; &#125; if (nw * mh &gt; nh * mw) &#123; h = nh * mw / nw; w = mw; &#125; else &#123; w = nw * mh / nh; h = mh; &#125; p.style.width = w; p.style.height = h; p.style.marginTop = (mh - h) / 2; p.style.marginLeft = (mw - w) / 2; &#125; else &#123; if (nw &gt; mw || nh &gt; mh) &#123; p.style = "cursor: zoom-out"; &#125; else &#123; p.style = "cursor: auto"; &#125; &#125; &#125; function picLoaded() &#123; setSize(); window.onresize = function() &#123; setSize(); &#125; &#125; function BigSmall() &#123; mw = window.innerWidth; mh = window.innerHeight; if (nw &gt; mw || nh &gt; mh) &#123; if (cur == 1) &#123; cur = 2; var p = document.getElementsByTagName("img")[0]; p.style = "cursor: zoom-out"; var e = event || window.event; mw = window.innerWidth; mh = window.innerHeight; if (nw * mh &gt; nh * mw) &#123; h = nh * mw / nw; w = mw; &#125; else &#123; w = nw * mh / nh; h = mh; &#125; if (nw &lt;= mw) &#123; xx = (mw - nw) / 2; rx = 0; &#125; else &#123; xx = 0; rx = (nw - mw) * (e.clientX - (mw - w) / 2) / w; &#125; if (nh &lt;= mh) &#123; yy = (mh - nh) / 2; ry = 0; &#125; else &#123; yy = 0; ry = (nh - mh) * (e.clientY - (mh - h) / 2) / h; &#125; p.style.marginTop = yy; p.style.marginLeft = xx; document.body.scrollLeft = rx; document.body.scrollTop = ry; &#125; else &#123; cur = 1; setSize(); &#125; &#125; &#125; var r = Math.floor(Math.random() * images.length); document.write("&lt;img src=" + images[r] + " onload=\"picLoaded()\" onclick=\"BigSmall()\"&gt;"); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>HTML/JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018~2019冬 广二避寒记]]></title>
    <url>%2F2018-2019%E5%86%AC-%E5%B9%BF%E4%BA%8C%E9%81%BF%E5%AF%92%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[迎风迈出的步伐更艰难，即使走的不远，但踩得更深。一代人只能做一代人的事，完成这个时代赋予的使命就是英雄，大地也会将他的脚印铭记。 ——乒乓帝国（句子迷上说是《孤杂记》..） 突然就得知了要去广二集训。 然后知道了这次出去可能要一直到 WC，差不多有 $50$ 天。这样一算这个学期我在武汉的时间可能和外出的时间一样多了。 毕竟是去广州，会暖和很多，也许看不到武汉的雪了。 Day 0Railway在站台上遇到了 Dew、ylh，感觉自己活尸化严重，都是我妈先看见的… 中午吃了泡面（有汤的那种），之前出去都比较近，在火车上不用吃饭，印象中上次吃方便面还是初三的时候在学校里吃的（桶装的泡面，愣是被我当成干拌面吃的）。 在火车上看看手机、看看《大卫·科波菲尔》，当然我现在在写博客。 途中看到了一幅非常………..ok我承认我词穷了。云很低，好像不比火车高多少，环绕在山的周围，山脚下是一些平房，在远处插入了几栋现代化的高楼大厦，有一种违和却奇妙的美感。 赶紧掏出手机，可毕竟只是手机，拍不出云那种虚无缥缈的立体感，匆忙中也没能选好角度，没拍到那几栋高楼大厦。 已经逝去了，经纬度也没有记下来，不能在回来的火车上再览其景，只能用粗浅的文字将其略微地记录下来罢。 Underground进地铁前忘记上厕所了Orz 和 ylh 一起体验了一次换票出站上厕所。 然后是 huangbei 站： 人特别多，特别热。毕竟是来避寒的 Restaurant和广二的教练谈了谈人生，建议我和 ylh 先系统地学知识点，不着急打套题，结果 dew 想先学知识点，我和 ylh 想在广二做题.. 然后就是住宿的事，貌似准备先住两个星期三人间，等 ylh 回去了就去教练家里住（教练一个星期只回家一天）。今晚是先各自和家长住双人间。房号 1216. Day 1上午教练咕咕了，中午才来接我们。 然后让我们不着急打比赛，给我们三个人安排了个机房做题。 $5$ 道左偏树，派遣、罗马游戏和Joint Stacks比较轻松地做出来了；Sequence看了看题解，感觉还没完全搞懂，但A了；魔法猪学院用A*在广二的OJ和BZOJ上过了，暂时放弃可持久化左偏树，以后再学吧.. 山、河、树（不只是路边那种）（当然也不是可持久化那种），游泳池，令人联想起 Angel Beats! 的食堂，各式各样的社团活动。 Day 2-3把题目列表搞到了洛谷团队里. 搞了搞平衡树、启发式合并之类的，感觉自己啥都不会.. 搞了个随机图片 。 Day 4一天就写了[NOI2004]郁闷的出纳员和LCT模板… 然后搞了个stylus插件：洛谷犇犇、讨论隐藏。 果然整天待机房效率低. Day 5上午听隔壁机房的讲了下回文自动机、后缀数组、后缀自动机，但由于手头上的题还没搞完就没做相关的题目。 [NOI2005]维护数列做了好久..本来操作就多，取的子段还不能为空… 然后学了下LCT。 Day 6-7就做了几道 LCT 的题…学了学虚树，还没做题。 然后这几天比赛挺多的，at+cf 还有洛谷比赛。感觉洛谷比赛都挺dl的… 然后今天看了几篇vfk的博客，感觉都写的挺好的。 里面提到了CFctr的自我修养，感觉以后出题时要牢记（虽然里面有些是只适用于CF的）： 准备一场CF包括：题目、比赛通知、题解。 你的题目必须是独一无二的。你不能从以前用过的题目中抄袭它的想法。PLEASE BE FAIR WITH THE COMMUNITY。（ 空间限制必须是256MB，时间限制至少是出题人的java程序运行时间的两倍。 题面必须清晰好懂，没有语法错误。建议写得短短的…… 题目背景中不要写数据范围，全部都要写在输入格式里。 请参考以前CF的题目描述的格式来写题目描述。如果你不知道怎么清晰地描述输入输出格式，请找与之类似的题目进行仿写。 题目描述中的数组下标最好从1开始。 你必须限制被你提到的所有的变量的范围。如果你提到一个字符串，你必须写明哪些字符可以出现在这个字符串内。 题目的tests中必须包括各种各样的数据，而且应该有各种各样的达到最小数据范围的数据和达到最大数据范围的数据。也就是说如果1 &lt;= n &lt;= 100000，那么数据中既应该有n = 1，也应该有n = 100000。 你应该写个暴力。 你应该拿标程与暴力对拍。 Div.2的题的pretests要很强，能让应该超时的程序在pretests上就TLE掉。但是你可以让这个点毫无意义。比如给n个数排序，你可以用n个1来确保选择排序不能过。 确保读错题的人不能过pretests。 建议添加极端数据，但是不必是所有极端数据。确保数组开小的人不能过pretests。 不要让时间复杂度很高但做了大量常数优化的人AC。 每道题至少2个样例。每道Div.2的题目的前两个样例必须有样例解释。 如果要使用long long，请确保不开long long的人不能过pretests。 哦对了，自定义域名总是炸，以后这个博客就用 ouuan.github.io 作为地址了。（正好避免了一年后域名到期的问题） Day 8今天好像啥都没干..估计是每天都没睡好导致白天效率低下.. 好像看了好几篇淀粉质的教程，但就是不想写题.. 和 memset0 讨论关于保留几位小数与精度限制的问题..感觉其他人总是不能轻松地理解保留几位小数是卡精度的… 翻译了CF的几道题，写了写题解。 继续yy自己口胡的题的优秀做法，依然没什么进展。 跟 Sooke 说了说自己出 CF 的想法，Sooke 表示想一起出，然后在还没想好一道题的情况下大谈怎么出 CF.. 说实话出 div.2 的话会有些不甘，哪怕晚点也想出 div.1+div.2 的.. 第一次用洗衣机，感觉洗衣机真有趣 （好像暴露了我一周没洗衣服…） （hexo 貌似不支持行内图片？） Day 9搞了个 随机生成图片 ，感觉自己自从用了 Hexo 日益由 OIer 变成码农了。 Day 10-11这几天忙着搞比赛，博客可能咕咕咕了..准备比赛记大约会在比赛出来之后发QAQ. Day ?-?咕咕咕咕咕咕咕 Day 14广二先是四楼停电，用了一上午笔记本，准备回酒店的时候门卫告诉我们电来了，然后回去一看发现四楼没电三楼有电。下午突然就又停电了，幸好我和 dew 都没有在写代码.. ylh 走了，然而住教练家被咕咕了，好像是因为又来了几个外省的。 新酒店..发几张图感受一下吧： 没错 p3 是 dew 在吊椅上 然而不敢对着 dew 拍… wifi 特别神仙： 被夹在了一个没有 wifi 的世界里.. 然后貌似明天还是什么时候开始要打比赛了，然后这篇游记就不会继续真的成“游记”了。 Day 15今天是集训队爷 zjt 出的 集训队互测。 T1 一道带权带花树好题的确是带权带花树裸题（求一般图最大权值匹配），然而不需要输出方案。 虽然说 OI 题名无正解，然而我还是百度了一下..然后学了一个半小时带花树，没学会！ 然后再一看，$n\le20$ 不会做？ 只好写了二分图的 $20$ 分滚粗.. 然而发现一个严重的问题，这貌似是我第一次写二分图最大权值匹配..百度了一下，发现全是KM算法，没有一篇费用流？然后仔细想了好多遍，感觉费用流应该没问题，就写了。然而一开始写挂了（连图中的边时没判哪个点是起点），幸好后来发现了。 后来听说这题 std 是一个线代做法，由于不用输出方案码量非常小。具体可以参考2017年集训队论文。然而看不懂鸭… 这题不卡随机化乱搞.（嘤嘤嘤？） T2 一道拉格朗日反演好题看到 T1 真的是一般图最大权值匹配的我真的信了题名的鬼话.. 一个 $01$ 序列，初始为空，有三种操作： 往末尾加个 $0$ . 删掉一个子序列，包含 $x$ 个 $0$ ，$y$ 个 $1$ ，然后往末尾加个 $1$ 。其中 $x\in A$ 。 删掉一个子序列，只包含 $x$ 个 $0$ ，然后往末尾加个 $1$ 。其中 $x\in B$ 。 $A$ 和 $B$ 还有操作总数 $n$ 是给你的，让你求 $n$ 次操作完成后序列长度为 $1$ 的方案数。 一开始还以为只用管 $01$ 分别的个数，后来才发现选的子序列位置不同也算不同的方案… 数据范围：いいよ,こいよ $114514$ 不太会做，好像是转化成一个树上的 dp，然后再算一波式子，分治FFT/牛顿迭代？ 不得不说样例十分lx： 12310 10 100 1 2 3 4 5 6 7 8 90 1 2 3 4 5 6 7 8 9 1362880 愉快地拿到了 $|A|=|B|=n$ 这档部分分。 T3 一道 Top cactus 好题仙人掌上 $q$ 次询问求经过某个点的路径贡献之和。模 $998244353$。“不在简单环上的边数”为 $x$ 的路径贡献为 $v_x$ 。 部分分第一档，树，$n\le2000$ 。 woc我只会 $O(n^3)$ .. 冷静了一下，发现可以枚举路径树上差分.. 愉快地拿到了这 $10$ 分。 正解好像是淀粉质+NTT。然后搬到圆方树上去。 总结队爷出的题就是神仙..之前一直感觉多项式看起来没啥用？请julao们看到这句话别打我..感觉很有必要早点去学多项式全家桶了。 另外题名里的算法真的 $99\%$ 不可信。 另外由于打比赛换了个机房，貌似机房里都是一些外省的？ OIer居然是可以有npy的！ Day 16yww咕咕了，myh出的题。这场题面太赞了！据说题意不清被吐槽的很厉害，但我貌似还是第一次碰见YNOI型题面，背景是自己看过的番，题意瞬间理解。 这场还有个有趣的地方，T1 和 T3 的 subtask 一开始放反了，而且 T3 的变量 T1 都有，于是我比赛开始 $2h$ 才发现..（当然我发现的时候已经改回来了） T1 青春野狼不做理性小魔女的梦题意简述，题目背景太棒了，所以我要题面简述。 在咖啡厅，双叶不说话，只是推给了你一张纸，上面写着一个不定方程： $A_1x_1+A_2x_2+\cdots+A_kx_k\equiv1\mod m$，然而其中的一些 $A_i$ 被咖啡打湿了，需要给被打湿的 $A_i$ 们赋值（$A_i\in[0,m)$），使得不定方程有整数解；同时，双叶也不记得 $m$ 是多少了，所以要求 $m\in[1,n]$ 的方案数之和。$1\le k\le50,1\le n \le10^9$。 大约想到怎么做了，然而感觉无法实现（事实是正解要用杜教筛），会写的特别麻烦复杂度还不对，于是就只打了 $k\le5,\,n\le10$ 的暴力和没有数字被打湿的分。然而后面那档挂了，因为求区间内与某个数互质的数个数时没有容斥，最神奇的是拍半个多小时没拍出来… T2 青春野狼不做姐控偶像的梦和花给麻衣的信很有规律，她写的信是一个 $1$ ~ $n$ 的排列，一段连续的信能给麻衣鼓励，当且仅当它的值也连续（noi.ac的whzzt邀请赛里把这玩意定义为“广义排列”，意思就是一个区间， $max-min=r-l$ 且没有重复的数），麻衣想知道如果只保留一段连续的信，她能收到多少鼓励（就是多组区间询问）。 其实..就是 CF997E Good Subsegments.. 千古神犇wxh log碾标算！lxctr myh n^2 送温暖！嗯，我拿了 $O(n^2)$ 的 $20$ 分… 做法参考 zzq的评论 T3 青春野狼不做小恶魔学妹的梦这道题题面写的最好！（貌似也被吐槽的最惨） 对学长的思念，深埋于心底。 难以表达。 与学长的记忆分为 $n$ 个部分，两个不同的部分间可能会有一种关系，也可能没有。 可是我知道，它们藕断丝连，注定联通。 想忘掉，可是却越来越难忘，$m$ 种关系会带给我 $m^k$ 的思念。 我不知道我有多思念学长，能告诉我如果关系随意出现，思念的和吗？ 我不想看到太大的数，只要告诉我它模 $998244353$ 的结果就好了。 题意简述：$n$ 个点组成无向图，求不同的方案边数的 $k$ 次方之和。 斯特林展开+大力推式子+NTT. 再见。 其它myh 问班上的女生：你怎么3.5k写完仙人掌剖分的。 嗯，女生就是昨天的总结里的女生。yqyry Day 17今天没有比赛。 Day 16 ~ Day 17 的这晚貌似是来广二之后睡的最长的一次（$6$ 小时 $40$ 分），然后效率果然略高了一些（一天只搞了FFT/NTT/多项式求逆，高个鬼），比起之前整天几乎啥都不干还是好多了..（有种如果睡8小时能一天搞完多项式全家桶的错觉） 希望这周能把多项式常见的一些东西搞完吧..到时候应该会写一篇博客。 Day 18颓颓颓。 T1题意大约是求 $l_i\le ki+b\le r_i$ 的 $k,b$ 方案数。 最低档暴力在考试结束前 $10min$ 才想出来一个特别麻烦的解法..然后爆零了。 正解半平面交。 T2线性同余找循环节海星。 T3给几个团，团内点连相同权值边，问点之间两两距离之和。 以团内边权为点权求出团之间的最短路，然后 $dist(i,j)=\min\{d(x,y)|x\in S_i,y\in S_j\}$（$S_i$ 表示 $i$ 所在团的集合）。 具体实现要用到 FMT 里的一个小 trick ，然而题解里一笔带过，我看了一下午题解都没看明白… 其它那位女生 $rank1$ 了… 然后今天才发现广二 OJ 外网是能上的..（当然注册不了账号QAQ） Day 19今天搬的 ACM 原题？CF 权限 gym Orz 题解给吉老师视频，太灵性了.. zjt 25（$rank 8$），myh 赛后五分钟提交 $15$ 快乐赛。 T1dp，好像没啥不会的知识点，然而没做出来。 T2把排列当成坐标放在平面上，分类讨论求上升块？表示完全没听懂，讲的时候 myh 在不停地提问。 黑科技听不懂，而这道题除了黑科技还要牛顿迭代…每场必有多项式的flag还是没倒. T3没听懂嘤嘤嘤。 Day 20颓颓颓。 今天没比赛，然而只搞了多项式除法和任意模数NTT。 多项式除法一开始 $B(x)$ 模了 $x^m$ ，然而应该模 $x^{n-m+1}$ ，然后挂了半天。 任意模数NTT因为数组开小挂了半天… 看到洛咕有绘板，就把晚上的at咕咕了，搞了个py脚本。一开始妄想手动把图片转成数据，差点一晚没睡，后来main包发了个脚本，转的效果还挺不错的。 Day 21-23基本上都在搞绘板，比赛记应该是永久咕咕了，绘板记这几天会写出来。 有一个小插曲，9102年第一个梗被我骗了点赞。 Day gugugu绘板记咕咕了，这两天的比赛记咕咕了，今晚的CF不咕咕！猝死！！ Day 27今天的T1非常有意思，$8$ 个 int 进行编码，编码长度至少是 $1000$ 个 int，随机打乱之后给你解码。标算是一个不确定性算法，所以这题是达到一定正确率就过，（然后我赛时第一次提交30，第二次提交20，脸黑选手zjt赛时90，赛后AC），然而有神仙想出了多点求值、快速插值的确定算法。 T2一看是几何题我就跳了..然而这题不怎么需要计算几何，而且有 $30$ 分挺好写的….. T3是个树上dp，部分分有个“与一条蛇同构”，然后： xswl 尝试着按myh的提交记录刷题，第一题是个字符串哈希，第一眼还以为是AC自动机..然后一发mapT飞，unordered就过了。第二题是个裸的单点、子树加，单点询问，竟然写错了3遍…..第三题是个数位dp，愉快地卡住了….再不好好学数位dp感觉会出事_(:з」∠)_ Day 28T1是树上在线多组多路径询问颜色种类数和mex，一开始看到部分分还在想为什么没给树上莫队分，然后一想多条路径莫队复杂度肯定不对，看题解才知道正解树分块…bitset能在线搞定的事，为什么要离线排序呢？然后成功在赛后A掉了（广二膜你赛赛后首A_(:з」∠)_）大约就是预处理关键点之间的bitset，块内暴力跳，关键点之间已经预处理了。 T2是道神仙题..好像从某外国比赛搬的，赛时0A，通过分治时判断左右一样来保证复杂度，没太听懂。 T3：“点分治然后建虚树再点分治就好了！”（mdzz）“听说fzy有两个log做法？treap/Splay合并就行了！”（mdzz） 然后用bitset水了点contribution，达成成就：contribution比friends多。 polygon真有意思！试着把一道题搞上去了。 Day 29-30稍微学了下莫比乌斯反演和杜教筛，感觉挺有意思的QAQ。 比赛全场就我不会马拉车，然而三题暴力排名还不错…貌似只要打了点非无脑的暴力就能考的还行。（A题就jxd了 Day 31今天比赛是zzq出的，上场 Chinese round 既视感严重.. T1树上有一些特殊点。 两两匹配特殊点使得距离之和最大。正解没听懂，然而直接扫一遍存为 $rk_{1..k}$ 然后输出 $(rk_i,rk_{i+\frac k 2})$ 就能过… T2“这是一道交互题”。 加了一些限制条件，不同排名的人在某些情况下可能不回答询问，对其排序。 并不是很难然而赛时没想到.. T3QuickSort伪代码。 求 $cnt$ 次操作后排序成啥样了。又是只需要大小时转化为 $0/1$,$0/\pm1$ 的 trick. 然后，今天写了 $5$ 道莫比乌斯反演，100+600，感觉海星。 Day 32改题日→出题日 Day 33比赛的时候OJ挂了海星，最后修好了。 感受一下刚修好时的提交。这次题目时限又大，当时卡了好几页。 T1一开始时限是 $2s$，后来开成 $4s$ 了，然后一排人 $3.9s$… T3一开始时限是 $6s$，myh NTT被卡常，赛后给自己开到 $12s$ 重测，$9s$ 过了…然后他成功 $rank1$。 Day 34 这个是我们刚来时就在画的，最近画好了，趁着迟到没人拍了一下。 上午被告知学校有考试，机房被占用了，让我们下午不要去机房，在打比赛的体育馆待着。于是很多人都提前跑了..我也下午就走了，走的时候看到一堆小学生模样的孩子和家长，听到了“XX考试的第二场和XX时间一样，不让考完第一场就跑”之类的话，听到了“二火”之类曾经熟悉的名词。我是为什么放弃了华一寄来到外初的呢..早就忘得一干二净了，只记得来外高是因为wqs的寥寥几句话： 还听到一个孩子说：“二中环境真好。”我以为他也会感叹二中有山有水，没想到他说的是——“二中有专门的清洁工”。 Day 35改题日颓颓颓 Day 36OrangeRabbit tql!!! 去机房的路上发现这个： 我们刚来的时候就看到有人在画井盖了，然而才发现这个QAQ T2对自己 $20$ 分暴力过于自信，打了一个半小时表找不到规律后写了下 $20$ 分才发现是错的… T1写了一个半小时比暴力跑的还慢的树剖..稍微想想就可以发现复杂度完全不比暴力优的，然而想到就打了.. 最后没时间写T3暴力了，赛后听说T3数据特别水，随便写都能六七十分.. 于是炸的特别惨。 晚上学了下淀粉质（讲题的时候myh认为机房里没人不会动态点分树…），看题解怎么都看不懂，只不过自己yy很快就写出来了，然而第一次交的时候前向星存边数组没开两倍..？ Day 37今天又是zzq出的题，T1T2都是构造，其中T1没有输入..T1 rand跑了一个小时跑出来 $60$ 分（存种子提交），T2最低档爆搜不会..两个特殊性质subtask写了 $30$ 分。 T3 也是道思维好题，写了个 $O(n^3)$ 暴力 $30$ 分。 Day 38好像是最后一个改题日..又颓过去了没什么好说的。 Day 39Sooke跟我说他昨天做了这套题…然后告诉我不要看T3，会很惨。然而.. 这次好像是我拿到 $80$ 分最快的一次，打完T1T2拍了一下就开始玩提答了。看了一会儿大约看懂了一点，然后试着百度了一下“lambda”，啥都没查到，然后继续搜“lambda 邱奇”，发现“邱奇数 百度百科”，然后继续搜“邱奇数”，搜到了这个。于是开始研究..前面 $6$ 个点有的是自己想的，有的是看懂之后写的，78是直接抄的。最后混到个15名..lx特别ba…只不过今天又来了几个人，感觉不抄的话二三十名好像也有，也海星啦… Day 40最后一天了呢..已经在布置THUWC了。 今天的题暴力档特别少..又是1h拿到了 $48$ 然后肝不出了…T3有很多人A，和之前D16T2有点像，是给一个排列问划分成若干个连续段的方案数，做法也比较类似，然而没想起来，也不会做… 这 $40$ 天好多想补的知识点也没补完..题也没怎么改..总体来说挺颓的…最后两天再稍微补一补，调整一下状态吧，考出应有的成绩就好。这篇博客大概就这样完结了，下次就是THUWC/WC游记了。 Day 41本来应该结束了的..今天没去学校，10点的时候dew突然告诉我今天有场比赛？？一看是THUSCH2017原题，然后T1 dl线段树写了2h没调出来…只不过好像并不是膜你赛，广二OJ很早就有这几题了，今天的standing也只有6个人… 然后..窝竟然真的在WC前把kanon补完了..]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>集训</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AtCoder Beginner Contest 115 游记]]></title>
    <url>%2FAtCoder-Beginner-Contest-115%2F</url>
    <content type="text"><![CDATA[之前听教练安利，就来打了场 AtCoder。 -5h比赛地址 一开始看到 “Beginner”的时候我还迟疑了一下，看了下上一场 Beginner 的题目，又在网上搜了一下，想着可以熟悉一下 AtCoder ，就准备打了。 0min咕咕咕 5min咕咕咕咕咕咕 只不过幸好咕咕了，我的模板还没搞好..赶紧新建文件夹 atcoder\AtCoder Beginner Contest 115 ，把 $4$ 个用于 CF 的模板扔进去。 10min开始了！ 用了 $0.1s$ 决定用 switch 而不是 if else 。 用了不知道多久敲完。 没测样例（废话）直接交了。 其实我现在还在想，如果 WJ 的时候我去写 T2 而不是刷新看结果会不会涨个一两名… 12min看了下 $10\times10000&lt;10^9$ 。 用了不知道多久敲完。 测了样例交了。 其实我现在还在想，如果没测样例我会不会再涨个一两名… 14min想了想还是用了快读，毕竟模板里有。 测样例，没写cout&lt;&lt;ans; 。 其实我现在还在想，其实我现在还在想，如果没测样例我会不会掉个十几名。 16min数据范围看起来好小。 等等，$x$ 的范围？ 预处理汉堡的大小。 哦，爆 int 了。 其实我现在还在想，如果模板里有#define int long long我会不会再涨个一两名… 写个函数 work(int a) 处理大小为 $a$ 的汉堡，分类讨论乱搞一下应该就行了。 测样例，#3 看起来好大。 终于可以安心地看 judging 不用担心浪费时间了。 130minBeginner 定级貌似最高 400 点 rating..]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WC2019 全国模拟赛第二场 T1 题解]]></title>
    <url>%2FWC2019-%E5%85%A8%E5%9B%BD%E6%A8%A1%E6%8B%9F%E8%B5%9B%E7%AC%AC%E4%BA%8C%E5%9C%BA-T1-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[又只会写T1… 题目链接 题意简述给你一个排列 $p_{1..n}$，$a_{1..n}$ 为任意的一个排列，定义 $b[a_i]=a[p_i]$，求总共有多少个不同的 $b_{1..n}$ 。 做法首先，对 $(i,p_i)$ 连边，会得到若干个环。 环上旋转一下（$\forall i\text{ on the cycle : }i\rightarrow p_i$）得到的置换是本质相同的。节点个数相同的环互换一下是本质相同的。 先计算把 $n​$ 个节点分成若干个环的方案数：（用 $siz[i]​$ 表示第 $i​$ 个环的大小，$k​$ 表示环的个数，$sum[i]​$ 表示 $\sum\limits_{j=i}^ksiz[j]​$） $$S_1=\prod\limits_{i=1}^kC_{sum[i]}^{siz[i]}$$ 然后去掉节点个数相同的环互相交换：（用 $num[i]$ 表示节点个数为 $i$ 的环的个数） $$S_2=\frac{S_1}{\prod\limits_{i=1}^nnum[i]!}$$ 然后乘上每个环旋转（旋转造成的不同方案数即固定某个数后剩下的数的排列个数）： $$S_3=S_2\times\prod\limits_{i=1}^k(siz[i]-1)!$$ $S_3$ 就是最终的答案了。 参考代码noi.ac 上最短解（其实计算方式和我是一样的..）： 12345678910111213141516#include&lt;bits/stdc++.h&gt;#define mn 1111111using namespace std;long long n,i=1,s=1,j,x,p=998244353,a[mn],f[mn],v[mn],t[mn];int main()&#123; scanf("%lld",&amp;n); f[0]=f[1]=1; for (;i&lt;=n;i++) scanf("%lld",a+i); for (i=2;i&lt;=n;i++) f[i]=f[p%i]*(p-p/i)%p,(s*=i)%=p; for (i=1;i&lt;=n;i++) if (!v[i]) &#123; for (j=i,x=0;!v[j];x++,j=a[j]) v[j]=1; (s*=f[x]*f[++t[x]]%p)%=p; &#125; printf("%lld",s);&#125; 我自己赛时的辣鸡写法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cctype&gt;using namespace std;int read()&#123; int out=0; char c; while (!isdigit(c=getchar())); for (;isdigit(c);c=getchar()) &#123; out=out*10+c-'0'; &#125; return out;&#125;const int N=1000010;const int M=998244353;void dfs(int u);int c(int a,int b);int n,p[N],dfn[N],low[N],sta[N],dfncnt,top,siz[N],tot,num[N];int x,y,jc[N],inv[N],ans=1,sum;bool ins[N];int main()&#123; int i; n=sum=read(); for (i=1;i&lt;=n;++i) &#123; p[i]=read(); &#125; for (i=1;i&lt;=n;++i) &#123; if (dfn[i]==0) &#123; dfs(i); &#125; &#125; jc[0]=jc[1]=inv[0]=inv[1]=1; for (i=2;i&lt;=n;++i) &#123; inv[i]=(1ll*M*M-1ll*(M/i)*inv[M%i])%M; &#125; for (i=2;i&lt;=n;++i) &#123; jc[i]=(1ll*jc[i-1]*i)%M; inv[i]=(1ll*inv[i-1]*inv[i])%M; &#125; for (i=1;i&lt;=tot;++i) &#123; ans=1ll*ans*c(sum,siz[i])%M; sum-=siz[i]; &#125; for (i=1;i&lt;=n;++i) &#123; ans=1ll*ans*inv[num[i]]%M; &#125; for (i=1;i&lt;=tot;++i) &#123; ans=1ll*ans*jc[siz[i]-1]%M; &#125; cout&lt;&lt;ans; return 0;&#125;int c(int a,int b)&#123; if (a==b||b==0) &#123; return 1; &#125; return 1ll*(1ll*jc[a]*inv[b]%M)*inv[a-b]%M;&#125;void dfs(int u)&#123; dfn[u]=low[u]=++dfncnt; sta[++top]=u; ins[u]=true; if (dfn[p[u]]==0) &#123; dfs(p[u]); low[u]=min(low[u],low[p[u]]); &#125; else if (ins[p[u]]) &#123; low[u]=min(low[u],dfn[p[u]]); &#125; if (low[u]==dfn[u]) &#123; siz[++tot]=1; while (sta[top]!=u) &#123; ++siz[tot]; ins[sta[top--]]=false; &#125; ins[sta[top--]]=false; ++num[siz[tot]]; &#125;&#125; 所以说不要看到环就 tarjan…]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>noi.ac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客搭建指北]]></title>
    <url>%2Fhexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8C%97%2F</url>
    <content type="text"><![CDATA[折腾了 $3$ 天终于把博客搭建好了…本文会简单介绍一下hexo博客的搭建，并选取一些我自己在配置博客的过程中遇到的问题，说明一下我的解决方案。 实际上，hexo博客的搭建并不难，难搞的是美化，我在这个过程中遇到了很多问题，不可能在这篇博客中全部陈述出来，最重要的还是勤于百度。 本篇博客不完全按照顺序撰写，可以通过页面左边的目录跳转阅读。 博客的搭建先推荐两篇比较好的教程：搭建个人博客-hexo+github详细完整步骤，使用github+Hexo人人都能拥有一个美美的博客。 这部分网上讲的已经比较好了，我在这就简单说一下。 安装软件需要安装的软件有：git，Node.js。 下载安装即可… 本地设置装好之后，在本地创建一个文件夹，下文中称其为“根目录”。 下文中“输入命令”均指在命令行中输入命令（并回车废话），既可以使用 git bash，也可以使用 cmd 或 powershell 。输入命令时若无特别说明都需要 cd 到根目录下。 输入命令 npm install -g hexo 来安装 hexo 。 输入命令 hexo init 来初始化 hexo 。 输入命令 npm install 来安装一些需要的包。 输入命令 hexo s，并在浏览器打开 localhost:4000，在本地预览博客；如果上文步骤进行正确，应该看到一个类似于这样的页面： 注：命令可以缩写，条件是没有开头几个字母相同的其它命令。hexo s 实际上是 hexo server 的缩写；下文中 hexo d 是 hexo deploy 的缩写，hexo g 是 hexo generate 的缩写；hexo clean 不能缩写为 hexo c，因为存在命令 hexo config ，但是可以缩写为 hexo cl 。 按 Ctrl+C 关闭 server 以继续操作。（若出现类似于 终止批处理操作吗(Y/N)? 的提示，输入 y 即可。） 接着安装博客的主题，可以在 hexo 官网 选择主题下载，本篇教程推荐使用 NexT 主题。 在 hexo 官网 点击图片下方蓝色的文字即可打开主题的 GitHub 主页，一般来说，一个主题的 GitHub 主页上是有用于安装的命令以及配置博客的教程的。 如果没有的话（或者即使有也一样），你应该输入命令 git clone 主题的Github主页地址 themes/主题名 。例如：git clone https://github.com/theme-next/hexo-theme-next themes/next 。 当然，你也可以使用默认的 landscape 主题，从而不用额外下载主题。 下载好主题后，用任何一款文本编辑器（记事本也可以），打开根目录下的 _config.yml ，将 theme: landscape 修改为 theme: 你想用的主题名 即可。 配置 GitHub 仓库首先你需要有一个 GitHub 账号。 然后点击右上角你的头像，打开“Your repositories”，点击绿色的按钮“New”。 在”Repository name”一栏填入 yourname.github.io （“yourname”指你的 GitHub ID，比如我就填 ouuan.github.io），”Description”可以随便填也可以不填，然后点绿色的按钮“Create repository”。 将博客上传至 GitHub输入命令 ssh-keygen 来生成 SSH，让你输入东西你就空着，按回车（应该要按三次回车）。 然后用任意的文本编辑器打开 C:\Users\电脑用户名\.ssh\id_rsa.pub（如果装了 vim 可以直接输入命令 vim ~/.ssh/id_rsa.pub），复制里面的内容。 打开 GitHub，点击右上角的头像，打开“Settings”，选择左边的“SSH and GPG keys”，点绿色的按钮“New SSH key”，Title 随便填，下面的 Key 把刚才复制的东西粘贴进去，然后点绿色的按钮“Add SSH key”。过程中可能需要输入密码。 输入命令 ssh -T git@github.com ，若出现 Hi yourname! You&#39;ve successfully authenticated, but GitHub does not provide shell access. 表示 SSH 配置成功。 输入命令 npm install hexo-deployer-git --save 安装 deployer 。 打开根目录下的 _config.yml ，将最后几行改为： 1234deploy: type: git repository: https://github.com/yourname/yourname.github.io.git branch: master 当然”yourname”要改成你的 GitHub ID 。 依次输入命令： 123hexo cleanhexo ghexo d 这一步可能要输入密码。 等几分钟，再用浏览器打开 yourname.github.io ，应该就可以看到你的博客了。（此时别人也可以通过这个网址看到你的博客） 域名的配置实际上，自定义域名基本上没有什么用。但是有一个自己的域名还是一件比较爽的事，会感觉摆脱了束缚（实际上你还是用着 GitHub…）。 域名的获取本篇教程只讲解如何免费获取域名（的 $12$ 个月使用权），当然你也可以通过其它方式购买域名。 打开 Freenom，输入自己想用的域名，点击”Check Availability”，有“Get it now”的就是能用的。 选择好你要的域名后，点右上角的”Checkout”，Period 选择”12 Months @ FREE”，然后点”Continue”，输入邮箱登录或使用其它账号（如 Google 账号）登录（输入邮箱登录经常会出错，而使用其它账号登录需要科学上网）。 DNS 配置我使用的是 cloudfare，（因为在学校搭建的博客，手机没电了，国内的服务商注册都需要短信验证码），还是比较方便的。 先注册一个账号，然后点”Add site”，输入你刚刚获取的域名。 然后进入站点设置里的 DNS 设置，如图添加两条记录： 1185.199.109.153 当然要记得把“yourname”换成你的 GitHub ID。推荐关闭 cdn 服务，即点击一下橙色的云使其变成灰色。 完成后应该是这样的： 连接域名和 DNS回到 Freenom，登录网站，点击右上角的“Services” $\rightarrow$ “My Domains”，找到你刚刚获取的域名，点击 “Manage Domain” $\rightarrow$ “Management Tools” $\rightarrow$ “Nameservers”。 再回到 cloudfare，就在刚刚 DNS 设置的下面，有两个域名： 再回到 Freenom，把这两个域名复制进去，然后点”Change Nameservers”。 连接域名和 GitHub在 hexo 根目录的 source 子目录下新建文件 CNAME（没有后缀名），用文本编辑器打开，输入如下内容： 当然要替换成你获取的域名。 然后再输入命令 hexo d ，过几分钟应该就可以从你获取的域名访问你的博客了。 开启https如果不开启的话，访问 https://你的域名 就会显示警告，访问 http://你的域名 就会显示不安全。 当然如果因为某种原因访问 https://你的域名 已经不会显示警告而且浏览器左上角有绿锁了，就不需要再进行额外的设置了。 其实很简单，浏览器打开 https://github.com/yourname/yourname.github.io/settings ，找到这里： 如果”Enforce HTTPS”前没有打勾，打勾即可。 如果”Enforce HTTPS”前面是灰色的，无法打勾： 删掉”Save”前面的域名，点击”Save”。 重新输入域名，点击”Save”。 重新发布博客（hexo d）。 等待几分钟~几小时，再访问你的博客应该就OK了。 停用域名由于免费的域名还是经常会出一些小问题，而且不可避免地会碰上域名到期的问题，所以我在用了半个月自定义域名后停用了.. 单纯停用只需删去 CNAME 文件即可，然后记得更改相关设置（在各种地方引用的博客链接、OAuth App 地址……）。 然而，在停用后，我自己的电脑上一直无法打开博客主页（会自动跳转到原自定义域名），别人的电脑/手机上可以正常打开。 解决方法：F12 $\rightarrow$ Network $\rightarrow$ Disable Cache 勾选后 Ctrl + F5 强制刷新博客主页，然后就可以进了，取消勾选 Disable Cache 后依然正常。 方法来源 博客的配置与美化根目录下的 _config.yml这部分参考官网教程即可。 主题目录下的 _config.yml主题目录下的 _config.yml 指 \themes\主题名\_config.yml。 这里以 NexT 主题（本文基于 NexT 6.6，其它版本可能有些区别）为例，这个主题的 _config.yml 非常完备，修改配置基本上只需删除/添加注释符号 # 以及改变 true/false 即可。 选择 NexT 主题的四种之一12345# Schemesscheme: Muse#scheme: Mist#scheme: Pisces#scheme: Gemini 将想用的主题前的 # 删掉，在 scheme: Muse 前加上 # 即可。 例如： 12345# Schemes#scheme: Muse#scheme: Mist#scheme: Piscesscheme: Gemini 四种主题的预览在 NexT 主题的官网有。 改变网站图标12345favicon: small: /images/favicon-16x16-next.png medium: /images/favicon-32x32-next.png apple_touch_icon: /images/apple-touch-icon-next.png safari_pinned_tab: /images/logo.svg 将你想用的图标放在 \themes\next\source\images 里，然后修改上面的文件名即可。 例如： 123favicon: small: /images/favicon16.png medium: /images/favicon32.png 页脚设置1234567891011121314151617181920212223242526272829303132333435footer: # Specify the date when the site was setup. # If not defined, current year will be used. #since: 2015 # Icon between year and copyright info. icon: # Icon name in fontawesome, see: https://fontawesome.com/v4.7.0/icons # `heart` is recommended with animation in red (#ff0000). name: battery-full # If you want to animate the icon, set it to true. animated: false # Change the color of icon, using Hex Code. color: &quot;#808080&quot; # If not defined, will be used `author` from Hexo main config. copyright: # ------------------------------------------------------------- powered: # Hexo link (Powered by Hexo). enable: false # Version info of Hexo after Hexo link (vX.X.X). version: true theme: # Theme &amp; scheme info link (Theme - NexT.scheme). enable: true # Version info of NexT after scheme info (vX.X.X). version: true # ------------------------------------------------------------- # Beian icp information for Chinese users. In China, every legal website should have a beian icp in website footer. # http://www.miitbeian.gov.cn beian: enable: false icp: icon： © 2019 与用户名之间的图标。（图中 $1$） 图标名称为 Font Awesome 上的图标名称。 powered.enable：为 true 则会显示“由 Hexo 强力驱动”。（图中 $2$） powered.version：为 true 则会显示 Hexo 的版本。（图中 $3$） powered.enable：为 true 则会显示“主题 – NexT.XX”。（图中 $4$） powered.version：为 true 则会显示主题的版本。（图中 $5$） 注：根据 NexT 主题的 LICENSE，footer 中必须开启 powered.enable 选项。 “关于”&amp;”标签”123456789menu: home: / || home about: /about/ || user tags: /tags/ || tags #categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 将需要的项目取消注释即可在侧边栏显示。 如果需要使用“关于”页面，输入命令 hexo new page &quot;about&quot;。 然后在 \source\about\index.md 中就可以编辑“关于”页面了。 可以修改 \source\about\index.md 中的 title 项来显示“关于”而非“about”。 如果需要使用“标签”功能，需要在博文中添加选项 tags ： 如果有多个标签，每行一个，以 - 开头： 1234tags:- 标签1- 标签2- 标签3 如果需要使用“标签”页面，输入命令 hexo new page &quot;tags&quot;。 然后向 source\tags\index.md 中添加一行： 1type: &quot;tags&quot; “分类”与“标签”类似。 站内搜索输入命令 npm install hexo-generator-searchdb --save 安装所需的库。 在根目录下的 _config.yml 的结尾加入： 12345search: path: search.xml field: post format: html limit: 10000 然后在 \themes\next\_config.yml 中，打开 local_search： 12local_search: enable: true 社交网站123456789101112131415# Social Links.# Usage: `Key: permalink || icon`# Key is the link label showing to end users.# Value before `||` delimeter is the target permalink.# Value after `||` delimeter is the name of FontAwesome icon. If icon (with or without delimeter) is not specified, globe icon will be loaded.social: GitHub: https://github.com/ouuan || github 洛谷: https://www.luogu.org/space/show?uid=49742 || code Codeforces: https://www.codeforces.com/profile/ouuan || code b站: https://space.bilibili.com/11067182 || tvsocial_icons: enable: true icons_only: false transition: false 在 social 下每行一个，格式为：名称: 地址 || 图标。 其中，“图标”为 Font Awesome 图标名称，但有些图标是不可用的，而且图标也不全，使用的时候要尝试一下图标是否可用。 12social_icons: enable: false 这样设置可以只显示名称不显示图标。 友情链接（或其它链接）123456789101112# Blog rollslinks_icon: globelinks_title: 友情链接# links_layout: blocklinks_layout: inlinelinks: Dew: https://www.cnblogs.com/ppprseter/ wjyyy: https://www.wjyyy.top/ Sooke: https://www.luogu.org/blog/Sooke/ huyufeifei: https://www.cnblogs.com/huyufeifei/ Rye_Catcher: https://rye-catcher.github.io/ 额冻豆腐: http://www.mayflyyh.com/ links_icon：显示在标题前的图标。 links_title：标题。 links_layout：block 一行一个，inline 一行多个。 links：要显示的链接以及名称。 头像123456789101112# Sidebar Avataravatar: # in theme directory(source/images): /images/avatar.gif # in site directory(source/uploads): /uploads/avatar.gif # You can also use other linking images. url: /images/avatar.jpg # If true, the avatar would be dispalyed in circle. rounded: true # The value of opacity should be choose from 0 to 1 to set the opacity of the avatar. opacity: 1 # If true, the avatar would be rotated with the cursor. rotated: false url：头像地址，留空则不显示头像。 rounded：圆/方头像。 opacity：不透明度。 rotated：随光标旋转。 回到顶部按钮/阅读百分比12345# Back to top in sidebar (only for Pisces | Gemini).b2t: true# Scroll percent label in b2t button.scrollpercent: true 博客首页不显示全文在博文里可以用 &lt;!-- more --&gt; 来标识在首页显示到哪为止。 可以在 \themes\next\_config.yml 里设置到一定字数自动不显示全文： 123456789# Automatically Excerpt. Not recommend.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt: enable: true length: 150# Read more button# If true, the read more button would be displayed in excerpt sectionread_more_btn: true length：不显示全文的字数上限。 read_more_btn： 代码块复制按钮123456789codeblock: # Manual define the border radius in codeblock # Leave it empty for the default 1 border_radius: # Add copy button on codeblock copy_button: enable: true # Show text copy result show_result: true enable：启用复制按钮。 show_result： $\LaTeX$1234567891011# Math Equations Render Supportmath: enable: true # Default(true) will load mathjax/katex script on demand # That is it only render those page who has &apos;mathjax: true&apos; in Front Matter. # If you set it to false, it will load mathjax/katex srcipt EVERY PAGE. per_page: false engine: mathjax #engine: katex enable：启用 $\LaTeX$ 。 per_page：为 true 则只有博文中有 mathjax: true 才会启用 $\LaTeX$，否则每篇博客都会启用 $\LaTeX$ 。 engine：推荐使用 mathjax 。 hexo 博客的 mathjax 和 Markdown 有一些冲突，将在后文专门讲解如何解决冲突。 评论功能由于 gitment 的服务器有一些问题，推荐使用 gitalk： 1234567gitalk: enable: true github_id: yourname repo: yourname.github.io client_id: client_secret: admin_user: yourname 这里需要在 GitHub 新建一个 OAuth App，”Homepage URL”和”Authorization callback URL”填你的域名（如果没有申请域名的话就填 yourname.github.io）： 需要注意的是，地址要严格和博客访问地址一样，http 和 https不能混，有无 www 也不能混。 然后将 Client ID 和 Client Secret 填入 \themes\next\_config.yml 中。 评论功能无法在本地正常预览，需要发布才能使用。 访客记录12busuanzi_count: enable: true 书签书签的功能是关闭页面/手动点击书签按钮时，保存这篇博客看到的位置，下次点进这篇博客时继续从这个位置开始。 安装插件：git clone https://github.com/theme-next/theme-next-bookmark.git source/lib/bookmark 更改 \themes\next\_config.yml： 123456789# Bookmark Support# Dependencies: https://github.com/theme-next/theme-next-bookmarkbookmark: enable: true # if auto # - save the reading position when closing the page # - or clicking the bookmark-icon # if manual, only save it by clicking the bookmark-icon save: manual 其它配置博客背景打开 \themes\next\source\css\_custom\custom.styl，输入： 1234body &#123; background-image:url(/images/background.jpg); background-size: cover;&#125; 把背景图片重命名为 background.jpg，放入 \themes\source\images（当然也可以更改background-image:url()）。 background-size: cover; 表示宽度缩放至页面大小。 123456body &#123; background-image:url(/images/background.jpg); background-repeat: no-repeat; background-attachment:fixed; background-size: cover;&#125; 如果修改成这样的话背景图片就不会滚动。 如果不想让博客内容挡住背景，可以设置博客内容的透明度，在 \themes\next\source\css\_custom\custom.styl 中加入下面的代码即可： 123.main-inner &#123; opacity: 0.8;&#125; 博文自定义排序打开 \node_modules\hexo-generator-index\lib\generator.js 。 在末尾添加如下代码： 12345678910111213posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; if(a.top == b.top) return b.date - a.date; else return b.top - a.top; &#125; else if(a.top &amp;&amp; !b.top) &#123; return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date;&#125;); 在博文设置中加入 top: x 即可，会以 top 为第一关键字，时间为第二关键字排序。若 top 为空则视作 -INF 。 折叠块怎么搞？ 标题链接的这篇博文写的够清楚了.. README.md如果想在 https://github.com/yourname/yourname.github.io 让别人看到你的博客的简介，就需要写一个 README.md 放在根目录下的 source 文件夹内。 然而，只是这样的话， README.md 会被渲染成 html，所以需要更改根目录下 _config.yml 的设置： 1skip_render: README.md 自定义404页面首先写一个 \source\404.html 。 至于怎么写html..这里地方太小写不下 事实上可以新建一篇博客，用 Markdown 写一个 404 页面，然后 hexo g 在 \public 里找到博客的页面，把相关部分直接复制过来。 可以参考一下我的： 1234567&lt;body&gt; &lt;div&gt; &lt;p style="text-align: center;"&gt;&lt;strong&gt;您可能访问了错误的网址&lt;/strong&gt;&lt;img src="https://i.loli.net/2018/10/27/5bd4705dd844f.jpg"&gt;&lt;/p&gt; &lt;p style="text-align: center;"&gt;&lt;a href="https://www.ouuan.cf"&gt;&lt;strong&gt;回到博客主页&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt; &lt;p style="text-align: center;"&gt;&lt;a href="javascript:history.go(-1);"&gt;&lt;strong&gt;返回上一页&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt; &lt;/div&gt;&lt;/html&gt; 然后，如果直接这样发布，html 会被渲染，就跟一个自定义页面（hexo new page）一样了。 所以要修改根目录下的 _config.yml，在 skip_render: 后添加 404.html，如果有多项用 - 隔开： 123skip_render: - README.md - 404.html 发布完成后，访问一个错误的网址，比如 你的域名/qaq 就可以查看效果了。 一言（ヒトコト）大约是这个。 网上没找到教程，自己随便瞎研究了一波，所以方法比较丑陋，仅供参考.. 本来想稍微写一下自己研究的经过，想了想自己也没完全搞清楚，就来一波授人以鱼吧… \themes\next\layout\_macro\sidebar.swig: 1234567891011121314151617…… &lt;aside id="sidebar" class="sidebar"&gt; &lt;div class="sidebar-inner"&gt; &lt;div&gt; &lt;div style="display: table-cell;vertical-align: top; color:#B2B7F2;font-size:24px;font-family:'Times New Roman',serif;font-weight:bold;text-align:left;"&gt;“&lt;/div&gt; &lt;div style="display: table-cell;text-align: left; vertical-align: middle; text-indent: 2em; padding: 0.8em 0.2em 1em 0.2em"&gt;&lt;b&gt;&lt;span style="color:burlywood;"&gt;&lt;span id="hitokoto-content"&gt;&lt;/span&gt;&lt;/span&gt;&lt;/b&gt;&lt;/div&gt; &lt;div style="display: table-cell; vertical-align: bottom; color:#B2B7F2;font-size:24px;font-family:'Times New Roman',serif;font-weight:bold;text-align:left;"&gt;”&lt;/div&gt; &lt;/div&gt; &lt;div style="text-align: right; font-size: 0.8em; color: black;" id="hitokoto-from"&gt;&lt;/div&gt; &lt;div style="margin-top: 15px; font-size: 0.8em; color: black;"&gt;&lt;a href="https://hitokoto.cn/"&gt;Hitokoto&lt;/a&gt;&lt;/div&gt; &lt;/div&gt; &lt;div style="height: 15px"&gt;&lt;/div&gt; &#123;% if theme.sidebar.onmobile %&#125;…… \themes\next\layout\_scripts\commons.swig: 1234567……&lt;script type="text/javascript"&gt; $.get('https://v1.hitokoto.cn/?c=a', function (data) &#123; $('#hitokoto-content').css('display', '').text(data.hitokoto); $('#hitokoto-from').css('display', '').text('——' + data.from); &#125;);&lt;/script&gt; \themes\next\source\css\_custom\custom.styl: 1234…….sidebar &#123; background: rgba(0, 0, 0, 0);&#125; 大约就这样，省略号表示文件中本来就有的其它部分。不保证在其他人电脑上可以用。大致思路就是搞个空 div 指定一个 id，用 js 往里面塞东西。所以即使我这个“鱼”不能直接用大约也是可以稍微研究研究来用的。 博客的写作Markdown 的使用网上有很多 Markdown 的学习资源，我自己是在洛谷剪贴板学会的。 我以前一般都用洛谷剪贴板编辑 Markdown，但 hexo 博客需要在本地编辑 .md 文件，这时普通的文本编辑器就不太方便了。我推荐 Typora 这款软件，还是挺方便的。 撰写博客前的准备打开根目录下的 _config.yml ，将 post_asset_folder 设为 true。 这样就可以把图片放到博客里而不用其它图床了。 然后把 \source\_posts\hello-world.md 删除。 博文的撰写新建一篇博客：hexo new &quot;博文标题&quot;。 然后等几秒钟，在 \source\_posts 文件夹下，就会生成 博客名 这个文件夹（如果你把 post_asset_folder 设为 true 了）以及 博客名.md。 撰写博客就是编辑 博客名.md。 这个文件的开头是博客的一些设置，可以在 \scaffolds\posts.md 中修改默认设置，我的默认设置是： 123456---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;tags: top: --- 然后就可以写 Markdown 格式的文章了。（top 是自定义文章排序，上文中介绍过） 需要注意的是，在洛谷代码块可以不加”cpp”，但在 hexo 上，一定要加上”cpp”： 12345#include &lt;iostream&gt;int main()&#123; cout&lt;&lt;&quot;hello world!&quot;&#125; 12345#include &lt;iostream&gt;int main()&#123; cout&lt;&lt;"hello world!"&#125; 更多博文模板在 \scaffolds 文件夹中可以增加更多的模板，比如我就搞了一个 \scaffolds\tutorial.md，这样的话，新建博文的时候输入命令 hexo new tutorial &quot;博文标题&quot; 就可以使用模板了。 引用本地图片引用链接/网络上的图片格式与普通 Markdown 相同（[链接名称](链接地址) 和 ![图片描述](图片地址)），引用本地图片需要把 post_asset_folder 设为 true ，然后把图片放在与博客同名的文件夹中，然后只用 ![图片描述](图片文件名) 就可以引用了。 在编辑器里显示不出图片是正常的。 还有另一种方式引用图片， 用这种方式引用图片的话，把鼠标放在上面会显示图片描述（上面这张图就是用这种方式引用的）。 只有这种方式引用图片才能在博客首页正常显示图片，否则只能点进博客才能看到图片。 $\LaTeX$ 的使用$\LaTeX$ 概述$\LaTeX$ 主要用于编辑数学公式，十分方便，网上也有很多学习资源，比如：LaTeX数学公式大全。 在支持 $\LaTeX$ 的 Markdown 文档里，使用两个美元符号将 $\LaTeX$ 公式括起来，例如： 1~~QAQ$f_i=\sum\limits_&#123;j=1&#125;^ia_j$f_i=\sum\limits_&#123;j=1&#125;^ia_j~~ QAQ$f_i=\sum\limits_{j=1}^ia_j$f_i=\sum\limits_{j=1}^ia_j 也可以用一对双美元符号使公式居中显示在单行，例如： 123$f_i=1$$$f_i=1$$ $f_i=1$ $$f_i=1$$ 在 Typora 中使用 $\LaTeX$ 需要将设置中的”Markdown 扩展语法”全部勾选。 P.S. $\LaTeX$：\LaTeX 启用 $\LaTeX$在 \themes\next\_config.yml 中将 mathjax 设为 true，然后将 per_page 设为 false 或者在需要启用 \LaTeX 的博文开头加上 mathjax: true 。 解决冲突由于hexo博客中即使是$$内的字符也会被当成 Markdown 渲染，类似于 $f_{f_i}$、$a*b*c$、$[x,y](1&lt;x&lt;y&lt;2)$ 之类的，都会被错误地渲染。 解决这个问题，首先要打开 \node_modules\marked\lib\marked.js，搜索 nolink，应该在 $470$ 行左右。 然后，将这一块修改为： 123456789101112131415var inline = &#123; escape: /^\\([`*\[\]()# +\-.!_&gt;])/, autolink: /^&lt;(scheme:[^\s\x00-\x1f&lt;&gt;]*|email)&gt;/, url: noop, tag: /^&lt;!--[\s\S]*?--&gt;|^&lt;\/?[a-zA-Z0-9\-]+(?:&quot;[^&quot;]*&quot;|&apos;[^&apos;]*&apos;|\s[^&lt;&apos;&quot;&gt;\/\s]*)*?\/?&gt;/, link: /^!?\[(inside)\]\(href\)/, reflink: /^!?\[(inside)\]\s*\[([^\]]*)\]/, nolink: /^!?\[((?:\[[^\[\]]*\]|\\[\[\]]|[^\[\]])*)\]/, strong: /^__([\s\S]+?)__(?!_)|^\*\*([\s\S]+?)\*\*(?!\*)/, em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/, code: /^(`+)\s*([\s\S]*?[^`]?)\s*\1(?!`)/, br: /^ &#123;2,&#125;\n(?!\s*$)/, del: noop, text: /^[\s\S]+?(?=[\\&lt;!\[`*]|\b_| &#123;2,&#125;\n|$)/&#125;; 这样做取消了 _text_ 的斜体意义，但 *text* 仍会被转义为斜体。 解决办法有两种： 放弃使用 * ，全部用 \times 代替或者省略掉。 取消 * 的转义。 如果使用方法二，就无法使用Markdown的斜体，可以通过HTML（&lt;em&gt;&lt;/em&gt;）来实现斜体。 如果想要使用 * 而放弃斜体： 在 \node_modules\marked\lib\marked.js 中搜索 Renderer.prototype.em ，应该在 $884$ 行左右。 将这一段改为： 123Renderer.prototype.em = function(text) &#123; return &apos;*&apos; + text + &apos;*&apos;;&#125;; （这个方法比较蠢..当然也可以直接修改 em: 项的正则表达式，使其无法匹配正常的博文。） 前文提到了，hexo博客中即使是$$内的字符也会被当成 Markdown 渲染，所以类似于 $[x,y](1&lt;x&lt;y&lt;2)$ 的，要在 ] 和 ( 中间加一个空格，就不会被错误地转义了。 博客的发布其实前文提到过，依次输入以下三条命令即可： 123hexo clhexo ghexo d hexo cl 是可选的。加上不会有坏处..而且有时候必须加上。 发布之前还可以执行 hexo s 并在本地使用浏览器打开 localhost:4000 进行预览。 当然也可以使用 hexo g -d 命令。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>hexo博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WC2019 全国模拟赛第一场 T1 题解]]></title>
    <url>%2FWC2019-%E5%85%A8%E5%9B%BD%E6%A8%A1%E6%8B%9F%E8%B5%9B%E7%AC%AC%E4%B8%80%E5%9C%BA-T1-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[由于只会T1，没法写游记，只好来写题解了… 题目链接 题目大意给你一个数列，每次可以任取两个不相交的区间，取一次的贡献是这两个区间里所有数的最小值，求所有取法的贡献和，对 $10^9+7$ 取模。 数列长度 $2\times 10^5$ ，值域 $1$ ~ $10^9$ 。 $O(n^4)$ 做法预处理区间最小值，枚举选的两个区间。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int M=1000000007;int n,a[60][60],ans;int main()&#123; int i,j,k,l; cin&gt;&gt;n; for (i=1;i&lt;=n;++i) &#123; cin&gt;&gt;a[i][i]; &#125; for (i=1;i&lt;n;++i) &#123; for (j=i+1;j&lt;=n;++j) &#123; a[i][j]=min(a[i][j-1],a[j][j]); &#125; &#125; for (i=1;i&lt;n;++i) &#123; for (j=i;j&lt;n;++j) &#123; for (k=j+1;k&lt;=n;++k) &#123; for (l=k;l&lt;=n;++l) &#123; ans=(ans+min(a[i][j],a[k][l]))%M; &#125; &#125; &#125; &#125; cout&lt;&lt;ans; return 0;&#125; $O(nlogn)$ 做法 warning：接下来的文章里“的”字嵌套情况非常严重，文字叙述比较繁杂，看不懂十分正常，建议看懂一小部分然后自己推。 考虑每个元素作为贡献的区间是哪些，为了把每个区间分给唯一的元素，规定一个区间的贡献是最小值里最靠左的（ e.g. 4 3 2 4 2 2 的贡献是 $3$ 号元素，即最左边的 $2$ ）。所以，可以利用栈在 $O(n)$ 的时间内预处理出每个元素作为贡献的区间的左端点和右端点的范围： 123456789101112131415161718192021222324252627for (i=1;i&lt;=n;++i)&#123; while (top&amp;&amp;a[sta[top]].w&gt;a[i].w) &#123; a[sta[top--]].r=i-1; &#125; sta[++top]=i;&#125;while (top)&#123; a[sta[top--]].r=n;&#125;for (i=n;i&gt;=1;--i)&#123; while (top&amp;&amp;a[sta[top]].w&gt;=a[i].w) &#123; a[sta[top--]].l=i+1; &#125; sta[++top]=i;&#125;while (top)&#123; a[sta[top--]].l=1;&#125; 每个元素作为贡献的区间就是 $[x,y] (l_i\le x\le i\le y\le r_i)$，每个元素作为贡献的区间数就是 $t_i=(i-l_i+1)\times(r_i-i+1)$ 。 然后，将元素按值从大到小排序，就能计算出区间数的后缀和 $suf[i]$，但一个元素的总贡献并不是 $t_i\times suf[i+1]$，因为这些区间可能与当前元素作为贡献的区间相交。 注意到，要想和当前元素作为贡献的区间相交，必须 $[x,y] (l_i\le x\le y\le r_i)$ ，而这样的区间除了当前元素作为贡献的区间，贡献都排在当前元素之后（值比当前元素大或值相等但位置靠后），所以这样的区间除了当前元素作为贡献的区间，都是我们要找的与当前元素作为贡献的区间相交的贡献更靠后的区间。 注：下面这段话中“相交的区间对”指（与当前元素作为贡献的区间相交的贡献更靠后的区间，当前元素作为贡献的区间）这样的一对区间；“相交的区间”指与当前元素作为贡献的区间相交的贡献更靠后的区间。 接下来就要计算相交的区间有多少对。首先，相交的区间不可能跨过当前元素，否则就是当前元素作为贡献的区间；所以，相交的区间要么是 $[x,y] (l_i\le x\le y&lt;i)$ ，要么是 $[x,y] (i&lt;x\le y\le r_i)$。先计算 $[x,y] (l_i\le x\le y&lt;i)$ 与当前元素作为贡献的区间相交的对数，先考虑 $y$ 固定时，个数为 $(r_i-i+1)\times(y-l_i+1)^2$ ，其中：$y-l_i+1$ 既是相交的区间左端点的个数，也是与相交的区间相交的当前元素作为贡献的区间的左端点的个数；$r_i-i+1$ 是与相交的区间相交的当前元素作为贡献的区间的右端点的个数。所以，总数是 $(r_i-i+1)\times\sum\limits_{y=l_i}^{i-1}(y-l_i+1)^2$ ，乘号右边是自然数平方和，可以用公式计算，所以就是 $(r_i-i+1)\times\frac{(i-l_i)\times(i-l_i+1)\times(2i-2l_i+1)}6$ 。$[x,y] (i&lt;x\le y\le r_i)$ 同理，总数为 $(i-l_i+1)\times\frac{(r_i-i)\times(r_i-i+1)\times(2r_i-2i+1)}6$ 。 所以，把相交的总对数减掉就可以了。 参考代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;using namespace std;int read()&#123; int out=0; char c; while (!isdigit(c=getchar())); for (;isdigit(c);c=getchar()) &#123; out=out*10+c-'0'; &#125; return out;&#125;const int N=200010;const int M=1000000007;const int SIX=166666668; //6模1e9+7的逆元struct Node&#123; long long id,w,l,r,t; bool operator&lt;(const Node&amp; b) const &#123; return w&lt;b.w; &#125;&#125; a[N];long long n,suf[N],sta[N],top,ans;int main()&#123; int i; n=read(); for (i=1;i&lt;=n;++i) &#123; a[i].w=read(); a[i].id=i; &#125; for (i=1;i&lt;=n;++i) &#123; while (top&amp;&amp;a[sta[top]].w&gt;a[i].w) &#123; a[sta[top--]].r=i-1; &#125; sta[++top]=i; &#125; while (top) &#123; a[sta[top--]].r=n; &#125; for (i=n;i&gt;=1;--i) &#123; while (top&amp;&amp;a[sta[top]].w&gt;=a[i].w) &#123; a[sta[top--]].l=i+1; &#125; sta[++top]=i; &#125; while (top) &#123; a[sta[top--]].l=1; &#125; for (i=1;i&lt;=n;++i) &#123; a[i].t=(i-a[i].l+1)*(a[i].r-i+1)%M; &#125; sort(a+1,a+n+1); for (i=n;i&gt;=1;--i) &#123; suf[i]=(suf[i+1]+a[i].t)%M; &#125; for (i=1;i&lt;=n;++i) &#123; ans=(ans+(a[i].w*suf[i+1]%M)*a[i].t)%M; ans=(ans-(a[i].id-a[i].l)*(a[i].id-a[i].l+1)%M*(2*a[i].id-2*a[i].l+1)%M*SIX%M*(a[i].r-a[i].id+1)%M*a[i].w%M+M)%M; //重复区间在左 ans=(ans-(a[i].r-a[i].id)*(a[i].r-a[i].id+1)%M*(2*a[i].r-2*a[i].id+1)%M*SIX%M*(a[i].id-a[i].l+1)%M*a[i].w%M+M)%M; //重复区间在右 &#125; cout&lt;&lt;ans; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>noi.ac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树上背包的上下界优化]]></title>
    <url>%2F%E6%A0%91%E4%B8%8A%E8%83%8C%E5%8C%85%E7%9A%84%E4%B8%8A%E4%B8%8B%E7%95%8C%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[最近做了几道树上背包的题目，很多题目的数据范围都很小，但实际上树上背包有多种方式可以优化到 $O(nm)$ （$n$ 为节点数，$m$ 为体积的值域），比如先序遍历优化（何森《先序遍历用于优化树形背包问题》），求泛化物品的并（徐持衡《浅谈几类背包题》）……经过一番学习，觉得还是上下界优化理解起来最简单，也比较好写，适用范围广，唯一比其它做法复杂的地方就是复杂度分析。 例题讲解这里以一道经典的树上背包作为例题：【数据加强版】选课 直接把我出的数据加强版放上来了..反正题面里有原题链接QAQ 注：本文中用 $a_i$ 代指题面中的 $s_i$ 。 $O(nm^2)$ 做法用 $f_{u,i}$ 表示以 $u$ 为根的子树中选 $i$ 门课的最大得分，那么 $f_{u,i}=\min\limits_{\forall fa[v_j]=u,\sum k_j=i-1}(\sum f[v_j][k_j])+a_u$，而这个转移可以通过背包实现，依次合并每棵子树，每次合并时枚举 $i$ 和 $k_j$ ，$f_{u,i}=\max(f_{u,i},f_{u,i-k_j}+f_{v_j,k_j})$ 。 需要倒序枚举 $i$ 防止状态在转移前被覆盖。否则的话dp数组要多一维。 由于可能是森林，所有没有直接先修课的节点，父亲视为节点 $0$，实际上就要选 $m+1$ 个节点。 参考代码： 1234567891011121314151617void dfs(int u)&#123; f[u][1]=a[u]; int i,j,k,v; for (i=head[u];i;i=nxt[i]) &#123; v=to[i]; dfs(v); for (j=m+1;j&gt;=1;--j) &#123; for (k=1;k&lt;j;++k) &#123; f[u][j]=max(f[u][j],f[u][j-k]+f[v][k]); &#125; &#125; &#125;&#125; 上下界优化注意背包转移的这部分： 1234567for (j=m+1;j&gt;=1;--j)&#123; for (k=1;k&lt;j;++k) &#123; f[u][j]=max(f[u][j],f[u][k]+f[v][j-k]); &#125;&#125; 实际上，这里面有很多状态都是没有意义的： 转移时已经合并了大小之和为 $s$ 的一些子树，那么 $f_{u,i}(i&gt;s)$ 实际上是没有意义的。 $f_{v,i}(i&gt;siz[v])$ 也是没有意义的。 $f_{u,i}(i&gt;m)$ 是没有作用的。 所以，可以对 $j$ 和 $k$ 的枚举范围进行优化： 12345678910111213141516171819void dfs(int u)&#123; siz[u]=1; f[u][1]=a[u]; int i,j,k,v; for (i=head[u];i;i=nxt[i]) &#123; v=to[i]; dfs(v); for (j=min(m+1,siz[u]+siz[v]);j&gt;=1;--j) &#123; for (k=max(1,j-siz[u]);k&lt;=siz[v]&amp;&amp;k&lt;j;++k) &#123; f[u][j]=max(f[u][j],f[u][j-k]+f[v][k]); &#125; &#125; siz[u]+=siz[v]; &#125;&#125; 复杂度分析可以参考这篇博客。 形象的解释每个点对都只会在 $lca$ 处合并一次，所以总的复杂度是 $O(n^2)$ 的。 这个解释很简洁，需要自己意会一下.. 严格？证明令 $T_u$ 为处理子树 $u$ 的总用时，那么： $\begin{aligned}T_u&amp;=\left(\sum\limits_{\forall fa[v_i]=u}T_{v_i}\right)+t_u\\\\t_u&amp;=1+(1+siz[v_1])\times siz[v_1]+(1+siz[v_1]+siz[v_2])\times siz[v_2]+\cdots+siz[u]\times siz[v_k]\\&amp;=1+\sum\limits_{\forall fa[v_i]=u}siz[v_i]\times(siz[u]+1)\\&amp;=siz[u]^2\end{aligned}$ 对于叶子节点 $u$ ，$T(u)=1$ ，是 $O(siz[u]^2)$ 的。 对于儿子都是叶子节点的节点 $u$，由于平方和小于和平方，$\sum\limits_{\forall fa[v_i]=u}T_{v_i}$ 也是 $O(siz[u]^2)$ 的。 可以这样递归地说明，对于任意节点 $u$ ，$\sum\limits_{\forall fa[v_i]=u}T_{v_i}$ 都是 $O(siz[u]^2)$ 的。 又因为 $t(u)$ 是 $O(siz[u]^2)$ 的，$T(u)$ 就是 $O(siz[u]^2)$ 的。 所以解决整个问题就是 $O(n^2)$ 的。 严格！证明枚举过程中还要对 $m$ 取 min ，所以应该是这样的： $\begin{aligned}t_u&amp;=1+\min(m,1+siz[v_1])\times \min(m,siz[v_1])+\min(m,1+siz[v_1]+siz[v_2])\times \min(m,siz[v_2])+\cdots+\min(m,siz[u])\times \min(m,siz[v_k])\\&amp;\le m\times siz[u]\end{aligned}$ 所以，$t(u)$ 是 $O(\min(siz[u],m)\times siz[u])$ 的。 对于 $siz[u]\le m$，$T(u)$ 是 $O(siz[u]^2)$ 的。 对于 $siz[u]&gt;m$，$\sum\limits_{\forall fa[v_i]=u,siz[v_i]\le m}T_{v_i}$ 是 $O\left(\left(\sum\limits_{\forall fa[v_i]=u,siz[v_i]\le m}siz[v_i]\right)^2\right)$ 的；$\sum\limits_{\forall fa[v_i]=u,siz[v_i]&gt;m}T_{v_i}$ 是 $O\left(m\times\sum\limits_{\forall fa[v_i]=u,siz[v_i]&gt;m}siz[v_i]\right)$ 的；所以，$T(u)$ 是 $O(m\times siz[u])$ 的。 所以，解决整个问题是 $O(nm)$ 的。 其它例题【数据加强版】道路重建 dl代码我出的那两道数据加强版略有些毒瘤..（$n\times m\le 10^8$） 大约需要这样写： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;void dfs(int u);void add(int u,int v);const int N=100010;int head[N],nxt[N],to[N],cnt;int n,m,a[N],f[100000010],siz[N];int main()&#123; int i,k; scanf("%d%d",&amp;n,&amp;m); for (i=1;i&lt;=n;++i) &#123; scanf("%d%d",&amp;k,a+i); add(k,i); &#125; dfs(0); printf("%d",f[m+1]); return 0;&#125;void add(int u,int v)&#123; nxt[++cnt]=head[u]; head[u]=cnt; to[cnt]=v;&#125;void dfs(int u)&#123; siz[u]=1; f[u*(m+2)+1]=a[u]; int i,j,k,v; for (i=head[u];i;i=nxt[i]) &#123; v=to[i]; dfs(v); for (j=min(m+1,siz[u]+siz[v]);j&gt;=1;--j) &#123; for (k=max(1,j-siz[u]);k&lt;=siz[v]&amp;&amp;k&lt;j;++k) &#123; f[u*(m+2)+j]=max(f[u*(m+2)+j],f[u*(m+2)+j-k]+f[v*(m+2)+k]); &#125; &#125; siz[u]+=siz[v]; &#125;&#125; 关于另一种 $O(nm)$ 做法一开始我在洛谷发了篇选课的题解，然后没过… 那篇题解用的是求泛化物品的并（徐持衡《浅谈几类背包题》） 虽然说洛谷好像还没有上下界优化的题解..但最近好几篇题解没过审，都不太想在洛谷发题解了…]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈邻项交换排序的应用以及需要注意的问题]]></title>
    <url>%2F%E6%B5%85%E8%B0%88%E9%82%BB%E9%A1%B9%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F%E7%9A%84%E5%BA%94%E7%94%A8%E4%BB%A5%E5%8F%8A%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[邻项交换排序是一种常见的贪心算法，通过比较两个相邻元素交换前后的优劣对整个序列进行排序，从而使得这个序列成为题目所求的最优解。然而，邻项交换排序的应用有一些需要注意的地方，稍有不慎便会成为一个错误的算法。 算法简介例题引入题目来源NOIP2012提高组D1T2 国王游戏 题目描述恰逢 $H$ 国国庆，国王邀请 $n$ 位大臣来玩一个有奖游戏。首先，他让每个大臣在左、右手上面分别写下一个整数，国王自己也在左、右手上各写一个整数。然后，让这 $n $位大臣排成一排，国王站在队伍的最前面。排好队后，所有的大臣都会获得国王奖赏的若干金币，每位大臣获得的金币数分别是：排在该大臣前面的所有人的左手上的数的乘积除以他自己右手上的数，然后向下取整得到的结果。 国王不希望某一个大臣获得特别多的奖赏，所以他想请你帮他重新安排一下队伍的顺序，使得获得奖赏最多的大臣，所获奖赏尽可能的少。注意，国王的位置始终在队伍的最前面。 输入格式第一行包含一个整数 $n$ ，表示大臣的人数。 第二行包含两个整数 $a$ 和 $b$ ，之间用一个空格隔开，分别表示国王左手和右手上的整数。 接下来 $n$ 行，每行包含两个整数 $a$ 和 $b$ ，之间用一个空格隔开，分别表示每个大臣左手和右手上的整数。 输出格式一个整数，表示重新排列后的队伍中获奖赏最多的大臣所获得的金币数。 数据范围对于 $20\%$ 的数据，有 $1\le n\le 10,0&lt;a,b&lt;8$； 对于 $40\%$ 的数据，有 $1\le n\le 20,0&lt;a,b&lt;8$； 对于 $60\%$ 的数据，有 $1\le n\le 100$； 对于 $60\%$ 的数据，保证答案不超过 $10^9$； 对于 $100\%$ 的数据，有 $1\le n\le 1000,0&lt;a,b&lt;10000$ 。 使用邻项交换排序解决问题选取相邻的两个大臣 $i$ 和 $j$ （$j$ 此时在 $i$ 后一个），分别用 $a_i,b_i,a_j,b_j$ 表示这两位大臣左手上和右手上的数字，设这两位大臣前面的所有大臣左手上的数乘积为 $k$ 。 此时，若调整这两名大臣的顺序，对前面和后面的大臣都不会造成影响，因此我们只要使得这两位大臣中获得较多奖赏的那位获得的奖赏尽量少即可。 当 $i$ 在前 $j$ 在后时，这个值为 $\max(\frac k{b_i},\frac {k a_i}{b_j})$ 。 当 $j$ 在前 $i$ 在后时，这个值为 $\max(\frac k{b_j},\frac {k a_j}{b_i})$ 。 因此，若 $\max(\frac k{b_i},\frac {k a_i}{b_j})&gt;\max(\frac k{b_j},\frac {k a_j}{b_i})$ ，就需要交换 $i$ 和 $j$ 。 实际上，由于 $\frac {k a_i}{b_j}\ge\frac k{b_j},\frac {k a_j}{b_i}\ge\frac k{b_i}$ ，只需比较 $\frac {k a_i}{b_j}$ 和 $\frac {k a_j}{b_i}$ ，也就只需比较 $\frac {a_i}{b_j}$ 和 $\frac {a_j}{b_i}$ ，即：若 $a_i b_i&gt;a_j b_j$，就要交换 $i$ 和 $j$ 。 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N=1010;struct Node&#123; int a,b; bool operator&lt;(Node&amp; y) &#123; return a*b&lt;y.a*y.b; &#125;&#125; dc[N];long long n,ans,k;int main()&#123; cin&gt;&gt;n; for (int i=0;i&lt;=n;++i) &#123; cin&gt;&gt;dc[i].a&gt;&gt;dc[i].b; &#125; sort(dc+1,dc+n+1); k=dc[0].a; for (int i=1;i&lt;=n;++i) &#123; ans=max(ans,k/dc[i].b); k*=dc[i].a; &#125; cout&lt;&lt;ans; return 0;&#125; 使用以上代码即可得到60分，而AC此题需要使用高精度乘除法，不在本文讨论范围内。 使用邻项交换排序需要注意的问题另一道例题题目来源洛谷P2123 皇后游戏 题目描述皇后有 $n$ 位大臣，每位大臣的左右手上面分别写上了一个正整数。恰逢国庆节来临，皇后决定为 $n$ 位大臣颁发奖金，其中第 $i$ 位大臣所获得的奖金数目为第 $i－1$ 位大臣所获得奖金数目与前 $i$ 位大臣左手上的数的和的较大值再加上第 $i$ 位大臣右手上的数。 形式化地讲：我们设第 $i$ 位大臣左手上的正整数为 $a_i$ ，右手上的正整数为 $b_i$ ， 则第 $i$ 位大臣获得的奖金数目为 $c_i$ 可以表达为： $$c_i=\begin{cases}a_1+b_1 &amp; i=1\\\max(c_{i-1},\sum\limits_{j=1}^ia_j)+b_i &amp; 2\le i\le n\end{cases}$$ 当然，吝啬的皇后并不希望太多的奖金被发给大臣，所以她想请你来重新安排一下队伍的顺序，使得获得奖金最多的大臣，所获奖金数目尽可能的少。 注意：重新安排队伍并不意味着一定要打乱顺序，我们允许不改变任何一位大臣的位置。 输入格式第一行包含一个正整数 $T$ ，表示测试数据的组数。 接下来 $T$ 个部分，每个部分的第一行包含一个正整数 $n$ ，表示大臣的数目。 每个部分接下来 $n$ 行中，每行两个正整数，分别为 $a_i$ 和 $b_i$ ，含义如上文所述。 输出格式共 $T$ 行，每行包含一个整数，表示获得奖金最多的大臣所获得的奖金数目。 数据范围对于全部测试数据满足：$T\le10,1\le n\le20000,1\le a_i,b_i\le10^9$ 。 尝试用邻项交换排序解决问题还是选取相邻的两个大臣 $i$ 和 $j$ （$j$ 此时在 $i$ 后一个），交换 $i$ 和 $j$ 对前面的大臣无影响，对后面的大臣的影响在于排在后面的那个大臣获得的奖金，需要使之尽量小。 设这两个大臣前面的所有大臣左手上的数之和为 $\rm sum$ ，这两个大臣的再往前一个大臣得到的奖金是 $\rm pre$ 。 当 $i$ 在前 $j$ 在后时，这个值为 $\max(\max(\mathrm{pre},\mathrm{sum}+a_i)+b_i,\mathrm{sum}+a_i+a_j)+b_j$ 。 当 $j$ 在前 $i$ 在后时，这个值为 $\max(\max(\mathrm{pre},\mathrm{sum}+a_j)+b_j,\mathrm{sum}+a_j+a_i)+b_i$ 。 由于 $\max(x,y)+z=\max(x+z,y+z)$ ，需要比较的就是 $\max(\mathrm{pre}+b_i+b_j,\mathrm{sum}+a_i+b_i+b_j,\mathrm{sum}+a_i+a_j+b_j)$ 和 $\max(\mathrm{pre}+b_j+b_i,\mathrm{sum}+a_j+b_j+b_i,\mathrm{sum}+a_j+a_i+b_i)$ ，其中 $\mathrm{pre}+b_i+b_j=\mathrm{pre}+b_j+b_i$ ，需要比较的就是 $\max(\mathrm{sum}+a_i+b_i+b_j,\mathrm{sum}+a_i+a_j+b_j)$ 和 $\max(\mathrm{sum}+a_j+b_j+b_i,\mathrm{sum}+a_j+a_i+b_i)$ ，再用 $\mathrm{sum}+a_i+b_i+a_j+b_j$ 减去两边并变号，即：当 $\min(a_i,b_j)&gt;\min(a_j,b_i)$ 时，需要交换 $i$ 和 $j$。 于是，可以写出以下代码，并在洛谷上AC此题： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N=20010;struct Node&#123; int a,b; bool operator&lt;(Node&amp; y) &#123; return min(a,y.b)&lt;min(b,y.a); &#125;&#125; dc[N];long long ans,sum,t,n;int main()&#123; cin&gt;&gt;t; while (t--) &#123; cin&gt;&gt;n; for (int i=1;i&lt;=n;++i) &#123; cin&gt;&gt;dc[i].a&gt;&gt;dc[i].b; &#125; sort(dc+1,dc+n+1); ans=sum=0; for (int i=1;i&lt;=n;++i) &#123; sum+=dc[i].a; ans=max(ans,sum)+dc[i].b; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; hack数据事实上，上面的做法是错误的，无法通过下面这组数据： 1234567891011241 11 13 52 741 13 51 12 7 这两组数据只有大臣给出的顺序不同，但上面的代码输出为： 121617 输出中间结果，可以发现，排列后的最终结果分别为： 12341 11 12 73 5 和 12341 13 51 12 7 这两种排列方式都满足 $\forall i\in [1,n),\min(a_i,b_{i+1})\le\min(a_{i+1},b_i)$，但第二种方式并不是最优解。具体原因将在下文分析。 严格弱序严格弱序简介要知道为什么这种做法是错误的，首先需要了解严格弱序（strict weak ordering）。 对于一个比较运算符（用“$&lt;$”表示此运算符，用“$\not&lt;$”表示不满足此运算符），若满足以下四个条件，则称其是满足严格弱序的： $x\not&lt;x$ （非自反性） 若 $x&lt;y$，则 $y\not&lt;x$ （非对称性） 若 $x&lt;y,y&lt;z$，则 $x&lt;z$ （传递性） 若 $x\not&lt;y,y\not&lt;x,y\not&lt;z,z\not&lt;y$，则 $x\not&lt;z,z\not&lt;x$ （不可比性的传递性） 而 C++ 标准库要求用于排序的运算符必须满足严格弱序： It has to be antisymmetric. This means that for operator $&lt;$: If $x &lt; y$ is true, then $y &lt; x$ is false. This means that for a predicate op(): If op(x,y) is true, then op(y,x) is false. It has to be transitive. This means that for operator $&lt;$: If $x &lt; y$ is true and $y &lt; z$ is true, then $x &lt; z$ is true. This means that for a predicate op(): If op(x,y) is true and op(y,z) is true, then op(x,z) is true. It has to be irreflexive. This means that for operator $&lt;$: $x &lt; x$ is always false. This means that for a predicate op(): op(x,x) is always false. It has to have transitivity of equivalence, which means roughly: If a is equivalent to b and b is equivalent to c, then a is equivalent to c. This means that for operator $&lt;$: If $!(a&lt;b) \&amp;\&amp; !(b&lt;a)$ is true and $!(b&lt;c) \&amp;\&amp; !(c&lt;b)$ is true then $!(a&lt;c) \&amp;\&amp; !(c&lt;a)$ is true. This means that for a predicate op(): If op(a,b), op(b,a), op(b,c), and op(c,b) all yield false, then op(a,c) and op(c,a) yield false. 上述做法的判断条件满足传递性，但不满足不可比性的传递性。 满足传递性的证明命题：$\forall \begin{cases}\min(a_i,b_j)&lt;\min(a_j,b_i)\\\min(a_j,b_k)&lt;\min(a_k,b_j)\end{cases}$，有 $\min(a_i,b_k)&lt;\min(a_k,b_i)$。 将上式拆解成逻辑式，即证： $\forall \begin{cases}\,(a_i&lt;a_j\lor b_j&lt;a_j)\land(a_i&lt;b_i\lor b_j&lt;b_i) \\\,(a_j&lt;a_k\lor b_k&lt;a_k)\land(a_j&lt;b_j\lor b_k&lt;b_j)\end{cases}$，有 $(a_i&lt;a_k\lor b_k&lt;a_k)\land(a_i&lt;b_i\lor b_k&lt;b_i)$。 假设原命题不成立，即 $\exists\begin{cases}\,(a_i&lt;a_j\lor b_j&lt;a_j)\land(a_i&lt;b_i\lor b_j&lt;b_i)&amp;(1) \\\,(a_j&lt;a_k\lor b_k&lt;a_k)\land(a_j&lt;b_j\lor b_k&lt;b_j)&amp;(2) \\\,(a_i\ge a_k\land b_k\ge a_k)\lor(a_i\ge b_i\land b_k\ge b_i)&amp;(3)\end{cases}$ 分别讨论 $(3)$ 式成立的两种情况： 若 $a_i\ge a_k\land b_k\ge a_k$，由 $(2)$ 式得 $a_j&lt;a_k$，进而推出 $a_j&lt;a_i$，再由 $(1)$ 式得 $b_j&lt;a_j$，再由 $(2)$ 式得到 $b_k&lt;b_j$，所以 $b_k&lt;b_j&lt;a_j&lt;a_k$，与 $b_k\ge a_k$ 矛盾，不成立。 若 $a_i\ge b_i\land b_k\ge b_i$，与上面类似，由 $(1)$ 式得 $b_j&lt;b_i$，进而推出 $b_j&lt;b_k$，再由 $(2)$ 式得到 $a_j&lt;b_j$，再由 $(1)$ 式得到 $a_i&lt;a_j$，所以 $a_i&lt;a_j&lt;b_j&lt;b_i$，与 $a_i\ge b_i$ 矛盾，不成立。 综上所述，假设不成立。 所以，$P_{i,j}=\min(a_i,b_j)&lt;\min(a_j,b_i)$ 具有传递性。 不具有不可比性的传递性的证明命题：$\forall \begin{cases}\min(a_i,b_j)=\min(a_j,b_i)\\\min(a_j,b_k)=\min(a_k,b_j)\end{cases}$，有 $\min(a_i,b_k)=\min(a_k,b_i)$。 很明显，当 $a_j=b_j$ 且都很小时存在反例，如： $$\begin{array}{c|c|c}&amp;a&amp;b\\i&amp;3&amp;5\\j&amp;1&amp;1\\k&amp;2&amp;7\end{array}$$ $\begin{cases}\min(3,1)=\min(1,5)\\\min(1,7)=\min(2,1)\end{cases}$，但 $\min(3,7)\ne \min(2,5)$。 这样的反例还有很多，所以，$P_{i,j}=\min(a_i,b_j)&lt;\min(a_j,b_i)$ 不具有不可比性的传递性。 为何会错简单地说，$P_{i,j}=\min(a_i,b_j)&lt;\min(a_j,b_i)$ 不满足严格弱序，不能作为 std::sort 的比较函数。 究其原因，“不具有不可比性的传递性”意味着：将序列中若干个不可比的相邻元素对（在这种比较方式下即 $\min(a_i,b_{i+1})=\min(a_{i+1},b_i)$ 的 $i$ 和 $i+1$）互换后，可能会出现前面的元素“大于”后面的元素（在这种比较方式下即出现 $\min(a_i,b_{i+1})&gt;\min(a_{i+1},b_i)$），从而使得原先的排列方式不是最优的。 正确解法更加完善的贪心解法比较相邻两项时，若 $\min(a_i,b_j)=\min(a_j,b_i)$ ，从全局来看，由于 $a$ 的前缀和对答案有一定的影响，把 $a$ 更小的放前面是更优的。从而可以得到这样一个解法： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N=20010;struct Node&#123; int a,b; bool operator&lt;(Node&amp; y) &#123; return min(a,y.b)==min(b,y.a)?a&lt;y.a:min(a,y.b)&lt;min(b,y.a); &#125;&#125; dc[N];long long ans,sum,t,n;int main()&#123; cin&gt;&gt;t; while (t--) &#123; cin&gt;&gt;n; for (int i=1;i&lt;=n;++i) &#123; cin&gt;&gt;dc[i].a&gt;&gt;dc[i].b; &#125; sort(dc+1,dc+n+1); ans=sum=0; for (int i=1;i&lt;=n;++i) &#123; sum+=dc[i].a; ans=max(ans,sum)+dc[i].b; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; 这个解法的正确性将在下文证明。 一个解法是否正确的判断方式由上文的讨论可以得知，一个排序方式 $P_{i,j}$ 要是正解，需要满足两个条件： 满足严格弱序。 $\forall P_{i,j}=true$，$\min(a_i,b_j)\le\min(a_j,b_i)$ 。 即，可以作为比较函数，且排序完成后任意交换相邻元素均不会使答案更优。 从而可以写出下面的正解判断器： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;bool cmp(int i,int j);int a[10],b[10];int main()&#123; for (a[0]=1;a[0]&lt;=6;++a[0]) &#123; for (b[0]=1;b[0]&lt;=6;++b[0]) &#123; if (cmp(0,0)) &#123; printf("No irreflexivity:%d %d\n",a[0],b[0]); &#125; for (a[1]=1;a[1]&lt;=6;++a[1]) &#123; for (b[1]=1;b[1]&lt;=6;++b[1]) &#123; if (cmp(0,1)&amp;&amp;min(a[0],b[1])&gt;min(a[1],b[0])) &#123; printf("Not the best:%d %d %d %d\n",a[0],b[0],a[1],b[1]); &#125; for (a[2]=1;a[2]&lt;=6;++a[2]) &#123; for (b[2]=1;b[2]&lt;=6;++b[2]) &#123; if (cmp(0,1)&amp;&amp;cmp(1,2)&amp;&amp;!cmp(0,2)) &#123; printf("No transitivity:%d %d %d %d %d %d\n",a[0],b[0],a[1],b[1],a[2],b[2]); &#125; if (!cmp(0,1)&amp;&amp;!cmp(1,0)&amp;&amp;!cmp(1,2)&amp;&amp;!cmp(2,1)&amp;&amp;(cmp(0,2)||cmp(2,0))) &#123; printf("No transitivity of incomparability:%d %d %d %d %d %d\n",a[0],b[0],a[1],b[1],a[2],b[2]); &#125; &#125; &#125; &#125; &#125; &#125; &#125; return 0;&#125;bool cmp(int i,int j)&#123; return min(a[i],b[j])==min(a[j],b[i])?a[i]&lt;a[j]:min(a[i],b[j])&lt;min(a[j],b[i]);&#125; 运行程序，没有任何输出，说明上文所述的排序方式是一个正解。 用其它排序方式替换 cmp，若没有任何输出即可作为本题的正确排序方式。 下面是几种排序方式的例子： 1234bool cmp(int i,int j)&#123; return min(a[i],b[j])==min(a[j],b[i])?b[i]&gt;b[j]:min(a[i],b[j])&lt;min(a[j],b[i]);&#125; 输出为空，是正解。 1234bool cmp(int i,int j)&#123; return min(a[i],b[j])&lt;min(a[j],b[i]);&#125; 共输出1694行，前10行如下： 12345678910No transitivity of incomparability:1 2 1 1 2 1No transitivity of incomparability:1 2 1 1 2 2No transitivity of incomparability:1 2 1 1 2 3No transitivity of incomparability:1 2 1 1 2 4No transitivity of incomparability:1 2 1 1 2 5No transitivity of incomparability:1 2 1 1 2 6No transitivity of incomparability:1 2 1 1 3 1No transitivity of incomparability:1 2 1 1 3 2No transitivity of incomparability:1 2 1 1 3 3No transitivity of incomparability:1 2 1 1 3 4 1234bool cmp(int i,int j)&#123; return min(a[i],b[j])==min(a[j],b[i])?a[i]&gt;a[j]:min(a[i],b[j])&lt;min(a[j],b[i]);&#125; 共输出280行，前10行如下： 12345678910No transitivity:1 2 2 1 1 1No transitivity:1 2 2 2 1 1No transitivity:1 2 2 3 1 1No transitivity:1 2 2 4 1 1No transitivity:1 2 2 5 1 1No transitivity:1 2 2 6 1 1No transitivity:1 2 3 1 1 1No transitivity:1 2 3 2 1 1No transitivity:1 2 3 3 1 1No transitivity:1 2 3 4 1 1 1234bool cmp(int i,int j)&#123; return min(a[i],b[j])&lt;=min(a[j],b[i]);&#125; 共输出883行，前10行如下： 12345678910No irreflexivity:1 1No irreflexivity:1 2No irreflexivity:1 3No irreflexivity:1 4No irreflexivity:1 5No irreflexivity:1 6No irreflexivity:2 1No transitivity:2 1 1 1 1 2No transitivity:2 1 1 1 1 3No transitivity:2 1 1 1 1 4 总结在可以通过比较相邻两项得出交换或不交换一定不会更差时，可以通过邻项交换排序的方式来得到最优解。 邻项交换排序的比较函数需要满足严格弱序，并且排序完成后任意交换相邻元素都不会更优。 使用这种算法时，一定要注意以上两点，才能得到真正正确的算法。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIp2018提高组游记]]></title>
    <url>%2FNOIp2018%E6%8F%90%E9%AB%98%E7%BB%84%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Day1T1 积木大赛NOIp2013D2T1…..看到的时候我还以为我记错了，以为原题是一次可以随便加，这题只能加一，出考场后查了下发现一模一样。 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int N=100010;int n,d[N],ans;int main()&#123; int i; scanf("%d",&amp;n); for (i=1;i&lt;=n;++i) &#123; scanf("%d",d+i); if (d[i]&gt;d[i-1]) &#123; ans+=d[i]-d[i-1]; &#125; &#125; cout&lt;&lt;ans; return 0;&#125; T2 货币系统去掉可以由其它货币拼成的货币，这个结论倒是很快猜到了。但由于xkdyh留下的阴影，一开始我还写了个exgcd…幸好大样例比较良心，有一组数据是三种货币拼成另一种。然后再仔细一看，发现是个完全背包… 简单证明一下： 结论：对于一个没有任何一种货币可以由系统内其它货币拼成的货币系统 $(n,A)$，与其等价的货币系统 $(m,B)$ 只能是 $(n,A)$ 自身或者加上一些能由 $(n,A)$ 表示的数。 若 $A\not\subseteq B$，任取 $t\in (A-B)$，那么在 $B$ 中必然有一些元素能够拼成 $t$，而这些元素在 $A$ 中必然有不能表示的（否则与 $A$ 中没有任何一种货币可以由系统内其它货币拼成矛盾），而存在 $(m,B)$ 能表示而 $(n,A)$ 不能表示的数与 $(n,A),(m,B)$ 等价矛盾，不成立。 若 $B$ 中有 $(n,A)$ 所不能表示的元素，依然与 $(n,A),(m,B)$ 等价矛盾，不成立。 所以命题得证。 排个序然后完全背包去掉能被系统内其它货币表示的货币即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int t,n,a[110],maxx;bool f[25010];int main()&#123; int i,j,ans; scanf("%d",&amp;t); while (t--) &#123; scanf("%d",&amp;n); ans=n; maxx=0; for (i=1;i&lt;=n;++i) &#123; scanf("%d",a+i); maxx=max(maxx,a[i]); &#125; sort(a+1,a+n+1); memset(f,false,sizeof(f)); f[0]=true; for (i=1;i&lt;=n;++i) &#123; if (f[a[i]]) &#123; --ans; continue; &#125; for (j=0;j+a[i]&lt;=maxx;++j) &#123; if (f[j]) &#123; f[j+a[i]]=true; &#125; &#125; &#125; printf("%d\n",ans); &#125; return 0;&#125; T3 赛道修建看到这题就想起了ylh当时跟我一个房间的时候切掉的 CF div.2 E，但赛后发现不一样… 出考场得知dew、ylh都切掉了这题，然而我只写了直径、链和菊花图的 $55$ 分…凉凉凉 Day2T1 旅行一开始看错题了，以为是最小字典序生成树，还在想为什么 $m$ 这么小..然后仔细一看题，发现一条边只能回溯时重复经过，也就是最后得到的序列只能是个dfs序…数据范围很小，所以就枚举断边写了个 $O(n^2)$ 的，预处理边排序。然后出考场听一堆dalao在那说各种 $O(nlogn)$，$O(n)$ 做法…都不会QAQ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;const int N=5010;void dfs(int u);int n,m,cut,a[N][N],tot,e[N][2];bool vis[N],used[N]; //used用于对m个字典序取min，若used[i]=true说明断开第 i 条边时一定不是答案vector&lt;int&gt; g[N];int main()&#123; int i,j,u,v,minn; scanf("%d%d",&amp;n,&amp;m); for (i=0;i&lt;m;++i) &#123; scanf("%d%d",&amp;u,&amp;v); e[i][0]=u; e[i][1]=v; g[u].push_back(v); g[v].push_back(u); &#125; for (i=1;i&lt;=n;++i) &#123; sort(g[i].begin(),g[i].end()); &#125; if (n==m) &#123; for (cut=0;cut&lt;m;++cut) &#123; memset(vis,false,sizeof(vis)); tot=0; dfs(1); if (tot&lt;n) &#123; used[cut]=true; &#125; &#125; for (i=1;i&lt;=n;++i) &#123; minn=n; for (j=0;j&lt;m;++j) &#123; if (!used[j]&amp;&amp;a[j][i]&lt;minn) &#123; minn=a[j][i]; &#125; &#125; for (j=0;j&lt;m;++j) &#123; if (a[j][i]&gt;minn) &#123; used[j]=true; &#125; &#125; printf("%d",minn); if (i&lt;n) &#123; putchar(' '); &#125; &#125; &#125; else &#123; cut=m; dfs(1); for (i=1;i&lt;=n;++i) &#123; printf("%d",a[m][i]); if (i&lt;n) &#123; putchar(' '); &#125; &#125; &#125; return 0;&#125;void dfs(int u)&#123; if (vis[u]) &#123; return; &#125; vis[u]=true; a[cut][++tot]=u; int v,i; for (i=0;i&lt;g[u].size();++i) &#123; v=g[u][i]; if ((u!=e[cut][0]||v!=e[cut][1])&amp;&amp;(u!=e[cut][1]||v!=e[cut][0])) &#123; dfs(v); &#125; &#125;&#125; T2 填数游戏要是数据范围给到 $10^9$ 我就不会在考场上推半天了…一开始想了好久怎么 $O(nm)$ dp，虽然没想出来怎么做，但发现了暴力怎么写：一种方案合法等价于：对于每个点，它右边的点先往下再往右的路径小于它下面的点先往右再往下的路径。因为这两条路径分别是一个点向右走后最大的路径和向下走后最小的路径。然后打了个表，发现 $(n,m)=(n,n+1)\times 3^{m-n-1} (n\ge 2,m\ge n+1)$。于是开始跑 $(8,9)$ ，跑到11:50 还没跑出来…幸好发现了 $(n,n)$ 和 $(n,n+1)$ 之间也有一定的规律，把 $(8,9)$ 算出来了… 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const long long Ans[9][10]=&#123;&#123;0,0,0,0,0,0,0,0,0,0&#125;, &#123;0,0,0,0,0,0,0,0,0,0&#125;, &#123;0,4,12,36,0,0,0,0,0,0&#125;, &#123;0,8,36,112,336,0,0,0,0,0&#125;, &#123;0,16,108,336,912,2688,0,0,0,0&#125;, &#123;0,32,324,1008,2688,7136,21312,0,0,0&#125;, &#123;0,64,972,3024,8064,21312,56768,170112,0,0&#125;, &#123;0,128,2916,9072,24192,63936,170112,453504,1360128,0&#125;, &#123;0,256,8748,27216,72576,191808,510336,1360128,3626752,10879488&#125;&#125;; //其实有一部分表是不必要（没有意义）的...const long long M=1000000007;long long n,m,ans=1;int main()&#123; int i; cin&gt;&gt;n&gt;&gt;m; if (n&gt;m) &#123; swap(n,m); &#125; if (n==1) &#123; for (i=30;i&gt;=0;--i) &#123; ans=ans*ans%M; if (m&amp;(1&lt;&lt;i)) &#123; ans=ans*2%M; &#125; &#125; cout&lt;&lt;ans; &#125; else &#123; if (m&lt;=n+1) &#123; cout&lt;&lt;Ans[n][m]; return 0; &#125; else &#123; for (i=30;i&gt;=0;--i) &#123; ans=ans*ans%M; if ((m-n-1)&amp;(1&lt;&lt;i)) &#123; ans=ans*3%M; &#125; &#125; cout&lt;&lt;ans*Ans[n][n+1]%M; &#125; &#125; return 0;&#125; T3 保卫王国据说是ddp…考场上先10min写了44分（一开始还以为是55分Orz），然后看了下，觉得B1挺可写的，更新向上的链貌似就可以了，但最后没调出来.. Day7上（tui）了一个星期的whk..个鬼啊，三天在考期中，就上了两天whk。感觉从零开始的whk没有想象中那么恐怖… 一周不让去机房，一到家就在洛谷上测了一下公布的代码.其它题都和预估的一样，D2T1可能会被卡常，洛谷上开了O2最慢点 $0.9s$ ，而且不用vector好像也过不了，不知道是不是洛谷上内存开小了的原因… D1T3大众AC题我爆菊（花图）了… 幸好菊花图的数据分治放在了最后面，还有 $40$ 分。发现自己傻了，不知道为什么会认为只有最短的两条边可以拼在一起，其它边都只能自成一条道……. 听说D2T3不用ddp，还是我太菜了… 估分：$100+100+40+88/100+100+44=472/484$ Day10GGF咕咕咕，然而我把两个T3写了一下.. D1T3真的好简单…二分答案，check的时候dfs处理每棵子树并返回块数最多时最大剩余，具体就是把子树返回值排个序，双指针配对得到最多块数，然后从最后一个配对的左指针开始往前这么多个依次配对，最后看剩下的没配对的里面最大的是多少。（第二天换成CCF数据发现做法挂了）处理子树的时候二分返回值不影响复杂度但能保证正确性。 D2T3做法挺有趣的..倍增题做少了，估计做多了就比较套路了…预处理出 $f[u][1],f[u][0],g[u][1],g[u][0]$，分别代表选/不选 $u$ 时 子树 $u$ 答案，选/不选 $u$ 时 $u$ 往上（整颗树减去子树 $u$）的答案。倍增处理出祖先 $fa[u][i]$ 表示 $u$ 的 $2^i$ 祖先，用 $bz[u][i][0/1][0/1]$ 表示子树 $fa[u][i]$ 除去子树 $u$ ，其中 $u$ 选/不选，$fa[u][i]$ 选/不选的答案，可以在dfs预处理 f 和 g 的同时算出 $bz[u][0][0/1][0/1]$ ，然后 $bz[u][i][a][b]=\min(bz[u][i-1][a][0]+bz[fa[u][i-1]][i-1][0][b],bz[u][i-1][a][1]+bz[fa[u][i-1]][i-1][1][b])$ 。计算答案的时候如果是祖先关系直接倍增计算链上答案，再加上子树的 f 和 祖先上方的 g；否则倍增到 $lca$ 计算路径上的答案，两棵子树以及 $lca$ 上方的答案就是对应的 $f$ 和 $g$ 。然后写到 $22:15$，交上去 $68$ 分，回寝室…ab相邻的 $16$ 分真的好简单，不用倍增，考场上应该写出来的… Day11刚到学校听说自己 $480$ ，还在想8700k这么强，能把我的 travel 卡成 $96$ … 中午一看是 $489$，数据真有趣…D1T3 隔壁原 $95$ 变成 $80$，我昨天A的变成 $90$ 了，考场写的还骗到了 $5$ 分（$45$）…8700k天下第一！ Day25咕咕咕咕咕，$\mathrm{CN} 329$。]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>CCF系列赛事</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二维莫队解题报告]]></title>
    <url>%2F%E4%BA%8C%E7%BB%B4%E8%8E%AB%E9%98%9F%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[我写的莫队教程 其实这是一道bzoj上的题（bzoj2639，貌似是权限题，反正我看不了），在YALI做模拟赛的时候遇到了. 然后在网上查到了几篇关于这道题的博客，都和我的做法略有不同… 题目大意给你一个 $r*c$ 的矩阵，每个点有一个颜色， $m$ 个询问，每次询问一个子矩阵内，每种颜色出现次数的平方和。 $r,c\le 200,m\le 100000$ 做法简述首先我们要明白，莫队究竟在干什么。 莫队其实就是几个指针在那跳来跳去，每跳一步都需要一定的时间，通过对询问排序使得指针跳的总次数尽量小。 所以，这题中询问为 $(x_1,y_1,x_2,y_2)$ ，也就是四个指针在那跳，分别分块再排序就可以了，即： 123456789//为避免和cmath库中的y0y1重名，下文中代码内的x1,y1,x2,y2都用x,y,xx,yy代替struct Query&#123; int x,y,xx,yy,id; bool operator&lt;(Query&amp; b) &#123; return x/B==b.x/B?(y/B==b.y/B?(xx/B==b.xx/B?yy&lt;b.yy:xx&lt;b.xx):y&lt;b.y):x&lt;b.x; //B为分块大小 &#125;&#125; q[M]; 答案更新一般的莫队都是 $O(1)$ 更新答案的，然而这题是 $O(n)$ （用 $n$ 代表 $r,c$ ） 更新。 移动指针的时候，把一排一起修改。 需要注意的是，8个while的顺序如果排列不当在某些情况下会导致答案出错，所以最好是将所有add都放在del前面（实际上有多种排列顺序都可以在不进行“反操作”的情况下保证答案正确，所有add放在del前面只是其中一种），或者是对“反区间”进行“反操作”。 所谓“反区间”，如：修改 $x_1$ 指针时，本应进行add操作，而此时$y_1&gt;y_2+1$，那么就要将 $(y_2,y_1)$ 这个开区间内的所有点进行del。 while的排列顺序得当可以使“反区间”不可能出现。 “反操作”参考代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697while (x&lt;q[i].x)&#123; for (j=y;j&lt;=yy;++j) &#123; del(a[x][j]); &#125; for (j=yy+1;j&lt;y;++j) &#123; add(a[x][j]); &#125; ++x;&#125;while (y&lt;q[i].y)&#123; for (j=x;j&lt;=xx;++j) &#123; del(a[j][y]); &#125; for (j=xx+1;j&lt;x;++j) &#123; add(a[j][y]); &#125; ++y;&#125;while (xx&gt;q[i].xx)&#123; for (j=y;j&lt;=yy;++j) &#123; del(a[xx][j]); &#125; for (j=yy+1;j&lt;y;++j) &#123; add(a[xx][j]); &#125; --xx;&#125;while (yy&gt;q[i].yy)&#123; for (j=x;j&lt;=xx;++j) &#123; del(a[j][yy]); &#125; for (j=xx+1;j&lt;x;++j) &#123; add(a[j][yy]); &#125; --yy;&#125;while (x&gt;q[i].x)&#123; --x; for (j=y;j&lt;=yy;++j) &#123; add(a[x][j]); &#125; for (j=yy+1;j&lt;y;++j) &#123; del(a[x][j]); &#125;&#125;while (y&gt;q[i].y)&#123; --y; for (j=x;j&lt;=xx;++j) &#123; add(a[j][y]); &#125; for (j=xx+1;j&lt;x;++j) &#123; del(a[j][y]); &#125;&#125;while (xx&lt;q[i].xx)&#123; ++xx; for (j=y;j&lt;=yy;++j) &#123; add(a[xx][j]); &#125; for (j=yy+1;j&lt;y;++j) &#123; del(a[xx][j]); &#125;&#125;while (yy&lt;q[i].yy)&#123; ++yy; for (j=x;j&lt;=xx;++j) &#123; add(a[j][yy]); &#125; for (j=xx+1;j&lt;x;++j) &#123; del(a[j][yy]); &#125;&#125;out[q[i].id]=ans; 分块大小具体计算清楚非常复杂，这里只是估算一下. $x_1$ 指针的移动次数为 $O(mB)$，$y_2$ 指针的移动次数渐进复杂度中含有 $O\left(\frac{n^4}{B^3}\right)$，取 $mB=\frac{n^4}{B^3}$，得到 $B=nm^{-\frac{1}{4}}$ 总时间复杂度为 $O(mlogm+n^2m^{\frac{3}{4}})$ 反正这样的分块大小实测比 $\sqrt{n}$ 优秀…有兴趣的话可以严谨地算一算（如果发现我这个估算有问题可以直接在这篇博客下评论） 初始子矩阵任意一个空矩阵就可以了，如 $x_1=y_1=1,x_2=y_2=0$ 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N=210;const int M=100010;void add(int x);void del(int x);int r,c,m,B,a[N][N],lsh[N*N],tot,cnt[N*N],ans,out[M];struct Query&#123; int x,y,xx,yy,id; bool operator&lt;(Query&amp; b) &#123; return x/B==b.x/B?(y/B==b.y/B?(xx/B==b.xx/B?yy&lt;b.yy:xx&lt;b.xx):y&lt;b.y):x&lt;b.x; &#125;&#125; q[M];int main()&#123; int i,j,x=1,y=1,xx=0,yy=0; cin&gt;&gt;r&gt;&gt;c&gt;&gt;m; B=pow(r*c,0.5)/pow(m,0.25)+1.0; for (i=1;i&lt;=r;++i) &#123; for (j=1;j&lt;=c;++j) &#123; cin&gt;&gt;a[i][j]; lsh[tot++]=a[i][j]; //这题要离散化 &#125; &#125; sort(lsh,lsh+tot); tot=unique(lsh,lsh+tot)-lsh; for (i=1;i&lt;=r;++i) &#123; for (j=1;j&lt;=c;++j) &#123; a[i][j]=lower_bound(lsh,lsh+tot,a[i][j])-lsh; &#125; &#125; for (i=0;i&lt;m;++i) &#123; cin&gt;&gt;q[i].x&gt;&gt;q[i].y&gt;&gt;q[i].xx&gt;&gt;q[i].yy; q[i].id=i; &#125; sort(q,q+m); for (i=0;i&lt;m;++i) &#123; while (x&gt;q[i].x) &#123; --x; for (j=y;j&lt;=yy;++j) &#123; add(a[x][j]); &#125; &#125; while (xx&lt;q[i].xx) &#123; ++xx; for (j=y;j&lt;=yy;++j) &#123; add(a[xx][j]); &#125; &#125; while (y&gt;q[i].y) &#123; --y; for (j=x;j&lt;=xx;++j) &#123; add(a[j][y]); &#125; &#125; while (yy&lt;q[i].yy) &#123; ++yy; for (j=x;j&lt;=xx;++j) &#123; add(a[j][yy]); &#125; &#125; while (x&lt;q[i].x) &#123; for (j=y;j&lt;=yy;++j) &#123; del(a[x][j]); &#125; ++x; &#125; while (xx&gt;q[i].xx) &#123; for (j=y;j&lt;=yy;++j) &#123; del(a[xx][j]); &#125; --xx; &#125; while (y&lt;q[i].y) &#123; for (j=x;j&lt;=xx;++j) &#123; del(a[j][y]); &#125; ++y; &#125; while (yy&gt;q[i].yy) &#123; for (j=x;j&lt;=xx;++j) &#123; del(a[j][yy]); &#125; --yy; &#125; out[q[i].id]=ans; &#125; for (i=0;i&lt;m;++i) &#123; cout&lt;&lt;out[i]&lt;&lt;endl; &#125; return 0;&#125;void add(int x)&#123; ans=ans+2*cnt[x]+1; ++cnt[x];&#125;void del(int x)&#123; ans=ans-2*cnt[x]+1; --cnt[x];&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018国庆YALI集训游记]]></title>
    <url>%2F2018%E5%9B%BD%E5%BA%86YALI%E9%9B%86%E8%AE%AD%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[想了想，像之前那样简略地叙述题意和做法，根本没讲清楚，没有任何意义，还不如写写自己的感受。 感觉YALI真的是一所挺不错的学校吧。总是能有一机房的julao轮番吊打你，总是能有集训队的奆佬来给你出dltm、给你讲题。每天放学回酒店的路上还能看到操场上一群目测是田径队之类的同学在努力地训练着。到处都洋溢着「青春」的氛围，反倒是老师见得很少（或许是国庆的缘故吧..）。YALI在我心中已经不止是那个在OIerDb的“全国信息学竞赛学校排名2018”上排名第一的学校了。 这几天去掉失误基本上都能排在前 $20$，但其他julao也会失误，所以是不存在“如果没有失误”的… 既然生在了弱省，就更要把眼光放在省外。OIerDb学校排行榜$rank1\sqrt{}$，OIerDb学校排行榜$rank5\sqrt{}​$。 虽然写的很短，还是比之前几乎什么都没写好吧. ———————————————以上于7号上午——————————————— 到了YALI的学生们返校的下午，YALI变得和外高没什么两样了…或许是那些国庆还在学校的人们让我看到了YALI不同的一面吧.]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>集训</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[莫队、带修莫队、树上莫队详解]]></title>
    <url>%2F%E8%8E%AB%E9%98%9F%E3%80%81%E5%B8%A6%E4%BF%AE%E8%8E%AB%E9%98%9F%E3%80%81%E6%A0%91%E4%B8%8A%E8%8E%AB%E9%98%9F%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[这几天学习了莫队算法，试着写一篇比较详细的莫队教程吧… 普通莫队简介莫队是一种基于分块思想的离线算法，用于解决区间问题，适用范围如下： 只有询问没有修改。 允许离线。 在已知询问 $[l,r]$ 答案的情况下可以 $O(1)$ 得到 $[l,r-1],[l,r+1],[l-1,r],[l+1,r]$ 的答案。 满足以上三个条件就可以在 $O(n\sqrt{m}+m\log m)​$ 的时间复杂度下得到每个询问的解。 算法思想莫队的精髓就在于通过对询问进行排序，并把询问的结果作为下一个询问求解的基础，使得暴力求解的复杂度得到保证。 上文中“适用范围”的第三点“在已知询问 $[l,r]$ 答案的情况下可以 $O(1)$ 得到 $[l,r-1],[l,r+1],[l-1,r],[l+1,r]$ 的答案”即是“把询问的结果作为下一个询问求解的基础”的方法。 例题解析例：[国家集训队]小Z的袜子 在这题中，用 $cnt_i$ 表示当前处理的区间内颜色为i的袜子出现的次数，用 $\mathrm{len}$ 表示当前处理的区间的长度，用 $x$ 表示新增的那只袜子的颜色。 以已知区间 $[l,r]$ 的答案求解区间 $[l,r+1]$ 为例。分别处理分子和分母： 分母为任选两只袜子的组合总数，原先是 $\frac{\mathrm{len}(\mathrm{len}-1)}{2}$，现在是 $\frac{\mathrm{len}(\mathrm{len}+1)}{2}$，增加了 $\mathrm{len}$ 。 分子为两只袜子颜色相同的组合总数，比原来增加了 $cnt_x$，即新增的这只袜子和原本就在当前区间内的相同颜色的袜子的组合。 因此，将一只颜色为x的袜子计入答案的函数就可以写出来了： 12345678//fz代表分子，fm代表分母void add(int x)&#123; fz+=cnt[x]; ++cnt[x]; fm+=len; ++len;&#125; 同理可以写出将一只颜色为x的袜子移出答案的函数： 1234567void del(int x)&#123; --cnt[x]; fz-=cnt[x]; --len; fm-=len;&#125; 于是，我们就可以得到一个暴力的算法：用 $l$ 和 $r$ 分别记录当前区间的两个端点，然后用下面这段代码来更新答案（q[i].l,q[i].r代表正在处理的询问的两个端点，col[p]代表第 $p$ 只袜子的颜色）： 12345678910111213141516while (l&gt;q[i].l)&#123; add(col[--l]);&#125;while (r&lt;q[i].r)&#123; add(col[++r]);&#125;while (l&lt;q[i].l) &#123; del(col[l++]);&#125;while (r&gt;q[i].r)&#123; del(col[r--]);&#125; 然而，这个算法的时间复杂度是 $O(nm)$ 的（因为最坏情况下每次 $l$ 和 $r$ 两个指针都要走 $O(n)$ 的距离，而一共有 $m$ 次询问），和暴力完全一样甚至跑的更慢。 优化复杂度别忘了，之前我说过，莫队的精髓就在于通过对询问进行排序，使得暴力求解的复杂度得到保证。 我们的目的是使 $l$ 和 $r$ 两个指针走过的总距离尽量的小，这时候就要用到分块的思想了。 把整个区间 $[1,n]$ 分成若干块，以询问的左端点所在块为第一关键字，以询问的右端点大小为第二关键字，对询问进行排序，那么： 对于同一块的询问，$l$ 指针每次最多移动块的大小，$r$ 指针的移动则是单调的，总共移动最多 $n$ 。 对于不同块的询问，$l$ 每次换块时最多移动两倍块的大小， $r$ 每次换块时最多移动 $n$ 。 总结：（用 $B$ 表示块的大小）$l$ 指针每次移动 $O(B)$，$r$ 指针每块移动 $O(n)$ 。 所以： $l$ 的移动次数最多为询问数 $\times$ 块的大小，即 $O(mB)$ 。 $r$ 的移动次数最多为块的个数 $\times$ 总区间大小，即 $O(n^2/B)$ 。 因此，总移动次数为 $O(mB+n^2/B)$ 。 没错，这就是个双勾函数，所以当 $B=\sqrt{\frac{n^2}{m}}$ 即 $\frac{n}{\sqrt{m}}$ 时复杂度最小，为 $O(n\sqrt{m})$ 。 剩下的最后一个问题：初始的当前区间是什么？ 只要任意指定一个空区间就好了，如 $l=1,r=0$ 。 所以，整个莫队算法就可以概括为： 将询问记录下来。 以 $\frac{n}{\sqrt{m}}$ 为块的大小，以询问的左端点所在块为第一关键字，以询问的右端点大小为第二关键字，对询问进行排序。 暴力处理每个询问。 输出答案。 总的复杂度为 $O(n\sqrt{m}+m\log m)$ 。 P.S. 网上很多教程说分块大小取 $\sqrt{n}$ 最优，复杂度为 $O(n\sqrt{n})$，这是不严谨的，当n、m差别较大时使用 $\sqrt{n}$ 作为分块大小效率会明显偏低。 例题代码[国家集训队]小Z的袜子 AC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N=50010;void add(int x);void del(int x);int gcd(int a,int b);int n,m,B,fz,fm,len,col[N],cnt[N],ans[N][2];struct Query&#123; int l,r,id; bool operator&lt;(Query&amp; b) &#123; return l/B==b.l/B?r&lt;b.r:l&lt;b.l; &#125;&#125; q[N];int main()&#123; int i,l=1,r=0,g; cin&gt;&gt;n&gt;&gt;m; B=n/sqrt(m); for (i=1;i&lt;=n;++i) &#123; cin&gt;&gt;col[i]; &#125; for (i=0;i&lt;m;++i) &#123; cin&gt;&gt;q[i].l&gt;&gt;q[i].r; q[i].id=i; &#125; sort(q,q+m); for (i=0;i&lt;m;++i) &#123; if (q[i].l==q[i].r) &#123; ans[q[i].id][0]=0; ans[q[i].id][1]=1; continue; &#125; while (l&gt;q[i].l) &#123; add(col[--l]); &#125; while (r&lt;q[i].r) &#123; add(col[++r]); &#125; while (l&lt;q[i].l) &#123; del(col[l++]); &#125; while (r&gt;q[i].r) &#123; del(col[r--]); &#125; g=gcd(fz,fm); ans[q[i].id][0]=fz/g; ans[q[i].id][1]=fm/g; &#125; for (i=0;i&lt;m;++i) &#123; printf("%d/%d\n",ans[i][0],ans[i][1]); &#125; return 0;&#125;void add(int x)&#123; fz+=cnt[x]; ++cnt[x]; fm+=len; ++len;&#125;void del(int x)&#123; --cnt[x]; fz-=cnt[x]; --len; fm-=len;&#125;int gcd(int a,int b)&#123; return b==0?a:gcd(b,a%b);&#125; 其它例题小B的询问 带修莫队前面说过，普通的莫队只能解决没有修改的问题，那么带修改的问题怎么解决呢？带修莫队就是一种支持单点修改的莫队算法。 算法简介还是对询问进行排序，每个询问除了左端点和右端点还要记录这次询问是在第几次修改之后（时间），以左端点所在块为第一关键字，以右端点所在块为第二关键字，以时间为第三关键字进行排序。 暴力查询时，如果当前修改数比询问的修改数少就把没修改的进行修改，反之回退。 需要注意的是，修改分为两部分： 若修改的位置在当前区间内，需要更新答案（del原颜色，add修改后的颜色）。 无论修改的位置是否在当前区间内，都要进行修改（以供add和del函数在以后更新答案）。 分块大小的选择以及复杂度证明（用 $B$ 表示分块大小，$c$ 表示修改个数，$q$ 表示询问个数，l块表示以 $l/B$ 分的块，r块表示以 $r/B$ 分的块，每个l块包含 $n/B$ 个r块） 对于时间指针 $now$：对于每个r块，最坏情况下会移动 $c$，共有 $\left(\frac{n}{B}\right)^2$ 个r块，所以总移动次数为 $\frac{cn^2}{B^2}$ 。 对于左端点指针 $l$ ：l块内移动每次最多 $B$，换l块每次最多 $2B$，所以总移动次数为 $O(qB)$ 。 对于右端点指针 $r​$：r块内移动每次最多 $B​$，换r块每次最多 $2B​$，所有l块内移动次数之和为 $O(qB)​$；换l块时最多移动 $n​$，总的换l块时移动次数为 $O\left(\frac{n^2}{B}\right)​$；所以总的移动次数为 $O\left(qB+\frac{n^2}{B}\right)​$ 。 所以：总移动次数为 $O\left(\frac{cn^2}{B^2}+qB+\frac{n^2}{B}\right)$ 。 由于一般的题目都不会告诉你修改和询问分别的个数，所以统一用 $m​$ 表示，即 $O\left(\frac{mn^2}{B^2}+mB+\frac{n^2}{B}\right)​$ 。 那么 $B$ 取多少呢…Mathematica告诉我大约是这个： 所以还是不要纠结带修莫队的最佳分块大小好了…视作 $n=m$ 的话，就可以得到总移动次数为 $O\left(\frac{n^3}{B^2}+nB+\frac{n^2}{B}\right)$，那么 $B=n^{\frac{2}{3}}$ 时取最小值 $O\left(n^{\frac{5}{3}}\right)$ 。 所以：带修莫队的渐进时间复杂度为 $O\left(n\log n+n^{\frac{5}{3}}\right)$ （视作 $n=m$）。 例题代码这次就不详细分析例题了，直接上代码。 [国家集训队]数颜色 AC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;void add(int x);void del(int x);void modify(int x,int ti); //这个函数会执行或回退修改ti（执行还是回退取决于是否执行过，具体通过swap实现），x表明当前的询问是x，即若修改了区间[q[x].l,q[x].r]便要更新答案int n,m,B,cnt[1000010],a[50010],ans,ccnt,qcnt,now,out[50010];struct Change&#123; int p,col;&#125; c[50010];struct Query&#123; int l,r,t,id; bool operator&lt;(Query&amp; b) &#123; return l/B==b.l/B?(r/B==b.r/B?t&lt;b.t:r&lt;b.r):l&lt;b.l; &#125;&#125; q[50010];int main()&#123; int i,l=2,r=1; char type[10]; cin&gt;&gt;n&gt;&gt;m; B=pow(n,0.66666); for (i=1;i&lt;=n;++i) &#123; cin&gt;&gt;a[i]; &#125; for (i=1;i&lt;=m;++i) &#123; scanf("%s",type); if (type[0]=='Q') &#123; ++qcnt; cin&gt;&gt;q[qcnt].l&gt;&gt;q[qcnt].r; q[qcnt].t=ccnt; q[qcnt].id=qcnt; &#125; else &#123; ++ccnt; cin&gt;&gt;c[ccnt].p&gt;&gt;c[ccnt].col; &#125; &#125; sort(q+1,q+qcnt+1); for (i=1;i&lt;=qcnt;++i) &#123; while (l&gt;q[i].l) &#123; add(a[--l]); &#125; while (r&lt;q[i].r) &#123; add(a[++r]); &#125; while (l&lt;q[i].l) &#123; del(a[l++]); &#125; while (r&gt;q[i].r) &#123; del(a[r--]); &#125; while (now&lt;q[i].t) &#123; modify(i,++now); &#125; while (now&gt;q[i].t) &#123; modify(i,now--); &#125; out[q[i].id]=ans; &#125; for (i=1;i&lt;=qcnt;++i) &#123; cout&lt;&lt;out[i]&lt;&lt;endl; &#125; return 0;&#125;void add(int x)&#123; if (cnt[x]++==0) &#123; ++ans; &#125;&#125;void del(int x)&#123; if (--cnt[x]==0) &#123; --ans; &#125;&#125;void modify(int x,int ti)&#123; if (c[ti].p&gt;=q[x].l&amp;&amp;c[ti].p&lt;=q[x].r) &#123; del(a[c[ti].p]); add(c[ti].col); &#125; swap(a[c[ti].p],c[ti].col); //下次执行时必定是回退这次操作，直接互换就可以了 &#125; 其它例题CF940F Machine Learning 树上莫队其实，莫队算法除了序列还可以用于树。复杂度同序列上的莫队（不带修 $O(n\sqrt{m}+m\log m)​$，带修 $O\left(n\log n+n^{\frac{5}{3}}\right)$）。 例题：[WC2013]糖果公园 分块方式这里需要看一道专门为树上莫队设计的题目 [SCOI2005]王室联邦。 用这道题所要求的方式进行分块，并用后文的方式更新答案，就能保证复杂度（复杂度分析见后文）。 那么如何满足每块大小在 $[B,3B]$，块内每个点到核心点路径上的所有点都在块内呢？ 这里先提供一种构造方式，再予以证明： dfs，并创建一个栈，dfs一个点时先记录初始栈顶高度，每dfs完当前节点的一棵子树就判断栈内（相对于刚开始dfs时）新增节点的数量是否≥B，是则将栈内所有新增点分为同一块，核心点为当前dfs的点，当前节点结束dfs时将当前节点入栈，整个dfs结束后将栈内所有剩余节点归入已经分好的最后一个块。 参考代码： 1234567891011121314151617181920212223242526272829void dfs(int u,int fa)&#123; int t=top; for (int i=head[u];i;i=nxt[i]) &#123; int v=to[i]; if (v!=fa) &#123; dfs(v,u); if (top-t&gt;=B) &#123; key[++tot]=u; while (top&gt;t) bl[stk[top--]]=tot; &#125; &#125; &#125; stk[++top]=u;&#125;int main()&#123; //....... dfs(1,0); if (!tot) ++tot; key[tot]=1; while (top) bl[stk[top--]]=tot;&#125; 如果你看懂了这个方法的话，每块大小≥B是显然的，下面证明为何每块大小≤3B： 对于当前节点的每一棵子树： 若未被分块的节点数≥B，那么在dfs这棵子树的根节点时就一定会把这棵子树的一部分分为一块直至这棵子树的剩余节点数≤B，所以这种情况不存在。 若未被分块的节点数=B，这些节点一定会和栈中所有节点分为一块，栈中之前还剩 $[0,B-1]$ 个节点，那么这一块的大小为 $[B,2B-1]$ 。 若未被分块的节点数&lt;B，当未被分块的节点数+栈中剩余节点数≥B时，这一块的大小为 $[B,2B-1)$，否则继续进行下一棵子树。 对于dfs结束后栈内剩余节点，数量一定在 $[1,B]​$ 内，而已经分好的每一块的大小为 $[B,2B-1]​$，所以每块的大小都在 $[B,3B)​$ 内。 修改方式所谓“修改”，就是由询问 $(cu,cv)$ 更新至询问 $(tu,tv)$ 。 如果把两条路径上的点全部修改复杂度是和暴力一样的，所以需要做一些处理。 （下文中 $T(u,v)​$ 表示 $u​$ 到 $v​$ 的路径上除 $lca(u,v)​$ 外的所有点构成的集合，$S(u,v)​$ 代表u到v的路径，$xor​$ 表示集合对称差（就跟异或差不多）） 两个指针 $cu,cv​$ （相当于序列莫队的 $l,r​$ 两个指针）， $ans​$记录$T(cu,cv)​$ 的答案，$vis​$ 数组记录每个节点是否在 $T(cu,cv)​$ 内； 由 $T(cu,cv)​$ 更新至 $T(tu,tv)​$ 时，将 $T(cu,tu)​$ 和 $T(cv,tv)​$ 的 $vis​$ 分别取反，并相应地更新答案； 将答案记录到 $out$ 数组（离线后用于输出那个）时对 $lca(cu,cv)$ （此时的 $cu,cv$ 已更新为上一步中的 $tu,tv$） 的 $vis$ 取反并更新答案，记录完再改回来（因为 $lca​$ 处理比较麻烦，这样搞比较方便）。 第二步证明如下： $\quad\,T(cu,cv) xor T(tu,tv)$ $=[S(cu,root) xor S(cv,root)] xor [S(tu,root) xor S(tv,root)]$ （lca及以上相消） $=[S(cu,root) xor S(tu,root)] xor [S(cv,root) xor S(tv,root)]$ （交换律、结合律） $=T(cu,tu) xor T(cv,tv)$ 之所以要把 $T(cu,cv) xor T(tu,tv)$ 转化成 $T(cu,tu) xor T(cv,tv)$，是因为这样的话就能通过对询问排序来保证复杂度。排序方式就是以 $u$ 所在块编号为第一关键字，$v​$ 的编号为第二关键字排序。如果是带修莫队，就还要以时间为第三关键字。 关于单点修改树上莫队的单点修改和序列莫队类似，唯一不同就是，修改后是否更新答案通过 $vis$ 数组判断。 复杂度分析每块大小在 $[B,3B)$，所以两点间路径长度也在 $[B,3B)$，块内移动就是 $\mathcal O(B)$ 的；编号相邻的块位置必然是相邻的，所以两块间路径长度也是 $\mathcal O(B) $；然后就和序列莫队的复杂度分析类似了… 例题代码[WC2013]糖果公园 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N=100010;void pathmodify(int u,int v); //将T(u,v)取反并更新答案void opp(int x); //将节点x取反并更新答案void modify(int ti); //进行或回退修改tiint lca(int u,int v);void dfs(int u); //进行分块并记录dep数组、f数组（用于求lca、两点间路径）void add(int u,int v);int head[N],nxt[N&lt;&lt;1],to[N&lt;&lt;1],cnt;int n,m,Q,B,bl[N],tot,V[N],W[N],a[N],stk[N],top,qcnt,ccnt,dep[N],f[20][N],num[N],now;long long ans,out[N];bool vis[N];struct Query&#123; int u,v,t,id; bool operator&lt;(Query&amp; y) &#123; return bl[u]==bl[y.u]?(bl[v]==bl[y.v]?t&lt;y.t:bl[v]&lt;bl[y.v]):bl[u]&lt;bl[y.u]; &#125;&#125; q[N];struct Change&#123; int p,x;&#125; c[N];int main()&#123; int i,j,u,v,lc,type; cin&gt;&gt;n&gt;&gt;m&gt;&gt;Q; B=pow(n,0.666); for (i=1;i&lt;=m;++i) cin&gt;&gt;V[i]; for (i=1;i&lt;=n;++i) cin&gt;&gt;W[i]; for (i=1;i&lt;n;++i) &#123; cin&gt;&gt;u&gt;&gt;v; add(u,v); add(v,u); &#125; dfs(1); for (i=1;i&lt;=16;++i) &#123; for (j=1;j&lt;=n;++j) &#123; f[i][j]=f[i-1][f[i-1][j]]; &#125; &#125; while (top) bl[stk[top--]]=tot; for (i=1;i&lt;=n;++i) cin&gt;&gt;a[i]; for (i=0;i&lt;Q;++i) &#123; cin&gt;&gt;type; if (type==0) &#123; ++ccnt; cin&gt;&gt;c[ccnt].p&gt;&gt;c[ccnt].x; &#125; else &#123; cin&gt;&gt;q[qcnt].u&gt;&gt;q[qcnt].v; q[qcnt].t=ccnt; q[qcnt].id=qcnt; ++qcnt; &#125; &#125; sort(q,q+qcnt); u=v=1; for (i=0;i&lt;qcnt;++i) &#123; pathmodify(u,q[i].u); pathmodify(v,q[i].v); u=q[i].u; v=q[i].v; while (now&lt;q[i].t) modify(++now); while (now&gt;q[i].t) modify(now--); lc=lca(u,v); opp(lc); out[q[i].id]=ans; opp(lc); &#125; for (i=0;i&lt;qcnt;++i) cout&lt;&lt;out[i]&lt;&lt;endl; return 0;&#125;void pathmodify(int u,int v)&#123; if (dep[u]&lt;dep[v]) swap(u,v); while (dep[u]&gt;dep[v]) &#123; opp(u); u=f[0][u]; &#125; while (u!=v) &#123; opp(u); opp(v); u=f[0][u]; v=f[0][v]; &#125;&#125;void opp(int x)&#123; if (vis[x]) ans-=1ll*V[a[x]]*W[num[a[x]]--]; else ans+=1ll*V[a[x]]*W[++num[a[x]]]; vis[x]^=1;&#125;void modify(int ti)&#123; if (vis[c[ti].p]) &#123; opp(c[ti].p); swap(a[c[ti].p],c[ti].x); opp(c[ti].p); &#125; else swap(a[c[ti].p],c[ti].x);&#125;int lca(int u,int v)&#123; if (dep[u]&lt;dep[v]) &#123; swap(u,v); &#125; int i; for (i=0;i&lt;=16;++i) &#123; if ((dep[u]-dep[v])&amp;(1&lt;&lt;i)) &#123; u=f[i][u]; &#125; &#125; if (u==v) return u; for (i=16;i&gt;=0;--i) &#123; if (f[i][u]!=f[i][v]) &#123; u=f[i][u]; v=f[i][v]; &#125; &#125; return f[0][u];&#125;void dfs(int u)&#123; int t=top; for (int i=head[u];i;i=nxt[i]) &#123; int v=to[i]; if (v!=f[0][u]) &#123; f[0][v]=u; dep[v]=dep[u]+1; dfs(v); if (top-t&gt;=B) &#123; ++tot; while (top&gt;t) bl[stk[top--]]=tot; &#125; &#125; &#125; stk[++top]=u;&#125;void add(int u,int v)&#123; nxt[++cnt]=head[u]; head[u]=cnt; to[cnt]=v;&#125; 莫队的扩展其实莫队可以扩展到高维，参见二维莫队解题报告。 更一般地，若 $Q(x_1,x_2,\cdots,x_k)​$ 为一个询问，$\forall i\in[1,k]​$，$x_i​$ 的规模都为 $n​$，可以在时间 $\mathrm{T}​$ 内求解 $Q(x_1,x_2,\cdots,x_i\pm 1,\cdots,x_n)​$，共有 $m​$ 个询问，那么就可以在 $O\left(km\log m+nTm^\frac{k-1}{k}\right)​$ 的时间复杂度下离线求解。 （蒟蒻的大胆猜想而已..并没有严格证明） To be finished：回滚莫队（只增莫队）..（有时间再填坑吧Orz）（等OI Diary更新我就填坑）]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>莫队</tag>
        <tag>离线算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[好用的网站]]></title>
    <url>%2F%E5%A5%BD%E7%94%A8%E7%9A%84%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[一些好用的网站。 $\text{图床}$ $\text{几何}$ $\text{图论}$ $\text{函数}$ $\text{找规律}$ $\text{矩阵运算}$ $\text{在线汇编编译器}$ $\mathrm{C++}$ $\LaTeX\text{公式大全}​$ $\LaTeX\text{公式奆全}$ $\text{.tex}$教程 $\text{OI Wiki}$ $\text{Wolfram Alpha}$ $\text{oier数据库}$]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>网站</tag>
      </tags>
  </entry>
</search>
